[
  {
    "objectID": "examples.html",
    "href": "examples.html",
    "title": "Examples",
    "section": "",
    "text": "Here you can find several examples how ‘brdr’ can be used:\n\n\n\n\n\n\n   \n    \n    \n      Order By\n      Default\n      \n        Title\n      \n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Author\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\nGeojsonLoader\n\n\n\nLoader\n\nGeojsonLoader\n\n\n\nexample how a GeojsonLoader is used to load thematic data\n\n\n\nKarel Dieussaert\n\n\nJan 14, 2026\n\n\n\n\n\n\n\n\n\n\nLambert72 to Lambert 08\n\n\n\nLambert72/08\n\nTransformation\n\n\n\nSimple example to align a data-object after Lambert72/08-transformation\n\n\n\nKarel Dieussaert\n\n\nJan 14, 2026\n\n\n\n\n\n\n\n\n\n\nAnimated GIF\n\n\n\nAnimation\n\n\n\nExample to create a animated GIF showing the principle of brdr\n\n\n\nKarel Dieussaert\n\n\nJan 7, 2026\n\n\n\n\n\n\n\n\n\n\nPrediction\n\n\n\nPrediction\n\n\n\nExample of a simple prediction by using brdr\n\n\n\nKarel Dieussaert\n\n\nJan 7, 2026\n\n\n\n\n\n\n\n\n\n\nNetworkGeometryProcessor\n\n\n\nNetworkGeometryProcessor\n\nPrediction\n\nGraph\n\n\n\nSimple example to get started\n\n\n\nKarel Dieussaert\n\n\nJan 7, 2026\n\n\n\n\n\n\n\n\n\n\nGet Started\n\n\n\nProcess\n\n\n\nSimple example to get started\n\n\n\nKarel Dieussaert\n\n\nJan 7, 2026\n\n\n\n\n\n\n\n\n\n\nDictLoader\n\n\n\nLoader\n\n\n\nexample how a DictLoader is used to load a Dictionary of thematic data\n\n\n\nKarel Dieussaert\n\n\nJan 7, 2026\n\n\n\n\n\n\n\n\n\n\nEvaluation\n\n\n\nEvaluation\n\n\n\nExample of a simple Evaluation by using brdr\n\n\n\nKarel Dieussaert\n\n\nJan 7, 2026\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "reference/AlignerResultType.html",
    "href": "reference/AlignerResultType.html",
    "title": "AlignerResultType",
    "section": "",
    "text": "AlignerResultType\nenums.AlignerResultType()\nFormat of the output dictionary.",
    "crumbs": [
      "Reference",
      "Enumerators",
      "AlignerResultType"
    ]
  },
  {
    "objectID": "reference/show_map.html",
    "href": "reference/show_map.html",
    "title": "show_map",
    "section": "",
    "text": "viz.show_map(aligner_results, dict_thematic, dict_reference)\nDisplay a grid of maps showing alignment results across different distances.\nThis function creates a multi-panel figure where each subplot represents the geographic state of the thematic data after being aligned using a specific ‘relevant distance’ parameter.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\naligner_results\ndict\nA nested dictionary structured as {theme_id: {rel_dist: ProcessResult}}.\nrequired\n\n\ndict_thematic\ndict\nDictionary containing the original thematic geometries.\nrequired\n\n\ndict_reference\ndict\nDictionary containing the reference geometries used for alignment.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\nThe function generates and displays a Matplotlib figure.\n\n\n\n\n\n\nThe function automatically calculates the required number of rows for a two-column grid. It relies on the internal _make_map helper function to render the individual spatial layers.",
    "crumbs": [
      "Reference",
      "Visualization-functions (optional by pip install brdr[viz])",
      "show_map"
    ]
  },
  {
    "objectID": "reference/show_map.html#parameters",
    "href": "reference/show_map.html#parameters",
    "title": "show_map",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\naligner_results\ndict\nA nested dictionary structured as {theme_id: {rel_dist: ProcessResult}}.\nrequired\n\n\ndict_thematic\ndict\nDictionary containing the original thematic geometries.\nrequired\n\n\ndict_reference\ndict\nDictionary containing the reference geometries used for alignment.\nrequired",
    "crumbs": [
      "Reference",
      "Visualization-functions (optional by pip install brdr[viz])",
      "show_map"
    ]
  },
  {
    "objectID": "reference/show_map.html#returns",
    "href": "reference/show_map.html#returns",
    "title": "show_map",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nNone\nThe function generates and displays a Matplotlib figure.",
    "crumbs": [
      "Reference",
      "Visualization-functions (optional by pip install brdr[viz])",
      "show_map"
    ]
  },
  {
    "objectID": "reference/show_map.html#notes",
    "href": "reference/show_map.html#notes",
    "title": "show_map",
    "section": "",
    "text": "The function automatically calculates the required number of rows for a two-column grid. It relies on the internal _make_map helper function to render the individual spatial layers.",
    "crumbs": [
      "Reference",
      "Visualization-functions (optional by pip install brdr[viz])",
      "show_map"
    ]
  },
  {
    "objectID": "reference/ProcessResult.html",
    "href": "reference/ProcessResult.html",
    "title": "ProcessResult",
    "section": "",
    "text": "typings.ProcessResult()\nA dictionary structure representing the output of a geometric alignment process.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nresult\nBaseGeometry\nThe final aligned geometry.\n\n\nresult_diff\nBaseGeometry\nThe total geometric difference.\n\n\nresult_diff_plus\nBaseGeometry\nThe added geometric area.\n\n\nresult_diff_min\nBaseGeometry\nThe removed geometric area.\n\n\nproperties\nDict[str, Any]\nCalculated metrics and feature attributes.\n\n\nmetadata\nDict[Any, Any]\nDictionary containing execution metadata.\n\n\nobservation\nDict[Any, Any]\nDictionary containing the alignment observation details.\n\n\n\n\n\n\nThe following diagram shows the relationship between the components:\n\n\n\n\n\ngraph LR\n    A[Original] --&gt; D{Aligner}\n    B[Target] --&gt; D\n    D --&gt; R[result]\n    R --&gt; DP[result_diff_plus]\n    R --&gt; DM[result_diff_min]\n\n\n\n\n\n\n\n\n\n&gt;&gt;&gt; result: ProcessResult = {\n...     \"result\": Point(0, 0),\n...     \"properties\": {\"brdr_stability\": True}\n... }",
    "crumbs": [
      "Reference",
      "Typings",
      "ProcessResult"
    ]
  },
  {
    "objectID": "reference/ProcessResult.html#attributes",
    "href": "reference/ProcessResult.html#attributes",
    "title": "ProcessResult",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nresult\nBaseGeometry\nThe final aligned geometry.\n\n\nresult_diff\nBaseGeometry\nThe total geometric difference.\n\n\nresult_diff_plus\nBaseGeometry\nThe added geometric area.\n\n\nresult_diff_min\nBaseGeometry\nThe removed geometric area.\n\n\nproperties\nDict[str, Any]\nCalculated metrics and feature attributes.\n\n\nmetadata\nDict[Any, Any]\nDictionary containing execution metadata.\n\n\nobservation\nDict[Any, Any]\nDictionary containing the alignment observation details.",
    "crumbs": [
      "Reference",
      "Typings",
      "ProcessResult"
    ]
  },
  {
    "objectID": "reference/ProcessResult.html#notes",
    "href": "reference/ProcessResult.html#notes",
    "title": "ProcessResult",
    "section": "",
    "text": "The following diagram shows the relationship between the components:\n\n\n\n\n\ngraph LR\n    A[Original] --&gt; D{Aligner}\n    B[Target] --&gt; D\n    D --&gt; R[result]\n    R --&gt; DP[result_diff_plus]\n    R --&gt; DM[result_diff_min]",
    "crumbs": [
      "Reference",
      "Typings",
      "ProcessResult"
    ]
  },
  {
    "objectID": "reference/ProcessResult.html#examples",
    "href": "reference/ProcessResult.html#examples",
    "title": "ProcessResult",
    "section": "",
    "text": "&gt;&gt;&gt; result: ProcessResult = {\n...     \"result\": Point(0, 0),\n...     \"properties\": {\"brdr_stability\": True}\n... }",
    "crumbs": [
      "Reference",
      "Typings",
      "ProcessResult"
    ]
  },
  {
    "objectID": "reference/DiffMetric.html",
    "href": "reference/DiffMetric.html",
    "title": "DiffMetric",
    "section": "",
    "text": "enums.DiffMetric()\nMetrics to quantify the change between thematic and reference data.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nAREA_CHANGE\nstr\nAbsolute change in area (m²).\n\n\nAREA_PERCENTAGE_CHANGE\nstr\nRelative change in area (%).\n\n\nSYMMETRICAL_AREA_CHANGE\nstr\nThe area of the symmetric difference (XOR).\n\n\nSYMMETRICAL_AREA_PERCENTAGE_CHANGE\nstr\nSymmetric difference as a percentage of original area.\n\n\nLENGTH_CHANGE\nstr\nChange in perimeter/length.\n\n\nLENGTH_PERCENTAGE_CHANGE\nstr\nRelative change in perimeter.\n\n\nLENGTH_REMOVED\nstr\nThe length of segments removed during processing.\n\n\nTOTAL_DISTANCE\nstr\nSum of displacement of all vertices.\n\n\nREFERENCE_USAGE\nstr\nThe extent of reference boundaries utilized (m or m²).",
    "crumbs": [
      "Reference",
      "Enumerators",
      "DiffMetric"
    ]
  },
  {
    "objectID": "reference/DiffMetric.html#attributes",
    "href": "reference/DiffMetric.html#attributes",
    "title": "DiffMetric",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nAREA_CHANGE\nstr\nAbsolute change in area (m²).\n\n\nAREA_PERCENTAGE_CHANGE\nstr\nRelative change in area (%).\n\n\nSYMMETRICAL_AREA_CHANGE\nstr\nThe area of the symmetric difference (XOR).\n\n\nSYMMETRICAL_AREA_PERCENTAGE_CHANGE\nstr\nSymmetric difference as a percentage of original area.\n\n\nLENGTH_CHANGE\nstr\nChange in perimeter/length.\n\n\nLENGTH_PERCENTAGE_CHANGE\nstr\nRelative change in perimeter.\n\n\nLENGTH_REMOVED\nstr\nThe length of segments removed during processing.\n\n\nTOTAL_DISTANCE\nstr\nSum of displacement of all vertices.\n\n\nREFERENCE_USAGE\nstr\nThe extent of reference boundaries utilized (m or m²).",
    "crumbs": [
      "Reference",
      "Enumerators",
      "DiffMetric"
    ]
  },
  {
    "objectID": "reference/loader.GRBActualLoader.html",
    "href": "reference/loader.GRBActualLoader.html",
    "title": "loader.GRBActualLoader",
    "section": "",
    "text": "be.grb.loader.GRBActualLoader(grb_type, aligner, partition=1000)\nLoader for the most recent version of GRB (Grootschalig Referentie Bestand).\nThis loader fetches live thematic reference data (such as buildings, parcels, or road edges) based on the spatial extent of the thematic data currently held by the aligner.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ngrb_type\nGRBType\nThe specific type of GRB data to load (e.g., ADP, Gebouw).\nrequired\n\n\naligner\nAny\nThe aligner object providing the spatial context, logger, and CRS.\nrequired\n\n\npartition\nint\nNumber of features per request to handle large datasets, by default 1000.\n1000\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\naligner\nAny\nReference to the parent aligner.\n\n\ngrb_type\nGRBType\nThe requested GRB layer type.\n\n\npart\nint\nThe partitioning size for downloads.\n\n\nversiondate_info\ndict\nInformation about the versioning metadata format.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nload_data\nDownload and process the actual GRB data from the web service.\n\n\n\n\n\nbe.grb.loader.GRBActualLoader.load_data()\nDownload and process the actual GRB data from the web service.\nCalculates a search buffer around the union of thematic geometries to ensure all relevant reference features are captured.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nAny\nThe processed FeatureCollection from the parent GeoJsonLoader.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf thematic data has not been loaded into the aligner prior to calling this method.",
    "crumbs": [
      "Reference",
      "GRB (Flanders-specific)",
      "loader.GRBActualLoader"
    ]
  },
  {
    "objectID": "reference/loader.GRBActualLoader.html#parameters",
    "href": "reference/loader.GRBActualLoader.html#parameters",
    "title": "loader.GRBActualLoader",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ngrb_type\nGRBType\nThe specific type of GRB data to load (e.g., ADP, Gebouw).\nrequired\n\n\naligner\nAny\nThe aligner object providing the spatial context, logger, and CRS.\nrequired\n\n\npartition\nint\nNumber of features per request to handle large datasets, by default 1000.\n1000",
    "crumbs": [
      "Reference",
      "GRB (Flanders-specific)",
      "loader.GRBActualLoader"
    ]
  },
  {
    "objectID": "reference/loader.GRBActualLoader.html#attributes",
    "href": "reference/loader.GRBActualLoader.html#attributes",
    "title": "loader.GRBActualLoader",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\naligner\nAny\nReference to the parent aligner.\n\n\ngrb_type\nGRBType\nThe requested GRB layer type.\n\n\npart\nint\nThe partitioning size for downloads.\n\n\nversiondate_info\ndict\nInformation about the versioning metadata format.",
    "crumbs": [
      "Reference",
      "GRB (Flanders-specific)",
      "loader.GRBActualLoader"
    ]
  },
  {
    "objectID": "reference/loader.GRBActualLoader.html#methods",
    "href": "reference/loader.GRBActualLoader.html#methods",
    "title": "loader.GRBActualLoader",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nload_data\nDownload and process the actual GRB data from the web service.\n\n\n\n\n\nbe.grb.loader.GRBActualLoader.load_data()\nDownload and process the actual GRB data from the web service.\nCalculates a search buffer around the union of thematic geometries to ensure all relevant reference features are captured.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nAny\nThe processed FeatureCollection from the parent GeoJsonLoader.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf thematic data has not been loaded into the aligner prior to calling this method.",
    "crumbs": [
      "Reference",
      "GRB (Flanders-specific)",
      "loader.GRBActualLoader"
    ]
  },
  {
    "objectID": "reference/utils.is_grb_changed.html",
    "href": "reference/utils.is_grb_changed.html",
    "title": "utils.is_grb_changed",
    "section": "",
    "text": "utils.is_grb_changed\nbe.grb.utils.is_grb_changed(\n    geometry,\n    grb_type=GRBType.ADP,\n    date_start=date.today(),\n    date_end=date.today(),\n    border_distance=0,\n    crs=DEFAULT_CRS,\n)\nchecks if a geometry is possibly affected by changes in the reference layer during a specified timespan Args: geometry: Geometry to check on GRB-changes grb_type: Type of GRB (parcels, buildings,artwork,…) to check date_start: Start of timespan to check if GRB-changes has occurred date_end: End of timespan to check if GRB-changes has occurred border_distance: Distance that can be used to only check the ‘border’ of the geometry, so ‘big’ geometries with internal parcel-updates are not affected (Default:0, indicating that the full geometry is checked fot GRB-changes) crs: Coordinate reference system to use\nReturns: Boolean, indicating if GRB is changed underneath the geometry",
    "crumbs": [
      "Reference",
      "GRB (Flanders-specific)",
      "utils.is_grb_changed"
    ]
  },
  {
    "objectID": "reference/enums.GRBType.html",
    "href": "reference/enums.GRBType.html",
    "title": "enums.GRBType",
    "section": "",
    "text": "enums.GRBType\nbe.grb.enums.GRBType",
    "crumbs": [
      "Reference",
      "GRB (Flanders-specific)",
      "enums.GRBType"
    ]
  },
  {
    "objectID": "reference/OGCFeatureAPIReferenceLoader.html",
    "href": "reference/OGCFeatureAPIReferenceLoader.html",
    "title": "OGCFeatureAPIReferenceLoader",
    "section": "",
    "text": "loader.OGCFeatureAPIReferenceLoader(\n    url,\n    id_property,\n    collection,\n    aligner,\n    partition=1000,\n    limit=DOWNLOAD_LIMIT,\n    is_reference=True,\n)\nLoader for OGC API - Features services.\nFetches data using spatial filters (BBOX) and handles partitioning of large datasets based on the thematic extent.\n\n\n\n\n\nName\nDescription\n\n\n\n\nload_data\nValidates the OGC service and downloads data within the thematic extent.\n\n\n\n\n\nloader.OGCFeatureAPIReferenceLoader.load_data()\nValidates the OGC service and downloads data within the thematic extent.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nAlignerFeatureCollection\nThe downloaded and processed reference data.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf thematic data is missing, the collection is not found, or the service does not support the Aligner’s CRS.\n\n\n\n\n\n\ngraph LR\nThematic[Thematic Data Extent] --&gt; Buffer[Apply MAX_REFERENCE_BUFFER]\nBuffer --&gt; Partition[Split into BBOX Partitions]\nPartition --&gt; Request[HTTP GetFeature/Items]\nRequest --&gt; Merge[Merge Results into Collection]\n\nsubgraph Service[External OGC/WFS Service]\nRequest\nend",
    "crumbs": [
      "Reference",
      "Loaders",
      "OGCFeatureAPIReferenceLoader"
    ]
  },
  {
    "objectID": "reference/OGCFeatureAPIReferenceLoader.html#methods",
    "href": "reference/OGCFeatureAPIReferenceLoader.html#methods",
    "title": "OGCFeatureAPIReferenceLoader",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nload_data\nValidates the OGC service and downloads data within the thematic extent.\n\n\n\n\n\nloader.OGCFeatureAPIReferenceLoader.load_data()\nValidates the OGC service and downloads data within the thematic extent.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nAlignerFeatureCollection\nThe downloaded and processed reference data.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf thematic data is missing, the collection is not found, or the service does not support the Aligner’s CRS.\n\n\n\n\n\n\ngraph LR\nThematic[Thematic Data Extent] --&gt; Buffer[Apply MAX_REFERENCE_BUFFER]\nBuffer --&gt; Partition[Split into BBOX Partitions]\nPartition --&gt; Request[HTTP GetFeature/Items]\nRequest --&gt; Merge[Merge Results into Collection]\n\nsubgraph Service[External OGC/WFS Service]\nRequest\nend",
    "crumbs": [
      "Reference",
      "Loaders",
      "OGCFeatureAPIReferenceLoader"
    ]
  },
  {
    "objectID": "reference/print_observation_of_aligner_results.html",
    "href": "reference/print_observation_of_aligner_results.html",
    "title": "print_observation_of_aligner_results",
    "section": "",
    "text": "viz.print_observation_of_aligner_results(aligner_results, aligner)\nPrint a detailed comparison analysis for alignment results.\nIterates through a nested results dictionary and uses the Aligner’s comparison logic to output a human-readable summary of how the processed geometry relates to the reference data for different parameter settings.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\naligner_results\ndict of dict\nA nested dictionary where the first key is the theme_id and the second key is the relevant_distance (rel_dist). The values are ProcessResult dictionaries.\nrequired\n\n\naligner\nAligner\nAn instance of the Aligner class (or a subclass) that provides the compare_to_reference method for geometric analysis.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\nThe function prints the analysis directly to the standard output.\n\n\n\n\n\n\nThis function is primarily used for debugging and quality control to verify if the “Observation” (alignment logic) is producing the expected geometric relationship with the reference data.",
    "crumbs": [
      "Reference",
      "Visualization-functions (optional by pip install brdr[viz])",
      "print_observation_of_aligner_results"
    ]
  },
  {
    "objectID": "reference/print_observation_of_aligner_results.html#parameters",
    "href": "reference/print_observation_of_aligner_results.html#parameters",
    "title": "print_observation_of_aligner_results",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\naligner_results\ndict of dict\nA nested dictionary where the first key is the theme_id and the second key is the relevant_distance (rel_dist). The values are ProcessResult dictionaries.\nrequired\n\n\naligner\nAligner\nAn instance of the Aligner class (or a subclass) that provides the compare_to_reference method for geometric analysis.\nrequired",
    "crumbs": [
      "Reference",
      "Visualization-functions (optional by pip install brdr[viz])",
      "print_observation_of_aligner_results"
    ]
  },
  {
    "objectID": "reference/print_observation_of_aligner_results.html#returns",
    "href": "reference/print_observation_of_aligner_results.html#returns",
    "title": "print_observation_of_aligner_results",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nNone\nThe function prints the analysis directly to the standard output.",
    "crumbs": [
      "Reference",
      "Visualization-functions (optional by pip install brdr[viz])",
      "print_observation_of_aligner_results"
    ]
  },
  {
    "objectID": "reference/print_observation_of_aligner_results.html#notes",
    "href": "reference/print_observation_of_aligner_results.html#notes",
    "title": "print_observation_of_aligner_results",
    "section": "",
    "text": "This function is primarily used for debugging and quality control to verify if the “Observation” (alignment logic) is producing the expected geometric relationship with the reference data.",
    "crumbs": [
      "Reference",
      "Visualization-functions (optional by pip install brdr[viz])",
      "print_observation_of_aligner_results"
    ]
  },
  {
    "objectID": "reference/AlignerResult.html",
    "href": "reference/AlignerResult.html",
    "title": "AlignerResult",
    "section": "",
    "text": "aligner.AlignerResult(process_results)\nStores and processes the results from the alignment operation.\nThis class manages the lifecycle of alignment results, including enrichment with geometric metrics (like area or length change), filtering by result type, and exporting to GeoJSON format.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nresults\nDict[ThematicId, Dict[float, Optional[ProcessResult]]]\nA nested dictionary where the outer key is the theme ID and the inner key is the relevant distance used during processing.\n\n\nmetadata\nOptional[Any]\nOptional metadata about the overall alignment operation.\n\n\n\n\n\n\nThe class acts as a post-processor. It takes the raw output from the geometric engines and calculates semantic differences before exporting.\n\n\n\n\n\ngraph TD\n    Raw[Raw Process Results] --&gt; AR[AlignerResult]\n    AR --&gt; |get_results| Enriched[Enriched with Area/Length Metrics]\n    Enriched --&gt; |get_results_as_geojson| GeoJSON[GeoJSON FeatureCollection]\n    GeoJSON --&gt; |save_results| Disk[Local .geojson files]\n\n\n\n\n\n\n\n\n\n&gt;&gt;&gt; # Initializing and saving results\n&gt;&gt;&gt; result_obj = AlignerResult(raw_results)\n&gt;&gt;&gt; result_obj.save_results(aligner, path=\"./output_folder\")\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_results\nRetrieves results enriched with geometric metrics and filtered by type.\n\n\nget_results_as_geojson\nConverts the results into a GeoJSON FeatureCollection format.\n\n\nsave_results\nExports the results as multiple GeoJSON files to a directory.\n\n\n\n\n\naligner.AlignerResult.get_results(\n    aligner,\n    result_type=AlignerResultType.PROCESSRESULTS,\n)\nRetrieves results enriched with geometric metrics and filtered by type.\nThis method mutates the stored ProcessResult objects by adding calculated difference metrics (e.g., symmetrical area change) to their properties.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\naligner\nAligner\nThe ‘Aligner’ object used to access thematic data and comparison logic.\nrequired\n\n\nresult_type\nAlignerResultType\nFilters the results based on status. Defaults to PROCESSRESULTS.\nAlignerResultType.PROCESSRESULTS\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[ThematicId, Dict[float, Optional[ProcessResult]]]\nA dictionary of filtered and enriched results.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf an unsupported result_type is provided.\n\n\n\n\n\n\n\naligner.AlignerResult.get_results_as_geojson(\n    aligner,\n    result_type=AlignerResultType.PROCESSRESULTS,\n    add_metadata=False,\n    add_original_attributes=False,\n)\nConverts the results into a GeoJSON FeatureCollection format.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\naligner\nAligner\nThe ‘Aligner’ object providing CRS and thematic metadata.\nrequired\n\n\nresult_type\nAlignerResultType\nThe type of results to export. Defaults to PROCESSRESULTS.\nAlignerResultType.PROCESSRESULTS\n\n\nadd_metadata\nbool\nIf True, includes the descriptive comparison observation in properties.\nFalse\n\n\nadd_original_attributes\nbool\nIf True, includes original thematic attributes in the output.\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[str, Any]\nA dictionary representing a GeoJSON FeatureCollection.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf self.results is empty or None.\n\n\n\n\n\n\n\naligner.AlignerResult.save_results(\n    aligner,\n    path,\n    result_type=AlignerResultType.PROCESSRESULTS,\n    add_metadata=False,\n    add_original_attributes=False,\n)\nExports the results as multiple GeoJSON files to a directory.\nCreates separate files for original results, differences, and specific area changes (added/removed).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\naligner\nAligner\nThe ‘Aligner’ object for spatial context.\nrequired\n\n\npath\nstr\nTarget directory path where files will be created.\nrequired\n\n\nresult_type\nAlignerResultType\nType of results to export. Defaults to PROCESSRESULTS.\nAlignerResultType.PROCESSRESULTS\n\n\nadd_metadata\nbool\nWhether to include alignment observations in the output.\nFalse\n\n\nadd_original_attributes\nbool\nWhether to include original feature attributes.\nFalse\n\n\n\n\n\n\nThe output files follow the naming convention: {result_type}_{name}.geojson.",
    "crumbs": [
      "Reference",
      "Aligner",
      "AlignerResult"
    ]
  },
  {
    "objectID": "reference/AlignerResult.html#attributes",
    "href": "reference/AlignerResult.html#attributes",
    "title": "AlignerResult",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nresults\nDict[ThematicId, Dict[float, Optional[ProcessResult]]]\nA nested dictionary where the outer key is the theme ID and the inner key is the relevant distance used during processing.\n\n\nmetadata\nOptional[Any]\nOptional metadata about the overall alignment operation.",
    "crumbs": [
      "Reference",
      "Aligner",
      "AlignerResult"
    ]
  },
  {
    "objectID": "reference/AlignerResult.html#notes",
    "href": "reference/AlignerResult.html#notes",
    "title": "AlignerResult",
    "section": "",
    "text": "The class acts as a post-processor. It takes the raw output from the geometric engines and calculates semantic differences before exporting.\n\n\n\n\n\ngraph TD\n    Raw[Raw Process Results] --&gt; AR[AlignerResult]\n    AR --&gt; |get_results| Enriched[Enriched with Area/Length Metrics]\n    Enriched --&gt; |get_results_as_geojson| GeoJSON[GeoJSON FeatureCollection]\n    GeoJSON --&gt; |save_results| Disk[Local .geojson files]",
    "crumbs": [
      "Reference",
      "Aligner",
      "AlignerResult"
    ]
  },
  {
    "objectID": "reference/AlignerResult.html#examples",
    "href": "reference/AlignerResult.html#examples",
    "title": "AlignerResult",
    "section": "",
    "text": "&gt;&gt;&gt; # Initializing and saving results\n&gt;&gt;&gt; result_obj = AlignerResult(raw_results)\n&gt;&gt;&gt; result_obj.save_results(aligner, path=\"./output_folder\")",
    "crumbs": [
      "Reference",
      "Aligner",
      "AlignerResult"
    ]
  },
  {
    "objectID": "reference/AlignerResult.html#methods",
    "href": "reference/AlignerResult.html#methods",
    "title": "AlignerResult",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_results\nRetrieves results enriched with geometric metrics and filtered by type.\n\n\nget_results_as_geojson\nConverts the results into a GeoJSON FeatureCollection format.\n\n\nsave_results\nExports the results as multiple GeoJSON files to a directory.\n\n\n\n\n\naligner.AlignerResult.get_results(\n    aligner,\n    result_type=AlignerResultType.PROCESSRESULTS,\n)\nRetrieves results enriched with geometric metrics and filtered by type.\nThis method mutates the stored ProcessResult objects by adding calculated difference metrics (e.g., symmetrical area change) to their properties.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\naligner\nAligner\nThe ‘Aligner’ object used to access thematic data and comparison logic.\nrequired\n\n\nresult_type\nAlignerResultType\nFilters the results based on status. Defaults to PROCESSRESULTS.\nAlignerResultType.PROCESSRESULTS\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[ThematicId, Dict[float, Optional[ProcessResult]]]\nA dictionary of filtered and enriched results.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf an unsupported result_type is provided.\n\n\n\n\n\n\n\naligner.AlignerResult.get_results_as_geojson(\n    aligner,\n    result_type=AlignerResultType.PROCESSRESULTS,\n    add_metadata=False,\n    add_original_attributes=False,\n)\nConverts the results into a GeoJSON FeatureCollection format.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\naligner\nAligner\nThe ‘Aligner’ object providing CRS and thematic metadata.\nrequired\n\n\nresult_type\nAlignerResultType\nThe type of results to export. Defaults to PROCESSRESULTS.\nAlignerResultType.PROCESSRESULTS\n\n\nadd_metadata\nbool\nIf True, includes the descriptive comparison observation in properties.\nFalse\n\n\nadd_original_attributes\nbool\nIf True, includes original thematic attributes in the output.\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[str, Any]\nA dictionary representing a GeoJSON FeatureCollection.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf self.results is empty or None.\n\n\n\n\n\n\n\naligner.AlignerResult.save_results(\n    aligner,\n    path,\n    result_type=AlignerResultType.PROCESSRESULTS,\n    add_metadata=False,\n    add_original_attributes=False,\n)\nExports the results as multiple GeoJSON files to a directory.\nCreates separate files for original results, differences, and specific area changes (added/removed).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\naligner\nAligner\nThe ‘Aligner’ object for spatial context.\nrequired\n\n\npath\nstr\nTarget directory path where files will be created.\nrequired\n\n\nresult_type\nAlignerResultType\nType of results to export. Defaults to PROCESSRESULTS.\nAlignerResultType.PROCESSRESULTS\n\n\nadd_metadata\nbool\nWhether to include alignment observations in the output.\nFalse\n\n\nadd_original_attributes\nbool\nWhether to include original feature attributes.\nFalse\n\n\n\n\n\n\nThe output files follow the naming convention: {result_type}_{name}.geojson.",
    "crumbs": [
      "Reference",
      "Aligner",
      "AlignerResult"
    ]
  },
  {
    "objectID": "reference/loader.GRBFiscalParcelLoader.html",
    "href": "reference/loader.GRBFiscalParcelLoader.html",
    "title": "loader.GRBFiscalParcelLoader",
    "section": "",
    "text": "be.grb.loader.GRBFiscalParcelLoader(year, aligner, partition=1000)\nLoader for fiscal parcel data (Adpf) for a specific year.\nThis loader retrieves the cadastral situation as it was registered for fiscal purposes at the start of a specific year.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nyear\nstr\nThe fiscal year to retrieve parcels for (e.g., “2023”).\nrequired\n\n\naligner\nAny\nThe aligner object providing spatial context and CRS.\nrequired\n\n\npartition\nint\nNumber of features per request, by default 1000.\n1000\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nload_data\nDownload and process fiscal parcel data for the specified year.\n\n\n\n\n\nbe.grb.loader.GRBFiscalParcelLoader.load_data()\nDownload and process fiscal parcel data for the specified year.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nAny\nThe result of the parent GeoJsonLoader’s load_data method.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf thematic data is missing from the aligner.",
    "crumbs": [
      "Reference",
      "GRB (Flanders-specific)",
      "loader.GRBFiscalParcelLoader"
    ]
  },
  {
    "objectID": "reference/loader.GRBFiscalParcelLoader.html#parameters",
    "href": "reference/loader.GRBFiscalParcelLoader.html#parameters",
    "title": "loader.GRBFiscalParcelLoader",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nyear\nstr\nThe fiscal year to retrieve parcels for (e.g., “2023”).\nrequired\n\n\naligner\nAny\nThe aligner object providing spatial context and CRS.\nrequired\n\n\npartition\nint\nNumber of features per request, by default 1000.\n1000",
    "crumbs": [
      "Reference",
      "GRB (Flanders-specific)",
      "loader.GRBFiscalParcelLoader"
    ]
  },
  {
    "objectID": "reference/loader.GRBFiscalParcelLoader.html#methods",
    "href": "reference/loader.GRBFiscalParcelLoader.html#methods",
    "title": "loader.GRBFiscalParcelLoader",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nload_data\nDownload and process fiscal parcel data for the specified year.\n\n\n\n\n\nbe.grb.loader.GRBFiscalParcelLoader.load_data()\nDownload and process fiscal parcel data for the specified year.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nAny\nThe result of the parent GeoJsonLoader’s load_data method.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf thematic data is missing from the aligner.",
    "crumbs": [
      "Reference",
      "GRB (Flanders-specific)",
      "loader.GRBFiscalParcelLoader"
    ]
  },
  {
    "objectID": "reference/TopologyProcessor.html",
    "href": "reference/TopologyProcessor.html",
    "title": "TopologyProcessor",
    "section": "",
    "text": "processor.TopologyProcessor(config, feedback=None)\nProcessor that aligns geometries while preserving topological relationships.\nInstead of processing features independently, the TopologyProcessor decomposes thematic data into unique ‘arcs’ (shared boundaries). Each arc is aligned once using network-based processing, ensuring that shared boundaries remain perfectly snapped together in the final output.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nprocessor_id\nProcessorID\nThe unique identifier for this processor (ProcessorID.TOPOLOGY).\n\n\nthematic_data\n(AlignerFeatureCollection, optional)\nCached reference to the full thematic dataset used for topology building.\n\n\ntopo_thematic\n(dict, optional)\nThe generated TopoJSON-like structure of the thematic data.\n\n\nthematic_geometries_to_process\n(dict, optional)\nMapping of arc IDs to their respective LineString geometries.\n\n\nid_to_arcs\n(dict, optional)\nMapping of feature IDs to the list of arc IDs that form their boundary.\n\n\nwkb_to_id\n(dict, optional)\nReverse index mapping geometry WKB strings to feature IDs.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nprocess\nAligns a geometry by processing its topological arcs.\n\n\n\n\n\nprocessor.TopologyProcessor.process(\n    input_geometry,\n    reference_data,\n    mitre_limit,\n    correction_distance,\n    relevant_distance,\n    thematic_data,\n    **kwargs,\n)\nAligns a geometry by processing its topological arcs.\nThis method identifies which unique arcs belong to the input geometry, aligns those arcs using the NetworkGeometryProcessor, and then reconstructs the final geometry.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput_geometry\nBaseGeometry\nThe specific thematic geometry to align.\nrequired\n\n\nreference_data\nAlignerFeatureCollection\nThe reference dataset used for alignment.\nrequired\n\n\nmitre_limit\nfloat\nMitre limit for buffering operations.\nrequired\n\n\ncorrection_distance\nfloat\nDistance used for cleaning and noise reduction.\nrequired\n\n\nrelevant_distance\nfloat\nThe maximum distance for alignment.\nrequired\n\n\nthematic_data\nAlignerFeatureCollection\nThe full thematic collection required to build/query the topology.\nrequired\n\n\n**kwargs\nAny\nAdditional arguments.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nProcessResult\nThe reconstructed geometry where shared boundaries are consistently aligned.\n\n\n\n\n\n\nThe topological workflow ensures “gapless” alignment:\n\n\n\n\n\ngraph TD\n    In[Input Geometry] --&gt; Cache{Cache Built?}\n    Cache -- No --&gt; Build[Build Topology: Extract Arcs]\n    Build --&gt; Cache\n    Cache -- Yes --&gt; Map[Map Geometry to Arc IDs]\n    Map --&gt; Loop[For each unique Arc]\n    Loop --&gt; Net[Align Arc via NetworkProcessor]\n    Net --&gt; Loop\n    Loop --&gt; Dissolve[Reconstruct Polygon from Aligned Arcs]\n    Dissolve --&gt; End[Final ProcessResult]",
    "crumbs": [
      "Reference",
      "Processors",
      "TopologyProcessor"
    ]
  },
  {
    "objectID": "reference/TopologyProcessor.html#attributes",
    "href": "reference/TopologyProcessor.html#attributes",
    "title": "TopologyProcessor",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nprocessor_id\nProcessorID\nThe unique identifier for this processor (ProcessorID.TOPOLOGY).\n\n\nthematic_data\n(AlignerFeatureCollection, optional)\nCached reference to the full thematic dataset used for topology building.\n\n\ntopo_thematic\n(dict, optional)\nThe generated TopoJSON-like structure of the thematic data.\n\n\nthematic_geometries_to_process\n(dict, optional)\nMapping of arc IDs to their respective LineString geometries.\n\n\nid_to_arcs\n(dict, optional)\nMapping of feature IDs to the list of arc IDs that form their boundary.\n\n\nwkb_to_id\n(dict, optional)\nReverse index mapping geometry WKB strings to feature IDs.",
    "crumbs": [
      "Reference",
      "Processors",
      "TopologyProcessor"
    ]
  },
  {
    "objectID": "reference/TopologyProcessor.html#methods",
    "href": "reference/TopologyProcessor.html#methods",
    "title": "TopologyProcessor",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nprocess\nAligns a geometry by processing its topological arcs.\n\n\n\n\n\nprocessor.TopologyProcessor.process(\n    input_geometry,\n    reference_data,\n    mitre_limit,\n    correction_distance,\n    relevant_distance,\n    thematic_data,\n    **kwargs,\n)\nAligns a geometry by processing its topological arcs.\nThis method identifies which unique arcs belong to the input geometry, aligns those arcs using the NetworkGeometryProcessor, and then reconstructs the final geometry.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput_geometry\nBaseGeometry\nThe specific thematic geometry to align.\nrequired\n\n\nreference_data\nAlignerFeatureCollection\nThe reference dataset used for alignment.\nrequired\n\n\nmitre_limit\nfloat\nMitre limit for buffering operations.\nrequired\n\n\ncorrection_distance\nfloat\nDistance used for cleaning and noise reduction.\nrequired\n\n\nrelevant_distance\nfloat\nThe maximum distance for alignment.\nrequired\n\n\nthematic_data\nAlignerFeatureCollection\nThe full thematic collection required to build/query the topology.\nrequired\n\n\n**kwargs\nAny\nAdditional arguments.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nProcessResult\nThe reconstructed geometry where shared boundaries are consistently aligned.\n\n\n\n\n\n\nThe topological workflow ensures “gapless” alignment:\n\n\n\n\n\ngraph TD\n    In[Input Geometry] --&gt; Cache{Cache Built?}\n    Cache -- No --&gt; Build[Build Topology: Extract Arcs]\n    Build --&gt; Cache\n    Cache -- Yes --&gt; Map[Map Geometry to Arc IDs]\n    Map --&gt; Loop[For each unique Arc]\n    Loop --&gt; Net[Align Arc via NetworkProcessor]\n    Net --&gt; Loop\n    Loop --&gt; Dissolve[Reconstruct Polygon from Aligned Arcs]\n    Dissolve --&gt; End[Final ProcessResult]",
    "crumbs": [
      "Reference",
      "Processors",
      "TopologyProcessor"
    ]
  },
  {
    "objectID": "reference/animated_map.html",
    "href": "reference/animated_map.html",
    "title": "animated_map",
    "section": "",
    "text": "viz.animated_map(\n    aligner_results,\n    dict_thematic,\n    dict_reference,\n    xlim,\n    ylim,\n    interval,\n    filename,\n)\nCreate a synchronized animation of map changes and area statistics.\nThis function generates a side-by-side animation: the left panel shows the geometric alignment on a map (zoomed to thematic data), while the right panel plots the percentage of area change as a function of the ‘relevant distance’ parameter.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\naligner_results\ndict\nA nested dictionary structured as {theme_id: {rel_dist: ProcessResult}}.\nrequired\n\n\ndict_thematic\ndict\nDictionary containing the original thematic geometries.\nrequired\n\n\ndict_reference\ndict\nDictionary containing the reference geometries used for alignment.\nrequired\n\n\nxlim\nfloat\nThe maximum value for the X-axis (relevant distance) in the trend plot.\nrequired\n\n\nylim\nfloat\nThe maximum value for the Y-axis (% area change) in the trend plot.\nrequired\n\n\ninterval\nint\nDelay between frames in milliseconds.\nrequired\n\n\nfilename\nstr\nThe output path/name for the saved animation (e.g., ‘analysis.gif’).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\nThe function saves the animation to the specified filename and displays the plot.\n\n\n\n\n\n\nTo prevent “stray lines” in the trend plot during animation loops, the data tracking lists are cleared whenever the animation restarts at the first distance frame.",
    "crumbs": [
      "Reference",
      "Visualization-functions (optional by pip install brdr[viz])",
      "animated_map"
    ]
  },
  {
    "objectID": "reference/animated_map.html#parameters",
    "href": "reference/animated_map.html#parameters",
    "title": "animated_map",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\naligner_results\ndict\nA nested dictionary structured as {theme_id: {rel_dist: ProcessResult}}.\nrequired\n\n\ndict_thematic\ndict\nDictionary containing the original thematic geometries.\nrequired\n\n\ndict_reference\ndict\nDictionary containing the reference geometries used for alignment.\nrequired\n\n\nxlim\nfloat\nThe maximum value for the X-axis (relevant distance) in the trend plot.\nrequired\n\n\nylim\nfloat\nThe maximum value for the Y-axis (% area change) in the trend plot.\nrequired\n\n\ninterval\nint\nDelay between frames in milliseconds.\nrequired\n\n\nfilename\nstr\nThe output path/name for the saved animation (e.g., ‘analysis.gif’).\nrequired",
    "crumbs": [
      "Reference",
      "Visualization-functions (optional by pip install brdr[viz])",
      "animated_map"
    ]
  },
  {
    "objectID": "reference/animated_map.html#returns",
    "href": "reference/animated_map.html#returns",
    "title": "animated_map",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nNone\nThe function saves the animation to the specified filename and displays the plot.",
    "crumbs": [
      "Reference",
      "Visualization-functions (optional by pip install brdr[viz])",
      "animated_map"
    ]
  },
  {
    "objectID": "reference/animated_map.html#notes",
    "href": "reference/animated_map.html#notes",
    "title": "animated_map",
    "section": "",
    "text": "To prevent “stray lines” in the trend plot during animation loops, the data tracking lists are cleared whenever the animation restarts at the first distance frame.",
    "crumbs": [
      "Reference",
      "Visualization-functions (optional by pip install brdr[viz])",
      "animated_map"
    ]
  },
  {
    "objectID": "reference/AlignerGeometryProcessor.html",
    "href": "reference/AlignerGeometryProcessor.html",
    "title": "AlignerGeometryProcessor",
    "section": "",
    "text": "processor.AlignerGeometryProcessor(config, feedback=None)\nProcessor responsible for aligning thematic geometries to reference data.\nThis class identifies the geometry type and delegates the alignment logic to specialized processors (Dieussaert or Network-based) while handling validation and edge cases like area limits and zero-distance processing.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nprocessor_id\nProcessorID\nUnique identifier for the aligner processor.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nprocess\nProcess and align a single geometry based on reference data.\n\n\n\n\n\nprocessor.AlignerGeometryProcessor.process(\n    correction_distance,\n    reference_data,\n    input_geometry,\n    mitre_limit,\n    relevant_distance=1.0,\n    **kwargs,\n)\nProcess and align a single geometry based on reference data.\nThe method validates the input geometry, checks against area constraints, and selects the appropriate sub-processor (Dieussaert for polygons or Network for linear/complex structures).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncorrection_distance\nfloat\nThe maximum distance a vertex can be moved during alignment.\nrequired\n\n\nreference_data\nGeoDataFrame or list[BaseGeometry]\nThe target geometries to which the input_geometry should align.\nrequired\n\n\ninput_geometry\nBaseGeometry\nThe geometry to be processed. Supports Polygon, MultiPolygon, and linear geometries.\nrequired\n\n\nmitre_limit\nfloat\nThe limit used for miter joins to prevent sharp spikes in corners.\nrequired\n\n\nrelevant_distance\nfloat\nThe search radius used to find nearby reference geometries. If set to 0, no processing is performed.\n1.0\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to sub-processors.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nProcessResult\nAn object containing the aligned geometry and processing metadata (e.g., remarks or error logs).\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf the input_geometry is a GeometryCollection. If the input_geometry exceeds the configured area_limit.\n\n\n\n\n\n\nThe logic follows this decision flow:\n\n\n\n\n\ngraph TD\n      A[Start Process] --&gt; B{GeometryCollection?}\n      B -- Yes --&gt; C[Raise ValueError]\n      B -- No --&gt; D{Polygon/MultiPolygon?}\n      D -- No --&gt; E[Network Processor]\n      D -- Yes --&gt; F{Area &gt; Limit?}\n      F -- Yes --&gt; G[Raise ValueError]\n      F -- No --&gt; H{RD == 0?}\n      H -- Yes --&gt; I[Return Original]\n      H -- No --&gt; J[Dieussaert Processor]\n      J -- Success --&gt; K[Return Result]\n      J -- Fail --&gt; E\n      E --&gt; K",
    "crumbs": [
      "Reference",
      "Processors",
      "AlignerGeometryProcessor"
    ]
  },
  {
    "objectID": "reference/AlignerGeometryProcessor.html#attributes",
    "href": "reference/AlignerGeometryProcessor.html#attributes",
    "title": "AlignerGeometryProcessor",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nprocessor_id\nProcessorID\nUnique identifier for the aligner processor.",
    "crumbs": [
      "Reference",
      "Processors",
      "AlignerGeometryProcessor"
    ]
  },
  {
    "objectID": "reference/AlignerGeometryProcessor.html#methods",
    "href": "reference/AlignerGeometryProcessor.html#methods",
    "title": "AlignerGeometryProcessor",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nprocess\nProcess and align a single geometry based on reference data.\n\n\n\n\n\nprocessor.AlignerGeometryProcessor.process(\n    correction_distance,\n    reference_data,\n    input_geometry,\n    mitre_limit,\n    relevant_distance=1.0,\n    **kwargs,\n)\nProcess and align a single geometry based on reference data.\nThe method validates the input geometry, checks against area constraints, and selects the appropriate sub-processor (Dieussaert for polygons or Network for linear/complex structures).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncorrection_distance\nfloat\nThe maximum distance a vertex can be moved during alignment.\nrequired\n\n\nreference_data\nGeoDataFrame or list[BaseGeometry]\nThe target geometries to which the input_geometry should align.\nrequired\n\n\ninput_geometry\nBaseGeometry\nThe geometry to be processed. Supports Polygon, MultiPolygon, and linear geometries.\nrequired\n\n\nmitre_limit\nfloat\nThe limit used for miter joins to prevent sharp spikes in corners.\nrequired\n\n\nrelevant_distance\nfloat\nThe search radius used to find nearby reference geometries. If set to 0, no processing is performed.\n1.0\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to sub-processors.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nProcessResult\nAn object containing the aligned geometry and processing metadata (e.g., remarks or error logs).\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf the input_geometry is a GeometryCollection. If the input_geometry exceeds the configured area_limit.\n\n\n\n\n\n\nThe logic follows this decision flow:\n\n\n\n\n\ngraph TD\n      A[Start Process] --&gt; B{GeometryCollection?}\n      B -- Yes --&gt; C[Raise ValueError]\n      B -- No --&gt; D{Polygon/MultiPolygon?}\n      D -- No --&gt; E[Network Processor]\n      D -- Yes --&gt; F{Area &gt; Limit?}\n      F -- Yes --&gt; G[Raise ValueError]\n      F -- No --&gt; H{RD == 0?}\n      H -- Yes --&gt; I[Return Original]\n      H -- No --&gt; J[Dieussaert Processor]\n      J -- Success --&gt; K[Return Result]\n      J -- Fail --&gt; E\n      E --&gt; K",
    "crumbs": [
      "Reference",
      "Processors",
      "AlignerGeometryProcessor"
    ]
  },
  {
    "objectID": "reference/loader.GRBSpecificDateParcelLoader.html",
    "href": "reference/loader.GRBSpecificDateParcelLoader.html",
    "title": "loader.GRBSpecificDateParcelLoader",
    "section": "",
    "text": "be.grb.loader.GRBSpecificDateParcelLoader(date, aligner, partition=1000)\nLoader for GRB parcel situations on a specific historical date.\nThis loader allows for high-precision historical reconstruction of parcel boundaries as they existed on a specific day.\n.. warning:: This loader is experimental and intended for historical research. Data availability depends on the historical archives of the GRB provider.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndate\nstr\nThe historical date in the format defined by DATE_FORMAT.\nrequired\n\n\naligner\nAny\nThe aligner object providing spatial context.\nrequired\n\n\npartition\nint\nNumber of features per request, by default 1000.\n1000\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\n- If the date format is invalid. - If the date refers to the current or a future year.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nload_data\nDownload and process parcel data for the specified historical date.\n\n\n\n\n\nbe.grb.loader.GRBSpecificDateParcelLoader.load_data()\nDownload and process parcel data for the specified historical date.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nAny\nThe result of the parent GeoJsonLoader’s load_data method.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf thematic data has not been loaded into the aligner.",
    "crumbs": [
      "Reference",
      "GRB (Flanders-specific)",
      "loader.GRBSpecificDateParcelLoader"
    ]
  },
  {
    "objectID": "reference/loader.GRBSpecificDateParcelLoader.html#parameters",
    "href": "reference/loader.GRBSpecificDateParcelLoader.html#parameters",
    "title": "loader.GRBSpecificDateParcelLoader",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndate\nstr\nThe historical date in the format defined by DATE_FORMAT.\nrequired\n\n\naligner\nAny\nThe aligner object providing spatial context.\nrequired\n\n\npartition\nint\nNumber of features per request, by default 1000.\n1000",
    "crumbs": [
      "Reference",
      "GRB (Flanders-specific)",
      "loader.GRBSpecificDateParcelLoader"
    ]
  },
  {
    "objectID": "reference/loader.GRBSpecificDateParcelLoader.html#raises",
    "href": "reference/loader.GRBSpecificDateParcelLoader.html#raises",
    "title": "loader.GRBSpecificDateParcelLoader",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nValueError\n- If the date format is invalid. - If the date refers to the current or a future year.",
    "crumbs": [
      "Reference",
      "GRB (Flanders-specific)",
      "loader.GRBSpecificDateParcelLoader"
    ]
  },
  {
    "objectID": "reference/loader.GRBSpecificDateParcelLoader.html#methods",
    "href": "reference/loader.GRBSpecificDateParcelLoader.html#methods",
    "title": "loader.GRBSpecificDateParcelLoader",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nload_data\nDownload and process parcel data for the specified historical date.\n\n\n\n\n\nbe.grb.loader.GRBSpecificDateParcelLoader.load_data()\nDownload and process parcel data for the specified historical date.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nAny\nThe result of the parent GeoJsonLoader’s load_data method.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf thematic data has not been loaded into the aligner.",
    "crumbs": [
      "Reference",
      "GRB (Flanders-specific)",
      "loader.GRBSpecificDateParcelLoader"
    ]
  },
  {
    "objectID": "reference/BaseProcessor.html",
    "href": "reference/BaseProcessor.html",
    "title": "BaseProcessor",
    "section": "",
    "text": "processor.BaseProcessor(config, feedback=None)\nAbstract base class for geometric alignment processors.\nThe processor is responsible for the core alignment logic between thematic geometries and reference data. It provides a standardized pipeline for processing, cleaning, and validating resulting geometries.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nconfig\nProcessorConfig\nConfiguration object containing thresholds and strategy settings.\n\n\nfeedback\n(Any, optional)\nFeedback mechanism for reporting progress or logs.\n\n\nlogger\nLogger\nInternal logger for debugging and user feedback.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nprocess\nAbstract method to align a single geometry to the reference layer.\n\n\n\n\n\nprocessor.BaseProcessor.process(\n    correction_distance,\n    reference_data,\n    input_geometry,\n    mitre_limit,\n    relevant_distance,\n    thematic_data,\n    id_thematic,\n)\nAbstract method to align a single geometry to the reference layer.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncorrection_distance\nfloat\nSmall buffer distance used to filter out geometric noise.\nrequired\n\n\nreference_data\nAlignerFeatureCollection\nThe collection of reference geometries (the ‘target’).\nrequired\n\n\ninput_geometry\nBaseGeometry\nThe thematic geometry to be aligned.\nrequired\n\n\nmitre_limit\nfloat\nThe mitre limit used for buffering operations.\nrequired\n\n\nrelevant_distance\nfloat\nThe maximum distance within which alignment should occur.\nrequired\n\n\nthematic_data\nAlignerFeatureCollection\nThe full thematic collection for context.\nrequired\n\n\nid_thematic\nAny\nThe unique identifier of the feature being processed.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nProcessResult\nA dictionary containing the resulting geometry and difference metrics.",
    "crumbs": [
      "Reference",
      "Processors",
      "BaseProcessor"
    ]
  },
  {
    "objectID": "reference/BaseProcessor.html#attributes",
    "href": "reference/BaseProcessor.html#attributes",
    "title": "BaseProcessor",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nconfig\nProcessorConfig\nConfiguration object containing thresholds and strategy settings.\n\n\nfeedback\n(Any, optional)\nFeedback mechanism for reporting progress or logs.\n\n\nlogger\nLogger\nInternal logger for debugging and user feedback.",
    "crumbs": [
      "Reference",
      "Processors",
      "BaseProcessor"
    ]
  },
  {
    "objectID": "reference/BaseProcessor.html#methods",
    "href": "reference/BaseProcessor.html#methods",
    "title": "BaseProcessor",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nprocess\nAbstract method to align a single geometry to the reference layer.\n\n\n\n\n\nprocessor.BaseProcessor.process(\n    correction_distance,\n    reference_data,\n    input_geometry,\n    mitre_limit,\n    relevant_distance,\n    thematic_data,\n    id_thematic,\n)\nAbstract method to align a single geometry to the reference layer.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncorrection_distance\nfloat\nSmall buffer distance used to filter out geometric noise.\nrequired\n\n\nreference_data\nAlignerFeatureCollection\nThe collection of reference geometries (the ‘target’).\nrequired\n\n\ninput_geometry\nBaseGeometry\nThe thematic geometry to be aligned.\nrequired\n\n\nmitre_limit\nfloat\nThe mitre limit used for buffering operations.\nrequired\n\n\nrelevant_distance\nfloat\nThe maximum distance within which alignment should occur.\nrequired\n\n\nthematic_data\nAlignerFeatureCollection\nThe full thematic collection for context.\nrequired\n\n\nid_thematic\nAny\nThe unique identifier of the feature being processed.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nProcessResult\nA dictionary containing the resulting geometry and difference metrics.",
    "crumbs": [
      "Reference",
      "Processors",
      "BaseProcessor"
    ]
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "Aligner class of the brdr package.\n\n\n\nAligner\nCompares and aligns thematic geospatial data against a set of reference data.\n\n\nAlignerResult\nStores and processes the results from the alignment operation.\n\n\n\n\n\n\nClasses for the thematic and reference data to be used by the Aligner\n\n\n\nAlignerFeatureCollection\nA collection of AlignerFeature objects with spatial indexing and utility properties.\n\n\nAlignerFeature\nA container for a single thematic or reference feature within the aligner.\n\n\n\n\n\n\nLoaders to load data\n\n\n\nLoader\nAbstract base class for all data loaders.\n\n\nDictLoader\nLoader that accepts data directly from Python dictionaries.\n\n\nGeoJsonLoader\nBase class for loaders dealing with GeoJSON-formatted data.\n\n\nGeoJsonFileLoader\nLoads GeoJSON data from a local file system.\n\n\nGeoJsonUrlLoader\nLoads GeoJSON data from a remote URL via HTTP GET.\n\n\nOGCFeatureAPIReferenceLoader\nLoader for OGC API - Features services.\n\n\nWFSReferenceLoader\nLoader for OGC Web Feature Service (WFS) version 2.0.0.\n\n\n\n\n\n\nProcessor algorithms\n\n\n\nBaseProcessor\nAbstract base class for geometric alignment processors.\n\n\nAlignerGeometryProcessor\nProcessor responsible for aligning thematic geometries to reference data.\n\n\nDieussaertGeometryProcessor\nProcessor implementing the Dieussaert area-based alignment algorithm.\n\n\nNetworkGeometryProcessor\nProcessor that aligns geometries based on a linear network.\n\n\nSnapGeometryProcessor\nProcessor that aligns geometries by snapping them to the reference data.\n\n\nTopologyProcessor\nProcessor that aligns geometries while preserving topological relationships.\n\n\n\n\n\n\nEnums used in the brdr package.\n\n\n\nFullReferenceStrategy\nStrategy for handling reference data coverage.\n\n\nAlignerResultType\nFormat of the output dictionary.\n\n\nOpenDomainStrategy\nStrategies for processing thematic areas not covered by reference data.\n\n\nDiffMetric\nMetrics to quantify the change between thematic and reference data.\n\n\nProcessRemark\nStatus remarks added to processed features for auditing and debugging.\n\n\nEvaluation\nClassification of the alignment quality and reliability.\n\n\nSnapStrategy\nGeometric priority during snapping.\n\n\nPredictionStrategy\nDetermines which prediction is selected as the primary result.\n\n\nProcessorID\nUnique identifiers for the available alignment algorithms.\n\n\n\n\n\n\nTypings used in ‘brdr’\n\n\n\nProcessResult\nA dictionary structure representing the output of a geometric alignment process.\n\n\n\n\n\n\nConfigs used in ‘brdr’ Aligner & Processor\n\n\n\nProcessorConfig\nConfiguration for the geometric preprocessing of polygons in the brdr pipeline.\n\n\nAlignerConfig\nConfiguration for the alignment and correction of spatial boundaries.\n\n\n\n\n\n\nGRB (Flanders-specific) classes,methods, enumerators,…\n\n\n\nloader.GRBActualLoader\nLoader for the most recent version of GRB (Grootschalig Referentie Bestand).\n\n\nloader.GRBFiscalParcelLoader\nLoader for fiscal parcel data (Adpf) for a specific year.\n\n\nloader.GRBSpecificDateParcelLoader\nLoader for GRB parcel situations on a specific historical date.\n\n\ngrb.update_featurecollection_to_actual_grb\nUpdate a thematic feature collection to the most recent version of the GRB.\n\n\nutils.is_grb_changed\nchecks if a geometry is possibly affected by changes in the reference layer\n\n\nutils.get_affected_ids_by_grb_change\nGet a list of affected IDs by GRB-changes in a\n\n\nenums.GRBType\n\n\n\n\n\n\n\nOpenStreetMap (OSM) classes,methods, enumerators,…\n\n\n\nloader.OSMLoader\nLoader for OpenStreetMap (OSM) features based on specific tags.\n\n\n\n\n\n\nOpenStreetMap (OSM) classes,methods, enumerators,…\n\n\n\nshow_map\nDisplay a grid of maps showing alignment results across different distances.\n\n\nplot_difference_by_relevant_distance\nPlot geometric differences across multiple features as a line graph.\n\n\nanimated_map\nCreate a synchronized animation of map changes and area statistics.\n\n\nprint_observation_of_aligner_results\nPrint a detailed comparison analysis for alignment results.",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#aligner",
    "href": "reference/index.html#aligner",
    "title": "Function reference",
    "section": "",
    "text": "Aligner class of the brdr package.\n\n\n\nAligner\nCompares and aligns thematic geospatial data against a set of reference data.\n\n\nAlignerResult\nStores and processes the results from the alignment operation.",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#alignerfeatures",
    "href": "reference/index.html#alignerfeatures",
    "title": "Function reference",
    "section": "",
    "text": "Classes for the thematic and reference data to be used by the Aligner\n\n\n\nAlignerFeatureCollection\nA collection of AlignerFeature objects with spatial indexing and utility properties.\n\n\nAlignerFeature\nA container for a single thematic or reference feature within the aligner.",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#loaders",
    "href": "reference/index.html#loaders",
    "title": "Function reference",
    "section": "",
    "text": "Loaders to load data\n\n\n\nLoader\nAbstract base class for all data loaders.\n\n\nDictLoader\nLoader that accepts data directly from Python dictionaries.\n\n\nGeoJsonLoader\nBase class for loaders dealing with GeoJSON-formatted data.\n\n\nGeoJsonFileLoader\nLoads GeoJSON data from a local file system.\n\n\nGeoJsonUrlLoader\nLoads GeoJSON data from a remote URL via HTTP GET.\n\n\nOGCFeatureAPIReferenceLoader\nLoader for OGC API - Features services.\n\n\nWFSReferenceLoader\nLoader for OGC Web Feature Service (WFS) version 2.0.0.",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#processors",
    "href": "reference/index.html#processors",
    "title": "Function reference",
    "section": "",
    "text": "Processor algorithms\n\n\n\nBaseProcessor\nAbstract base class for geometric alignment processors.\n\n\nAlignerGeometryProcessor\nProcessor responsible for aligning thematic geometries to reference data.\n\n\nDieussaertGeometryProcessor\nProcessor implementing the Dieussaert area-based alignment algorithm.\n\n\nNetworkGeometryProcessor\nProcessor that aligns geometries based on a linear network.\n\n\nSnapGeometryProcessor\nProcessor that aligns geometries by snapping them to the reference data.\n\n\nTopologyProcessor\nProcessor that aligns geometries while preserving topological relationships.",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#enumerators",
    "href": "reference/index.html#enumerators",
    "title": "Function reference",
    "section": "",
    "text": "Enums used in the brdr package.\n\n\n\nFullReferenceStrategy\nStrategy for handling reference data coverage.\n\n\nAlignerResultType\nFormat of the output dictionary.\n\n\nOpenDomainStrategy\nStrategies for processing thematic areas not covered by reference data.\n\n\nDiffMetric\nMetrics to quantify the change between thematic and reference data.\n\n\nProcessRemark\nStatus remarks added to processed features for auditing and debugging.\n\n\nEvaluation\nClassification of the alignment quality and reliability.\n\n\nSnapStrategy\nGeometric priority during snapping.\n\n\nPredictionStrategy\nDetermines which prediction is selected as the primary result.\n\n\nProcessorID\nUnique identifiers for the available alignment algorithms.",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#typings",
    "href": "reference/index.html#typings",
    "title": "Function reference",
    "section": "",
    "text": "Typings used in ‘brdr’\n\n\n\nProcessResult\nA dictionary structure representing the output of a geometric alignment process.",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#configs",
    "href": "reference/index.html#configs",
    "title": "Function reference",
    "section": "",
    "text": "Configs used in ‘brdr’ Aligner & Processor\n\n\n\nProcessorConfig\nConfiguration for the geometric preprocessing of polygons in the brdr pipeline.\n\n\nAlignerConfig\nConfiguration for the alignment and correction of spatial boundaries.",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#grb-flanders-specific",
    "href": "reference/index.html#grb-flanders-specific",
    "title": "Function reference",
    "section": "",
    "text": "GRB (Flanders-specific) classes,methods, enumerators,…\n\n\n\nloader.GRBActualLoader\nLoader for the most recent version of GRB (Grootschalig Referentie Bestand).\n\n\nloader.GRBFiscalParcelLoader\nLoader for fiscal parcel data (Adpf) for a specific year.\n\n\nloader.GRBSpecificDateParcelLoader\nLoader for GRB parcel situations on a specific historical date.\n\n\ngrb.update_featurecollection_to_actual_grb\nUpdate a thematic feature collection to the most recent version of the GRB.\n\n\nutils.is_grb_changed\nchecks if a geometry is possibly affected by changes in the reference layer\n\n\nutils.get_affected_ids_by_grb_change\nGet a list of affected IDs by GRB-changes in a\n\n\nenums.GRBType",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#osm",
    "href": "reference/index.html#osm",
    "title": "Function reference",
    "section": "",
    "text": "OpenStreetMap (OSM) classes,methods, enumerators,…\n\n\n\nloader.OSMLoader\nLoader for OpenStreetMap (OSM) features based on specific tags.",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#visualization-functions-optional-by-pip-install-brdrviz",
    "href": "reference/index.html#visualization-functions-optional-by-pip-install-brdrviz",
    "title": "Function reference",
    "section": "",
    "text": "OpenStreetMap (OSM) classes,methods, enumerators,…\n\n\n\nshow_map\nDisplay a grid of maps showing alignment results across different distances.\n\n\nplot_difference_by_relevant_distance\nPlot geometric differences across multiple features as a line graph.\n\n\nanimated_map\nCreate a synchronized animation of map changes and area statistics.\n\n\nprint_observation_of_aligner_results\nPrint a detailed comparison analysis for alignment results.",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/AlignerFeatureCollection.html",
    "href": "reference/AlignerFeatureCollection.html",
    "title": "AlignerFeatureCollection",
    "section": "",
    "text": "feature_data.AlignerFeatureCollection(\n    features,\n    source=None,\n    id_fieldname=None,\n    crs=None,\n    is_reference=False,\n)\nA collection of AlignerFeature objects with spatial indexing and utility properties.\nThis class manages a group of features, providing high-level access to spatial operations like unary unions and R-tree indexing for fast spatial queries.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfeatures\ndict[ThematicId, AlignerFeature]\nA dictionary mapping feature IDs to their corresponding AlignerFeature objects.\n\n\nsource\ndict[str, str]\nMetadata regarding the source of the data.\n\n\nis_reference\nbool\nFlag indicating if this collection serves as the reference dataset (enables spatial indexing).\n\n\ncrs\n(CRS, optional)\nThe Coordinate Reference System associated with the collection.\n\n\n\n\n\n\nWhen is_reference is set to True, the collection lazily initializes a spatial index ([shapely.strtree.STRtree][]) upon the first access to the tree property.\n\n\n\n&gt;&gt;&gt; collection = AlignerFeatureCollection(features=my_feature_dict, is_reference=True)\n&gt;&gt;&gt; # Access the spatial index\n&gt;&gt;&gt; index = collection.tree\n&gt;&gt;&gt; # Get a union of all geometries\n&gt;&gt;&gt; total_area = collection.union.area\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nto_geojson\nConverts the collection into a GeoJSON FeatureCollection format.\n\n\n\n\n\nfeature_data.AlignerFeatureCollection.to_geojson(geom_attributes=False)\nConverts the collection into a GeoJSON FeatureCollection format.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ngeom_attributes\nbool\nIf True, includes calculated geometric attributes (like area or length) in the feature properties. Defaults to False.\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nFeatureCollection\nA GeoJSON representation of the data.",
    "crumbs": [
      "Reference",
      "AlignerFeatures",
      "AlignerFeatureCollection"
    ]
  },
  {
    "objectID": "reference/AlignerFeatureCollection.html#attributes",
    "href": "reference/AlignerFeatureCollection.html#attributes",
    "title": "AlignerFeatureCollection",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nfeatures\ndict[ThematicId, AlignerFeature]\nA dictionary mapping feature IDs to their corresponding AlignerFeature objects.\n\n\nsource\ndict[str, str]\nMetadata regarding the source of the data.\n\n\nis_reference\nbool\nFlag indicating if this collection serves as the reference dataset (enables spatial indexing).\n\n\ncrs\n(CRS, optional)\nThe Coordinate Reference System associated with the collection.",
    "crumbs": [
      "Reference",
      "AlignerFeatures",
      "AlignerFeatureCollection"
    ]
  },
  {
    "objectID": "reference/AlignerFeatureCollection.html#notes",
    "href": "reference/AlignerFeatureCollection.html#notes",
    "title": "AlignerFeatureCollection",
    "section": "",
    "text": "When is_reference is set to True, the collection lazily initializes a spatial index ([shapely.strtree.STRtree][]) upon the first access to the tree property.",
    "crumbs": [
      "Reference",
      "AlignerFeatures",
      "AlignerFeatureCollection"
    ]
  },
  {
    "objectID": "reference/AlignerFeatureCollection.html#examples",
    "href": "reference/AlignerFeatureCollection.html#examples",
    "title": "AlignerFeatureCollection",
    "section": "",
    "text": "&gt;&gt;&gt; collection = AlignerFeatureCollection(features=my_feature_dict, is_reference=True)\n&gt;&gt;&gt; # Access the spatial index\n&gt;&gt;&gt; index = collection.tree\n&gt;&gt;&gt; # Get a union of all geometries\n&gt;&gt;&gt; total_area = collection.union.area",
    "crumbs": [
      "Reference",
      "AlignerFeatures",
      "AlignerFeatureCollection"
    ]
  },
  {
    "objectID": "reference/AlignerFeatureCollection.html#methods",
    "href": "reference/AlignerFeatureCollection.html#methods",
    "title": "AlignerFeatureCollection",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nto_geojson\nConverts the collection into a GeoJSON FeatureCollection format.\n\n\n\n\n\nfeature_data.AlignerFeatureCollection.to_geojson(geom_attributes=False)\nConverts the collection into a GeoJSON FeatureCollection format.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ngeom_attributes\nbool\nIf True, includes calculated geometric attributes (like area or length) in the feature properties. Defaults to False.\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nFeatureCollection\nA GeoJSON representation of the data.",
    "crumbs": [
      "Reference",
      "AlignerFeatures",
      "AlignerFeatureCollection"
    ]
  },
  {
    "objectID": "reference/WFSReferenceLoader.html",
    "href": "reference/WFSReferenceLoader.html",
    "title": "WFSReferenceLoader",
    "section": "",
    "text": "loader.WFSReferenceLoader(\n    url,\n    id_property,\n    typename,\n    aligner,\n    partition=1000,\n    limit=DOWNLOAD_LIMIT,\n    is_reference=True,\n)\nLoader for OGC Web Feature Service (WFS) version 2.0.0.\nSupports GetCapabilities parsing and GetFeature requests with spatial filtering using the Aligner’s extent.\n\n\n\n\n\nName\nDescription\n\n\n\n\nload_data\nDownloads features via GetFeature based on capabilities and extent.\n\n\n\n\n\nloader.WFSReferenceLoader.load_data()\nDownloads features via GetFeature based on capabilities and extent.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nAlignerFeatureCollection\nThe downloaded and processed reference data.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf thematic data is missing, typename is not found, or the service does not support the Aligner’s CRS.",
    "crumbs": [
      "Reference",
      "Loaders",
      "WFSReferenceLoader"
    ]
  },
  {
    "objectID": "reference/WFSReferenceLoader.html#methods",
    "href": "reference/WFSReferenceLoader.html#methods",
    "title": "WFSReferenceLoader",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nload_data\nDownloads features via GetFeature based on capabilities and extent.\n\n\n\n\n\nloader.WFSReferenceLoader.load_data()\nDownloads features via GetFeature based on capabilities and extent.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nAlignerFeatureCollection\nThe downloaded and processed reference data.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf thematic data is missing, typename is not found, or the service does not support the Aligner’s CRS.",
    "crumbs": [
      "Reference",
      "Loaders",
      "WFSReferenceLoader"
    ]
  },
  {
    "objectID": "reference/GeoJsonFileLoader.html",
    "href": "reference/GeoJsonFileLoader.html",
    "title": "GeoJsonFileLoader",
    "section": "",
    "text": "GeoJsonFileLoader\nloader.GeoJsonFileLoader(path_to_file, id_property, is_reference=False)\nLoads GeoJSON data from a local file system.",
    "crumbs": [
      "Reference",
      "Loaders",
      "GeoJsonFileLoader"
    ]
  },
  {
    "objectID": "reference/ProcessorConfig.html",
    "href": "reference/ProcessorConfig.html",
    "title": "ProcessorConfig",
    "section": "",
    "text": "configs.ProcessorConfig(\n    multi_as_single_modus=True,\n    max_outer_buffer=50,\n    od_strategy=OpenDomainStrategy.SNAP_ALL_SIDE,\n    threshold_overlap_percentage=50,\n    threshold_exclusion_area=0,\n    threshold_exclusion_percentage=0,\n    threshold_inclusion_percentage=100,\n    buffer_multiplication_factor=1.01,\n    threshold_circle_ratio=0.98,\n    snap_strategy=SnapStrategy.PREFER_VERTICES,\n    snap_max_segment_length=2,\n    partial_snapping=False,\n    partial_snap_strategy=SnapStrategy.PREFER_VERTICES,\n    partial_snap_max_segment_length=2,\n    area_limit=None,\n)\nConfiguration for the geometric preprocessing of polygons in the brdr pipeline.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmulti_as_single_modus\nbool\nModus to handle multipolygons. If True, input multipolygons are split into single polygons for processing and merged back afterward. If False, multipolygons are processed as a single unit.\nTrue\n\n\nmax_outer_buffer\nint\nValue that is used to calculate the boundary of a thematic geometry wherefor the calculation has to be done. (inner part is added)\n50\n\n\nod_strategy\nOpenDomainStrategy\nThe strategy used to determine how to handle information outside the reference polygons (Open Domain).\nOpenDomainStrategy.SNAP_ALL_SIDE\n\n\nthreshold_overlap_percentage\nint\nThreshold (%) to determine if a reference polygon should be included when no relevant intersections or differences exist. If set to -1, the original border is returned in such cases.\n50\n\n\nthreshold_exclusion_area\nint\nArea in square meters (\\(m^2\\)) below which candidate reference polygons are excluded from processing.\n0\n\n\nthreshold_exclusion_percentage\nint\nOverlap percentage below which candidate reference polygons are excluded.\n0\n\n\nthreshold_inclusion_percentage\nint\nPercentage threshold above which a reference polygon is automatically included in the alignment process.\n100\n\n\nbuffer_multiplication_factor\nfloat\nFactor used to buffer thematic objects when searching for reference borders (buffer = factor * relevant_distance).\n1.01\n\n\nthreshold_circle_ratio\nfloat\nThreshold to exclude circular geometries based on the Polsby-Popper algorithm (where 1.0 is a perfect circle).\n0.98\n\n\nsnap_strategy\nSnapStrategy\nThe primary strategy used for snapping geometry vertices to the reference. When alignment is done by ‘SnapGeometryProcessor’, This strategy will be applied\nSnapStrategy.PREFER_VERTICES\n\n\nsnap_max_segment_length\nint\nThe maximum segment length allowed during the snapping process. When alignment is done by ‘SnapGeometryProcessor’, the input geometry (line, lineair ring,…) will be split up by default in parts of max X meter\n2\n\n\npartial_snapping\nbool\nWhether to allow snapping of individual segments rather than the entire geometry.\nFalse\n\n\npartial_snap_strategy\nSnapStrategy\nThe strategy used specifically for partial snapping operations. When snapping of partial geometries (geom_x) is executed, This strategy will be applied.\nSnapStrategy.PREFER_VERTICES\n\n\npartial_snap_max_segment_length\nint\nThe maximum segment length allowed during partial snapping. When real snapping of vertices is used, the input geometry will be split up by default in parts of max X meter\n2\n\n\narea_limit\nint\nMaximum area for processing. If a polygon exceeds this limit, it may be skipped or simplified.\nNone",
    "crumbs": [
      "Reference",
      "Configs",
      "ProcessorConfig"
    ]
  },
  {
    "objectID": "reference/ProcessorConfig.html#parameters",
    "href": "reference/ProcessorConfig.html#parameters",
    "title": "ProcessorConfig",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nmulti_as_single_modus\nbool\nModus to handle multipolygons. If True, input multipolygons are split into single polygons for processing and merged back afterward. If False, multipolygons are processed as a single unit.\nTrue\n\n\nmax_outer_buffer\nint\nValue that is used to calculate the boundary of a thematic geometry wherefor the calculation has to be done. (inner part is added)\n50\n\n\nod_strategy\nOpenDomainStrategy\nThe strategy used to determine how to handle information outside the reference polygons (Open Domain).\nOpenDomainStrategy.SNAP_ALL_SIDE\n\n\nthreshold_overlap_percentage\nint\nThreshold (%) to determine if a reference polygon should be included when no relevant intersections or differences exist. If set to -1, the original border is returned in such cases.\n50\n\n\nthreshold_exclusion_area\nint\nArea in square meters (\\(m^2\\)) below which candidate reference polygons are excluded from processing.\n0\n\n\nthreshold_exclusion_percentage\nint\nOverlap percentage below which candidate reference polygons are excluded.\n0\n\n\nthreshold_inclusion_percentage\nint\nPercentage threshold above which a reference polygon is automatically included in the alignment process.\n100\n\n\nbuffer_multiplication_factor\nfloat\nFactor used to buffer thematic objects when searching for reference borders (buffer = factor * relevant_distance).\n1.01\n\n\nthreshold_circle_ratio\nfloat\nThreshold to exclude circular geometries based on the Polsby-Popper algorithm (where 1.0 is a perfect circle).\n0.98\n\n\nsnap_strategy\nSnapStrategy\nThe primary strategy used for snapping geometry vertices to the reference. When alignment is done by ‘SnapGeometryProcessor’, This strategy will be applied\nSnapStrategy.PREFER_VERTICES\n\n\nsnap_max_segment_length\nint\nThe maximum segment length allowed during the snapping process. When alignment is done by ‘SnapGeometryProcessor’, the input geometry (line, lineair ring,…) will be split up by default in parts of max X meter\n2\n\n\npartial_snapping\nbool\nWhether to allow snapping of individual segments rather than the entire geometry.\nFalse\n\n\npartial_snap_strategy\nSnapStrategy\nThe strategy used specifically for partial snapping operations. When snapping of partial geometries (geom_x) is executed, This strategy will be applied.\nSnapStrategy.PREFER_VERTICES\n\n\npartial_snap_max_segment_length\nint\nThe maximum segment length allowed during partial snapping. When real snapping of vertices is used, the input geometry will be split up by default in parts of max X meter\n2\n\n\narea_limit\nint\nMaximum area for processing. If a polygon exceeds this limit, it may be skipped or simplified.\nNone",
    "crumbs": [
      "Reference",
      "Configs",
      "ProcessorConfig"
    ]
  },
  {
    "objectID": "examples/example_lambert72_to_lambert08.html",
    "href": "examples/example_lambert72_to_lambert08.html",
    "title": "Lambert72 to Lambert 08",
    "section": "",
    "text": "Lambert72/08 transformation\nThis example shows how brdr can be used to align a data-object after Lambert72/08-tranformation, so small deviations of the transformation are re-aligned to a 08-reference-layer.\n\n\nCode\nfrom pyproj import Transformer\nfrom shapely.ops import transform\n\nfrom brdr.aligner import Aligner\nfrom brdr.be.grb.enums import GRBType\nfrom brdr.be.grb.loader import GRBActualLoader\nfrom brdr.be.oe.enums import OEType\nfrom brdr.be.oe.loader import OnroerendErfgoedLoader\nfrom brdr.loader import DictLoader\nfrom brdr.viz import show_map\n\n\ndef transforms_geom_31370_to_3812(geom):\n    \"\"\"\n    Transforms a Shapely (Multi-)Polygon from EPSG:31370 to EPSG:3812.\n    \"\"\"\n    transformer = Transformer.from_crs(\"EPSG:31370\", \"EPSG:3812\", always_xy=True)\n\n    return transform(transformer.transform, geom)\n\n\nif __name__ == \"__main__\":\n    # 1) Load data in Lambert72  & Align to reference layer (72)\n    ##################################################################\n\n    # BASE\n    # =====\n    # Initiate an Aligner to create a dataset that is base-referenced on a specific base_year\n    aligner72 = Aligner(crs=\"EPSG:31370\")\n    print(\"start loading OE-objects\")\n    # Load the thematic data to evaluate\n    loader = OnroerendErfgoedLoader(\n        objectids=[\"https://id.erfgoed.net/aanduidingsobjecten/121125\"],\n        oetype=OEType.AO,\n    )\n    aligner72.load_thematic_data(loader)\n    print(\n        \"Number of OE-thematic features loaded into base-aligner: \"\n        + str(len(aligner72.thematic_data.features))\n    )\n    aligner72.load_reference_data(\n        GRBActualLoader(grb_type=GRBType.ADP, partition=1000, aligner=aligner72)\n    )\n    print(\"Reference-data loaded\")\n    #\n    rd = 2\n    aligner_result72 = aligner72.process(relevant_distances=[rd])\n    print(\n        \"Processed: the data-object is now fully aligned to the reference-data in Lambert72\"\n    )\n    dict08 = {}\n\n    # transform features (72--&gt;2008)\n    print(\n        \"Next, we do a transformation of the data-object to Lambert08, possibly resulting in some deviations\"\n    )\n    for key, processresult in aligner_result72.results.items():\n        dict08[key] = transforms_geom_31370_to_3812(processresult[rd][\"result\"])\n\n    # Align to GRB (2008)\n    print(\n        \"We make a new aligner with CRS EPSG:3812 (Lambert08), so we can align the deviated object to the reference-data(Lambert08)\"\n    )\n    aligner08 = Aligner(crs=\"EPSG:3812\")\n    loader = DictLoader(dict08)\n    aligner08.load_thematic_data(loader)\n    aligner08.load_reference_data(\n        GRBActualLoader(grb_type=GRBType.ADP, partition=1000, aligner=aligner08)\n    )\n    rd08 = 0.5  # we use 0.5, so deviations up to 50cm will be aligner to the reference-data(Lambert08)\n    aligner_result08 = aligner08.process(relevant_distances=[rd08])\n    for key, processresult in aligner_result08.results.items():\n\n        print(\n            \"Resulting aligned geometry (Lambert08): \"\n            + processresult[rd08][\"result\"].wkt\n        )\n        print(\n            \"Corrected deviations (Lambert08): \"\n            + processresult[rd08][\"result_diff\"].wkt\n        )\n\n    thematic_geometries = {\n        key: feat.geometry for key, feat in aligner08.thematic_data.features.items()\n    }\n    reference_geometries = {\n        key: feat.geometry for key, feat in aligner08.reference_data.features.items()\n    }\n    show_map(aligner_result08.results, thematic_geometries, reference_geometries)\n\n\nstart loading OE-objects\nNumber of OE-thematic features loaded into base-aligner: 1\nReference-data loaded\nProcessed: the data-object is now fully aligned to the reference-data in Lambert72\nNext, we do a transformation of the data-object to Lambert08, possibly resulting in some deviations\nWe make a new aligner with CRS EPSG:3812 (Lambert08), so we can align the deviated object to the reference-data(Lambert08)\nResulting aligned geometry (Lambert08): POLYGON ((625042.18167686 680576.17805293, 625028.0450691443 680604.871368738, 625030.0914367443 680605.441999969, 625038.987479072 680607.9236184452, 625039.7678556138 680608.1413104001, 625039.7995553301 680608.1501532793, 625072.7417162794 680617.3396189411, 625084.1533328403 680620.5229759387, 625117.0412757118 680629.6969620653, 625124.1793480635 680564.1786487388, 625108.1413849437 680555.876637919, 625109.2966578464 680545.2685593893, 625110.4025965496 680545.42284679, 625110.6027168096 680542.21983937, 625110.8314346 680538.5610331503, 625111.0601523103 680534.90293092, 625111.1885855796 680532.8490843297, 625111.23128983 680532.16583411, 625111.3483120692 680530.2942736049, 625098.7473393852 680525.1911945271, 625098.2277884147 680526.3531511744, 625098.1777067562 680526.465156962, 625095.28323865 680525.04495726, 625090.5339789528 680522.7146866346, 625081.1058448796 680518.08960439, 625080.2064426197 680523.11042433, 625079.3794076897 680527.72722602, 625078.8939073196 680530.43740508, 625078.2542584604 680534.0084186196, 625077.60525951 680537.63152636, 625077.063978774 680540.6529269313, 625077.0433572696 680540.76889077, 625073.753512469 680540.30846709, 625073.54827796 680540.2050836104, 625071.3089372007 680539.0768273204, 625071.0651950028 680539.888627782, 625071.0534784797 680539.9281776451, 625058.3830996593 680582.2375343896, 625042.18167686 680576.17805293))\nCorrected deviations (Lambert08): MULTIPOLYGON (((625110.6027168096 680542.21983937, 625110.8314346 680538.5610331503, 625111.0601523103 680534.90293092, 625111.1885855796 680532.8490843297, 625111.23128983 680532.16583411, 625111.3483120692 680530.2942736049, 625111.3182642603 680530.2821049937, 625111.2086993367 680532.0343743499, 625111.1659951264 680532.7176140873, 625111.0375595295 680534.7714689089, 625110.808837501 680538.4295883679, 625110.5801153713 680542.0884120895, 625110.3799913554 680545.2914343103, 625109.3104167469 680545.1422208368, 625109.2966578464 680545.2685593893, 625110.4025965496 680545.42284679, 625110.6027168096 680542.21983937)), ((625058.3830996593 680582.2375343896, 625071.0534784689 680539.9281776812, 625071.0651949941 680539.8886278111, 625071.3089372007 680539.0768273204, 625073.54827796 680540.2050836104, 625073.753512469 680540.30846709, 625077.0433572696 680540.76889077, 625077.063978774 680540.6529269313, 625077.60525951 680537.63152636, 625078.2542584604 680534.0084186196, 625078.8939073196 680530.43740508, 625079.3794076897 680527.72722602, 625080.2064426197 680523.11042433, 625081.1058448796 680518.08960439, 625090.5339788126 680522.7146865658, 625095.28323865 680525.04495726, 625098.1777067562 680526.465156962, 625098.2218593396 680526.3664113319, 625095.2606841647 680524.9134760932, 625090.5114342512 680522.5832021107, 625081.0833221747 680517.9581145948, 625080.1839151406 680522.9789592265, 625079.3568756661 680527.5957837077, 625078.871372633 680530.3059761532, 625078.2317202648 680533.8770073362, 625077.5827177647 680537.5001329893, 625077.041434098 680540.521548292, 625077.0208124437 680540.6375129187, 625073.730973594 680540.1770926312, 625073.5257411728 680540.073709828, 625071.2864038679 680538.9454512311, 625071.0426610925 680539.7572556819, 625071.0309444739 680539.7968059701, 625058.3605326456 680582.1063814665, 625042.1591440777 680576.0468996338, 625027.9685043712 680604.8500185898, 625028.0450691443 680604.871368738, 625042.18167686 680576.17805293, 625058.3830996593 680582.2375343896)))\n\n\n\n\n\nAlignment after Lambert72/08-transformation"
  },
  {
    "objectID": "examples/example_dictloader.html",
    "href": "examples/example_dictloader.html",
    "title": "DictLoader",
    "section": "",
    "text": "DictLoader\nThis example shows a basic Loader example of the Aligner\n\nfrom brdr.aligner import Aligner\nfrom brdr.be.grb.enums import GRBType\nfrom brdr.be.grb.loader import GRBActualLoader\nfrom brdr.geometry_utils import geom_from_wkt\n\nfrom brdr.loader import DictLoader\n\nif __name__ == \"__main__\":\n    \"\"\"\n    Example to load dat with a DictLoader, and also adding the properties to the result\n    \"\"\"\n    # CREATE AN ALIGNER\n    aligner = Aligner(crs=\"EPSG:31370\")\n    # ADD A THEMATIC POLYGON TO THEMATIC DICTIONARY and LOAD into Aligner\n    id = \"my_theme_id\"\n    wkt = \"MULTIPOLYGON (((141894.30860000103712082 192030.99359999969601631, 141895.30039999634027481 192030.43499999865889549, 141916.94680000096559525 192018.24240000173449516, 141935.11959999799728394 192008.00629999861121178, 141938.46660000085830688 192006.36679999902844429, 141938.01630000025033951 192004.09310000017285347, 141936.13579999655485153 191997.07739999890327454, 141927.83190000057220459 191974.37330000102519989, 141924.48290000110864639 191964.26909999921917915, 141918.48789999634027481 191946.18219999969005585, 141897.54580000042915344 191892.38010000064969063, 141885.81229999661445618 191863.05810000002384186, 141883.73430000245571136 191858.32620000094175339, 141881.57930000126361847 191851.27149999886751175, 141880.02970000356435776 191844.1534000001847744, 141875.37430000305175781 191822.76999999955296516, 141875.30219999700784683 191822.43849999830126762, 141875.31379999965429306 191822.42839999869465828, 141875.32599999755620956 191822.41780000180006027, 141873.66679999977350235 191810.330400001257658, 141873.53939999639987946 191810.47140000015497208, 141824.16929999738931656 191865.09059999883174896, 141807.49130000174045563 191883.54179999977350235, 141806.4221000000834465 191884.39990000054240227, 141804.12879999727010727 191884.68789999932050705, 141802.18280000239610672 191884.19500000029802322, 141799.86169999837875366 191882.65430000051856041, 141797.43410000205039978 191879.70760000124573708, 141796.65850000083446503 191879.23550000041723251, 141795.6005999967455864 191879.14139999821782112, 141793.61129999905824661 191879.65769999846816063, 141791.29720000177621841 191881.41699999943375587, 141775.49679999798536301 191898.58630000054836273, 141762.63560000061988831 191912.02459999918937683, 141746.34480000287294388 191931.99890000000596046, 141739.71980000287294388 191941.33379999920725822, 141718.17260000109672546 191963.87099999934434891, 141707.33889999985694885 191974.1517999991774559, 141691.99570000171661377 191990.56419999897480011, 141682.7752000018954277 191999.544599998742342, 141680.59319999814033508 192001.8539000004529953, 141677.57880000025033951 192009.98910000175237656, 141677.57880000025033951 192024.72419999912381172, 141687.39810000360012054 192032.38650000095367432, 141710.51529999822378159 192048.2443000003695488, 141718.70740000158548355 192054.53130000084638596, 141792.93550000339746475 192111.49830000102519989, 141790.39050000160932541 192115.83139999955892563, 141771.93940000236034393 192145.56280000135302544, 141756.72280000150203705 192171.94390000030398369, 141750.73979999870061874 192185.24599999934434891, 141746.87189999967813492 192192.59640000015497208, 141744.20000000298023224 192197.03090000152587891, 141741.65730000287294388 192203.05490000173449516, 141738.98480000346899033 192211.15890000015497208, 141736.27549999952316284 192222.19130000099539757, 141734.4122999981045723 192232.36960000172257423, 141734.01650000363588333 192233.20839999988675117, 141733.4156000018119812 192233.86070000007748604, 141732.60769999772310257 192234.36529999971389771, 141731.69009999930858612 192234.72720000147819519, 141730.37650000303983688 192234.86820000037550926, 141727.74570000171661377 192234.72109999880194664, 141708.45470000058412552 192234.2791999988257885, 141680.76659999787807465 192234.02210000157356262, 141656.07289999723434448 192234.38520000129938126, 141629.07209999859333038 192233.29850000143051147, 141618.51850000023841858 192231.88439999893307686, 141603.34749999642372131 192228.10990000143647194, 141597.26340000331401825 192226.65670000016689301, 141592.5292000025510788 192225.30229999870061874, 141568.39479999989271164 192219.11100000143051147, 141554.37330000102519989 192214.54509999975562096, 141541.26389999687671661 192208.97210000082850456, 141529.27139999717473984 192202.5982000008225441, 141527.42339999973773956 192207.54980000108480453, 141526.95019999891519547 192208.81769999861717224, 141538.93559999763965607 192213.12829999998211861, 141551.88490000367164612 192218.77100000157952309, 141563.40359999984502792 192223.01000000163912773, 141568.94730000197887421 192224.56370000168681145, 141588.22190000116825104 192230.68310000002384186, 141599.65079999715089798 192233.4813000001013279, 141604.27549999952316284 192234.52360000088810921, 141612.59619999676942825 192236.39869999885559082, 141625.6671999990940094 192238.60940000042319298, 141640.7581000030040741 192239.92980000004172325, 141687.70180000364780426 192239.60280000045895576, 141708.04810000211000443 192239.78669999912381172, 141725.32699999958276749 192239.62020000070333481, 141736.44510000199079514 192239.40599999949336052, 141738.10999999940395355 192233.08529999852180481, 141744.46729999780654907 192208.94959999993443489, 141747.24490000307559967 192201.90359999984502792, 141750.76910000294446945 192194.79340000078082085, 141757.62960000336170197 192183.66059999912977219, 141765.30849999934434891 192168.3214000016450882, 141766.5877000018954277 192166.07369999960064888, 141779.35530000180006027 192173.02180000022053719, 141801.67239999771118164 192199.32169999927282333, 141831.40259999781847 192121.48229999840259552, 141831.68190000206232071 192121.63430000096559525, 141839.40439999848604202 192125.83700000122189522, 141847.05669999867677689 192105.80189999938011169, 141848.41929999738931656 192102.23440000042319298, 141852.30349999666213989 192092.06469999998807907, 141856.9464000016450882 192074.37240000069141388, 141855.61249999701976776 192070.44669999927282333, 141854.58449999988079071 192067.42040000110864639, 141851.04050000011920929 192056.98910000175237656, 141853.14169999957084656 192055.68459999933838844, 141855.8546999990940094 192053.98660000041127205, 141857.53270000219345093 192052.94280000030994415, 141865.36980000138282776 192048.06769999861717224, 141878.53230000287294388 192039.87979999929666519, 141877.30830000340938568 192037.69469999894499779, 141888.70970000326633453 192031.27279999852180481, 141889.19900000095367432 192031.21249999850988388, 141890.32779999822378159 192033.23580000177025795, 141894.30860000103712082 192030.99359999969601631),(141798.70589999854564667 192111.06799999997019768, 141801.00859999656677246 192106.89739999920129776, 141829.50010000169277191 192122.21880000084638596, 141800.99939999729394913 192196.83920000120997429, 141781.65139999985694885 192173.08870000019669533, 141767.0609000027179718 192165.24260000139474869, 141773.47720000147819519 192153.96849999949336052, 141785.42890000343322754 192135.11470000073313713, 141798.70589999854564667 192111.06799999997019768)))\"\n    thematic_dict = {id: geom_from_wkt(wkt)}\n    loader = DictLoader(data_dict=thematic_dict)\n    aligner.load_thematic_data(loader)\n\n    # Load reference data: The actual GRB-parcels\n    loader = GRBActualLoader(grb_type=GRBType.ADP, partition=1000, aligner=aligner)\n    aligner.load_reference_data(loader)\n    # EXECUTE THE ALIGNMENT\n    relevant_distance = 5\n    aligner_result = aligner.process(relevant_distances=[relevant_distance])\n    process_results = aligner_result.get_results(aligner=aligner)\n    # PRINT RESULTS IN WKT\n    print(\"result: \" + process_results[id][relevant_distance][\"result\"].wkt)\n    print(\n        \"added area: \" + process_results[id][relevant_distance][\"result_diff_plus\"].wkt\n    )\n    print(\n        \"removed area: \" + process_results[id][relevant_distance][\"result_diff_min\"].wkt\n    )\n\nresult: MULTIPOLYGON (((141793.03305738285 192111.57318755027, 141790.3904695799 192115.8313674, 141771.93939757044 192145.56282341923, 141756.72275755982 192171.94387944016, 141750.7398455493 192185.2460234514, 141746.87194155 192192.59642345, 141742.82794304754 192200.28146594105, 141741.65728554007 192203.0549194593, 141739.89092246076 192208.41111370703, 141741.73062030482 192209.46040323336, 141750.76909355 192194.79341545, 141757.6296375507 192183.66061543886, 141765.30848556166 192168.32135143687, 141766.5828628447 192166.08220142793, 141767.06086818798 192165.24256983973, 141773.4771895606 192153.96845541894, 141785.4289335803 192135.1146954095, 141796.82158037843 192114.48072135754, 141797.44501794243 192113.35157246463, 141797.60589956064 192113.06018915444, 141798.28997375924 192111.8212172532, 141798.70586158 192111.0679753901, 141801.0038013616 192106.90600920998, 141801.6800913187 192105.68115173615, 141801.83878959 192105.39373539, 141831.4026264999 192121.48230970738, 141831.6818585496 192121.634309734, 141839.40442161 192125.8370634101, 141847.05670962 192105.80186339008, 141848.41933292866 192102.23450520015, 141852.3034936202 192092.0647113792, 141856.94637363 192074.37242337025, 141855.6125496299 192070.44666336008, 141854.5844539097 192067.42036021277, 141851.04045362 192056.98912736, 141852.39097125817 192056.15064807926, 141853.1417016185 192055.68455135095, 141854.7287057269 192054.69134007988, 141855.85472564306 192053.9866313356, 141857.53274162 192052.94279135, 141865.36978304185 192048.0676644248, 141866.81699864636 192047.1673787629, 141866.85261363 192047.1452233501, 141876.4258150617 192041.1901092554, 141878.53229363996 192039.87975133993, 141877.30829364 192037.69466334017, 141888.31859764 192031.49306334008, 141888.70970164993 192031.27277534, 141889.19904564018 192031.21248734, 141890.32781365007 192033.23578333991, 141894.3086136501 192030.99360734, 141895.30042165008 192030.43495134008, 141916.94675767008 192018.24237533, 141935.11955768114 192008.0063433195, 141938.46662968 192006.36679132, 141938.01632567964 192004.09312731825, 141936.13581368045 191997.07744731105, 141927.83194167062 191974.37331930175, 141924.4854072258 191964.27673489143, 141924.4828872273 191964.26913198843, 141918.4878776708 191946.182215282, 141897.54579764695 191892.38010323196, 141885.81229364063 191863.05811922147, 141883.7343416403 191858.32621522073, 141881.57933363982 191851.27149521885, 141880.02970324864 191844.153422599, 141875.3021755949 191822.43851153212, 141875.3254736129 191822.41380685786, 141873.66682164 191810.33043919006, 141873.53940063194 191810.47136385995, 141824.16934979084 191865.09056700877, 141807.49126958975 191883.54183124026, 141806.4220855899 191884.39994324007, 141804.12877357993 191884.68794324, 141802.18278958995 191884.19501524014, 141799.86170159004 191882.65427923997, 141797.43405357964 191879.70759122973, 141796.65850158 191879.23552723, 141795.60058157754 191879.14144723074, 141793.61126957982 191879.6576712401, 141791.29722157962 191881.41703124024, 141775.4967735719 191898.58631124764, 141762.63558956096 191912.02464724876, 141746.34477355 191931.99891927, 141739.71981353982 191941.33383128035, 141718.17261353089 191963.87104728923, 141707.3389495192 191974.1517513007, 141691.99571750825 191990.5641673119, 141682.7752375 191999.5446473201, 141680.5932215 192001.85389532015, 141677.57882149992 192009.98906332042, 141677.57882149992 192024.7241673399, 141687.3980854999 192032.38650334, 141710.5152695301 192048.24429535, 141718.70739026685 192054.5313297759, 141749.1093688275 192077.86358368513, 141751.58060556688 192074.77973901018, 141791.9401655799 192108.53645538993, 141790.96320244708 192109.984659987, 141792.9354935801 192111.49831139, 141793.03305738285 192111.57318755027)), ((141725.3270455372 192239.62016747976, 141736.44512554 192239.40602347982, 141737.61955949193 192234.94725314045, 141737.64666152475 192234.8443595378, 141738.78980980895 192230.5043660842, 141733.4156215401 192233.86067948, 141732.60768554022 192234.36525547988, 141731.69005354 192234.72723948, 141731.4883200514 192234.8068185435, 141731.04332745058 192234.79662609258, 141730.37651752948 192234.86816748008, 141727.74573353713 192234.7210954799, 141708.45472552654 192234.2792394801, 141680.76659750368 192234.0220874799, 141656.07290149166 192234.38522348, 141629.07206946905 192233.29850347992, 141618.5185334608 192231.88435948017, 141603.34752545008 192228.10989548, 141597.26342945182 192226.65671147034, 141592.5292214508 192225.30234347016, 141568.39482142948 192219.1109834698, 141554.3732534101 192214.54509547, 141547.59936119211 192212.33929130126, 141541.2639414099 192208.97210346008, 141529.2713654 192202.5982154602, 141527.42342940008 192207.54976746, 141526.95021872703 192208.8177373759, 141533.91939805186 192211.32418877794, 141538.93562139958 192213.12826346981, 141551.88486940946 192218.77101546992, 141563.40358942084 192223.00999147023, 141568.94726942235 192224.5636554708, 141588.22189343965 192230.68307947982, 141599.6508214521 192233.48128748054, 141604.2754954486 192234.52358471838, 141612.59616546106 192236.39866348018, 141625.66720547026 192238.6093514799, 141640.75814947 192239.92979947993, 141687.70182951 192239.60275947992, 141708.04813351537 192239.7866954799, 141719.13516967124 192239.67984257417, 141725.3270455372 192239.62016747976)))\nadded area: GEOMETRYCOLLECTION EMPTY\nremoved area: MULTIPOLYGON (((141751.58060556688 192074.77973901018, 141749.10938305568 192077.86356592987, 141790.96320994748 192109.98464886873, 141791.9401655799 192108.53645538993, 141751.58060556688 192074.77973901018)), ((141792.93549358012 192111.49831138997, 141790.75651614694 192115.20822342104, 141790.77155240465 192115.21730295772, 141793.03305738285 192111.57318755027, 141792.93549358012 192111.49831138997)), ((141801.6723999977 192199.32169999927, 141831.40260148828 192121.48229609613, 141801.83878959 192105.39373539, 141801.6800913187 192105.68115173615, 141801.00856517133 192106.8973812718, 141829.5001000017 192122.21880000085, 141800.9993999973 192196.8392000012, 141781.65139999986 192173.0887000002, 141767.06086249847 192165.24257983334, 141766.5877020916 192166.0737011368, 141779.3553000018 192173.02180000022, 141801.6723999977 192199.32169999927)), ((141742.88068583191 192200.15653360618, 141742.89109347828 192200.16145755255, 141746.75789507607 192192.81315251102, 141746.74550845352 192192.8061695695, 141744.20000000298 192197.03090000153, 141742.88068583191 192200.15653360618)), ((141541.3799938568 192209.03378372776, 141547.59936119211 192212.33929130126, 141554.2501284672 192214.5050019014, 141554.25409109317 192214.49442252837, 141541.38488562324 192209.02353278152, 141541.3799938568 192209.03378372776)), ((141750.71698525207 192194.8985433813, 141750.70753692367 192194.89330513956, 141741.73062030482 192209.46040323336, 141739.8909476443 192208.4111280707, 141738.98480000347 192211.15890000015, 141736.27549999952 192222.191300001, 141734.4122999981 192232.36960000172, 141734.01650000364 192233.2083999999, 141733.41561533514 192233.86068335516, 141738.78981405136 192230.50436343474, 141744.4672999978 192208.94959999993, 141747.24490000308 192201.90359999985, 141750.71698525207 192194.8985433813)), ((141731.6901736623 192234.72719209458, 141731.09726907214 192234.79083364972, 141731.09756480512 192234.79786838643, 141731.4883200514 192234.8068185435, 141731.6901736623 192234.72719209458)))"
  },
  {
    "objectID": "examples/example_networkgeometryprocessor.html",
    "href": "examples/example_networkgeometryprocessor.html",
    "title": "NetworkGeometryProcessor",
    "section": "",
    "text": "NetworkGeometryProcessor\nThis example shows an example how a processor (NetworkGeometryProcessor) can be added to the aligner. The aligner makes predictions based on the result from this processor. In this case NetworkGeometryProcessor is used. This is a slower processor as DieussaertProcessor, but can be used more generic for all kinds of geometrytypes: Polygon/LibeString/Point - to - Polygon/LibeString/Point.\n\n\nCode\nimport numpy as np\n\nfrom brdr.aligner import Aligner\nfrom brdr.be.grb.enums import GRBType\nfrom brdr.be.grb.loader import GRBActualLoader\nfrom brdr.configs import ProcessorConfig\nfrom brdr.enums import AlignerResultType\nfrom brdr.geometry_utils import geom_from_wkt\nfrom brdr.loader import DictLoader\nfrom brdr.processor import NetworkGeometryProcessor\nfrom brdr.viz import plot_difference_by_relevant_distance, show_map\n\nwkt = \"MULTIPOLYGON (((161124.34599999999045394 192109.59909999999217689, 161168.89799999998649582 192116.24609999998938292, 161193.2410000000090804 192119.87810000000172295, 161209.3779999999969732 192122.2851000000082422, 161301.39799999998649582 192136.21809999999823049, 161331.3720000000030268 192140.75609999999869615, 161333.79800000000977889 192162.08809999999357387, 161337.36100000000442378 192190.08609999998589046, 161340.79999999998835847 192217.1010999999998603, 161289.46599999998579733 192225.79409999999916181, 161292.97899999999208376 192242.98009999998612329, 161302.7559999999939464 192241.45209999999497086, 161310.06700000001001172 192277.30910000001313165, 161310.77600000001257285 192280.7890999999945052, 161307.41599999999743886 192281.32409999999799766, 161308.2559999999939464 192285.75409999999101274, 161291.07000000000698492 192289.80210000000079162, 161294.72800000000279397 192307.19709999999031425, 161286.91599999999743886 192307.39009999998961575, 161271.16300000000046566 192309.70809999998891726, 161271.12599999998928979 192310.10310000000754371, 161269.97500000000582077 192322.45410000000265427, 161267.09099999998579733 192353.4101000000082422, 161269.3219999999855645 192359.60910000000149012, 161250.23999999999068677 192360.83710000000428408, 161261.48999999999068677 192355.92110000000684522, 161263.70499999998719431 192321.40810000000055879, 161236.57800000000861473 192316.75109999999403954, 161206.75800000000162981 192311.63109999999869615, 161203.84299999999348074 192311.13109999999869615, 161177.42100000000209548 192306.5951000000059139, 161186.53400000001420267 192247.45209999999497086, 161139.78800000000046566 192240.76809999998658895, 161140.12100000001373701 192238.20809999998891726, 161124.34599999999045394 192109.59909999999217689)))\"\ndict_theme = {\"id_wkt\": geom_from_wkt(wkt)}\nconfig = ProcessorConfig()\n# config.od_strategy = OpenDomainStrategy.EXCLUDE\n# processor= DieussaertGeometryProcessor(config=config)\nprocessor = NetworkGeometryProcessor(config=config)\naligner = Aligner(crs=\"EPSG:31370\", processor=processor)\nloader = DictLoader(dict_theme)\naligner.load_thematic_data(loader)\nloader = GRBActualLoader(grb_type=GRBType.ADP, partition=1000, aligner=aligner)\naligner.load_reference_data(loader)\n\nseries = np.arange(0, 310, 10, dtype=int) / 100\n# predict which relevant distances are interesting to propose as resulting geometry\naligner_result = aligner.predict(\n    relevant_distances=series,\n)\n# aligner_result = aligner.process(relevant_distances=[0,1,2,3,4],)\n# aligner_result = aligner.process(relevant_distances=[1],)\ndict_predictions = aligner_result.get_results(\n    aligner=aligner, result_type=AlignerResultType.PREDICTIONS\n)\n\n# SHOW results of the predictions\nfcs = aligner_result.get_results_as_geojson(add_metadata=False, aligner=aligner)\ndiffs_dict = aligner.get_difference_metrics_for_thematic_data(\n    dict_processresults=aligner_result.results, thematic_data=aligner.thematic_data\n)\nreference_geometries = {\n    key: feat.geometry for key, feat in aligner.reference_data.features.items()\n}\nif fcs is None or \"result\" not in fcs:\n    print(\"empty predictions\")\nelse:\n    print(fcs[\"result\"])\n    for key in dict_predictions:\n        plot_difference_by_relevant_distance({key: diffs_dict[key]})\n        show_map(\n            {key: dict_predictions[key]},\n            {key: aligner.thematic_data.features[key].geometry},\n            reference_geometries,\n        )\n\n\n{\"crs\": {\"properties\": {\"name\": \"http://www.opengis.net/def/crs/EPSG/0/31370\"}, \"type\": \"name\"}, \"features\": [{\"geometry\": {\"coordinates\": [[[161124.346, 192109.5991], [161168.898, 192116.2461], [161193.241, 192119.8781], [161209.378, 192122.2851], [161301.398, 192136.2181], [161331.372, 192140.7561], [161333.798, 192162.0881], [161337.361, 192190.0861], [161340.8, 192217.1011], [161289.466, 192225.7941], [161292.979, 192242.9801], [161302.756, 192241.4521], [161310.067, 192277.3091], [161310.776, 192280.7891], [161307.416, 192281.3241], [161308.256, 192285.7541], [161291.07, 192289.8021], [161294.728, 192307.1971], [161286.916, 192307.3901], [161271.163, 192309.7081], [161271.126, 192310.1031], [161269.975, 192322.4541], [161267.091, 192353.4101], [161269.322, 192359.6091], [161250.24, 192360.8371], [161261.49, 192355.9211], [161263.705, 192321.4081], [161236.578, 192316.7511], [161206.758, 192311.6311], [161203.843, 192311.1311], [161177.421, 192306.5951], [161186.534, 192247.4521], [161139.788, 192240.7681], [161140.121, 192238.2081], [161124.346, 192109.5991]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31594.917091998537, \"brdr_diff_area_index\": 0, \"brdr_diff_area_index_perc\": 0, \"brdr_diff_length_index\": 0, \"brdr_diff_length_index_perc\": 0, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 916.2373493861767, \"brdr_relevant_distance\": 0.0, \"brdr_remark\": [\"resulting geometry equal to original geometry\"], \"brdr_shape_index\": 0.47294550420130754, \"brdr_stability\": false, \"brdr_sym_diff_area_index\": 0, \"brdr_sym_diff_area_index_perc\": 0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161291.272495, 192289.754404], [161301.411721, 192287.366205], [161301.39693, 192287.266953], [161301.998139, 192287.22808], [161302.599347, 192287.189208], [161302.584556, 192287.089955], [161307.113789, 192286.023137], [161307.212035, 192285.999996], [161307.31028, 192285.976855], [161308.256, 192285.7541], [161307.416, 192281.3241], [161310.776, 192280.7891], [161310.067001, 192277.309103], [161309.892862, 192276.455035], [161309.872859, 192276.356931], [161309.852856, 192276.258827], [161307.245981, 192263.473335], [161307.147347, 192263.490126], [161306.937943, 192261.962554], [161306.728539, 192260.434982], [161306.629906, 192260.451778], [161302.756, 192241.4521], [161292.979, 192242.9801], [161289.466, 192225.7941], [161290.633564, 192225.596382], [161290.732193, 192225.57968], [161290.830822, 192225.562978], [161340.8, 192217.1011], [161340.733186, 192216.576244], [161340.720558, 192216.477044], [161340.70793, 192216.377845], [161339.956827, 192210.477572], [161339.944199, 192210.378373], [161339.931571, 192210.279173], [161338.668396, 192200.356322], [161338.655765, 192200.257105], [161338.643135, 192200.157889], [161337.361, 192190.0861], [161333.798, 192162.0881], [161331.372, 192140.7561], [161301.398, 192136.2181], [161277.311535, 192132.571102], [161277.208817, 192132.55555], [161277.1061, 192132.539997], [161223.021408, 192124.350886], [161222.918688, 192124.335333], [161222.815969, 192124.31978], [161218.432279, 192123.656033], [161218.432877, 192123.554984], [161217.737118, 192123.651917], [161217.737718, 192123.550868], [161210.055371, 192122.387663], [161209.953073, 192122.372173], [161209.850773, 192122.356684], [161209.378, 192122.2851], [161193.241, 192119.8781], [161170.681382, 192116.512182], [161170.579184, 192116.496934], [161170.476986, 192116.481686], [161168.898, 192116.2461], [161125.090378, 192109.710158], [161124.988205, 192109.694915], [161124.886032, 192109.679671], [161124.346, 192109.5991], [161128.227887, 192141.246999], [161128.327241, 192141.235622], [161128.962324, 192147.23465], [161129.597407, 192153.233678], [161129.696766, 192153.22234], [161137.475726, 192216.641951], [161137.488502, 192216.746104], [161137.501277, 192216.850256], [161138.753814, 192227.061826], [161138.766588, 192227.165974], [161138.779363, 192227.270121], [161139.171823, 192230.469736], [161139.272539, 192230.469462], [161139.223329, 192230.889648], [161139.174119, 192231.309834], [161139.274834, 192231.309557], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161181.646147, 192279.174065], [161181.744755, 192279.190758], [161181.245843, 192281.897351], [161181.128167, 192282.535737], [161180.5116, 192285.880575], [161180.610211, 192285.89725], [161177.421, 192306.5951], [161178.586902, 192306.795256], [161178.685468, 192306.812178], [161178.784034, 192306.829099], [161203.842997, 192311.1311], [161206.757995, 192311.631099], [161208.312036, 192311.897923], [161208.410653, 192311.914855], [161208.50927, 192311.931788], [161236.578, 192316.7511], [161236.944912, 192316.814089], [161236.962198, 192316.715594], [161237.945747, 192316.891016], [161252.145407, 192319.423619], [161262.779411, 192321.320264], [161262.861877, 192321.263358], [161263.705, 192321.4081], [161261.49, 192355.9211], [161258.047981, 192357.425186], [161257.99081, 192357.341038], [161257.79432, 192357.53603], [161257.59783, 192357.731022], [161257.540658, 192357.646874], [161250.24, 192360.8371], [161254.334012, 192360.573635], [161254.365361, 192360.671824], [161254.546227, 192360.559978], [161254.727092, 192360.448132], [161254.758442, 192360.546321], [161267.437791, 192359.730356], [161267.450804, 192359.829726], [161268.196801, 192359.681511], [161268.709139, 192359.57972], [161268.942846, 192359.533293], [161268.955854, 192359.632663], [161269.322, 192359.6091], [161269.305488, 192359.56322], [161269.279059, 192359.466504], [161269.259818, 192359.436323], [161269.015768, 192359.053516], [161269.106084, 192359.009161], [161267.091, 192353.4101], [161269.975, 192322.4541], [161271.125999, 192310.103114], [161271.136128, 192309.994976], [161271.145581, 192309.894058], [161271.155034, 192309.79314], [161271.163, 192309.7081], [161286.916, 192307.3901], [161294.369907, 192307.205947], [161294.471207, 192307.203444], [161294.572507, 192307.200942], [161294.728, 192307.1971], [161293.174027, 192299.807444], [161293.075955, 192299.827014], [161292.161651, 192294.993262], [161291.247347, 192290.15951], [161291.149277, 192290.17909], [161291.07, 192289.8021], [161291.175062, 192289.777354], [161291.272495, 192289.754404]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31594.504535967557, \"brdr_diff_area_index\": 0.4, \"brdr_diff_area_index_perc\": 0.0, \"brdr_diff_length_index\": 2.2, \"brdr_diff_length_index_perc\": 0.2, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 918.4822861370965, \"brdr_relevant_distance\": 0.1, \"brdr_remark\": [], \"brdr_shape_index\": 0.4706302555487045, \"brdr_stability\": false, \"brdr_sym_diff_area_index\": 2.9, \"brdr_sym_diff_area_index_perc\": 0.0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161170.374787, 192116.466438], [161168.898, 192116.2461], [161125.192549, 192109.725402], [161124.988205, 192109.694915], [161124.78386, 192109.664427], [161124.346, 192109.5991], [161127.493445, 192135.259306], [161127.692158, 192135.236595], [161128.962324, 192147.23465], [161130.23249, 192159.232706], [161130.431206, 192159.210018], [161137.462951, 192216.537799], [161137.488502, 192216.746104], [161137.514052, 192216.954408], [161138.741039, 192226.957679], [161138.766588, 192227.165974], [161138.792138, 192227.37427], [161139.120318, 192230.049827], [161139.321749, 192230.049277], [161139.223329, 192230.889648], [161139.124909, 192231.730019], [161139.32634, 192231.72947], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161182.164128, 192275.81239], [161182.361349, 192275.845745], [161181.245843, 192281.897351], [161181.128167, 192282.535737], [161179.895034, 192289.225413], [161180.092255, 192289.258761], [161177.421, 192306.5951], [161178.488337, 192306.778335], [161178.685468, 192306.812178], [161178.882599, 192306.84602], [161203.842997, 192311.1311], [161206.757995, 192311.631099], [161208.213419, 192311.880991], [161208.410653, 192311.914855], [161208.607887, 192311.94872], [161221.687268, 192314.194408], [161221.721727, 192313.997398], [161226.529043, 192314.854792], [161230.632723, 192315.586696], [161237.945747, 192316.891016], [161252.145407, 192319.423619], [161262.779411, 192321.320264], [161262.975901, 192321.282933], [161263.705, 192321.4081], [161261.49, 192355.9211], [161258.301641, 192357.314342], [161258.1873, 192357.146045], [161257.79432, 192357.53603], [161257.401341, 192357.926015], [161257.286999, 192357.757718], [161250.24, 192360.8371], [161254.121796, 192360.587292], [161254.184495, 192360.78367], [161254.546227, 192360.559978], [161254.907958, 192360.336285], [161254.970658, 192360.532664], [161266.678788, 192359.779201], [161266.704807, 192359.97794], [161268.196801, 192359.681511], [161268.709139, 192359.57972], [161269.279059, 192359.466504], [161269.259818, 192359.436323], [161268.915923, 192358.896904], [161268.771729, 192358.670739], [161268.95236, 192358.582028], [161267.091, 192353.4101], [161269.975, 192322.4541], [161271.125999, 192310.103114], [161271.126675, 192310.095893], [161271.145581, 192309.894058], [161271.390932, 192309.876714], [161271.369293, 192309.677745], [161286.916, 192307.3901], [161294.268607, 192307.20845], [161294.471207, 192307.203444], [161294.673807, 192307.198439], [161294.728, 192307.1971], [161294.1864, 192304.62161], [161293.990259, 192304.660765], [161292.161651, 192294.993262], [161291.175062, 192289.777354], [161291.369927, 192289.731455], [161300.825308, 192287.504329], [161300.795722, 192287.305825], [161301.998139, 192287.22808], [161303.200556, 192287.150335], [161303.170972, 192286.95183], [161307.015544, 192286.046278], [161307.212035, 192285.999996], [161307.408525, 192285.953715], [161308.256, 192285.7541], [161307.416, 192281.3241], [161310.776, 192280.7891], [161310.067001, 192277.309103], [161309.912865, 192276.55314], [161309.872859, 192276.356931], [161309.832854, 192276.160723], [161307.554017, 192264.984104], [161307.356751, 192265.017698], [161306.937943, 192261.962554], [161306.519135, 192258.90741], [161306.321869, 192258.941003], [161302.756, 192241.4521], [161292.979, 192242.9801], [161289.466, 192225.7941], [161290.534935, 192225.613085], [161290.732193, 192225.57968], [161290.929452, 192225.546276], [161340.8, 192217.1011], [161340.745814, 192216.675443], [161340.720558, 192216.477044], [161340.695302, 192216.278646], [161339.969455, 192210.576772], [161339.944199, 192210.378373], [161339.918943, 192210.179974], [161338.681026, 192200.455539], [161338.655765, 192200.257105], [161338.630505, 192200.058672], [161337.361, 192190.0861], [161333.798, 192162.0881], [161331.372, 192140.7561], [161301.398, 192136.2181], [161277.414251, 192132.586655], [161277.208817, 192132.55555], [161277.003383, 192132.524444], [161223.124126, 192124.366439], [161222.918688, 192124.335333], [161222.71325, 192124.304227], [161218.779561, 192123.708616], [161218.780757, 192123.506518], [161218.084997, 192123.60345], [161217.389238, 192123.700383], [161217.390436, 192123.498285], [161210.15767, 192122.403152], [161209.953073, 192122.372173], [161209.748475, 192122.341195], [161209.378, 192122.2851], [161193.241, 192119.8781], [161170.783581, 192116.527431], [161170.579184, 192116.496934], [161170.374787, 192116.466438]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31591.534509369925, \"brdr_diff_area_index\": 3.4, \"brdr_diff_area_index_perc\": 0.0, \"brdr_diff_length_index\": 3.8, \"brdr_diff_length_index_perc\": 0.4, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 920.054523586666, \"brdr_relevant_distance\": 0.2, \"brdr_remark\": [], \"brdr_shape_index\": 0.4689790642165271, \"brdr_stability\": false, \"brdr_sym_diff_area_index\": 10.1, \"brdr_sym_diff_area_index_perc\": 0.0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161170.272589, 192116.45119], [161168.898, 192116.2461], [161125.294722, 192109.740646], [161124.988205, 192109.694915], [161124.681687, 192109.649183], [161124.346, 192109.5991], [161126.759002, 192129.271608], [161127.057075, 192129.237567], [161128.962324, 192147.23465], [161130.867573, 192165.231734], [161131.165647, 192165.197702], [161137.450176, 192216.433647], [161137.488502, 192216.746104], [161137.526827, 192217.05856], [161138.728264, 192226.85353], [161138.766588, 192227.165974], [161138.804912, 192227.478417], [161139.068812, 192229.629916], [161139.370959, 192229.629091], [161139.075699, 192232.150205], [161139.377846, 192232.149378], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161182.682114, 192272.450681], [161182.977943, 192272.500732], [161181.245843, 192281.897351], [161181.128167, 192282.535737], [161179.278467, 192292.57025], [161179.574295, 192292.620305], [161177.421, 192306.5951], [161178.389771, 192306.761414], [161178.685468, 192306.812178], [161178.981165, 192306.862941], [161203.842997, 192311.1311], [161206.318028, 192311.555633], [161206.369668, 192311.26011], [161208.449416, 192311.630213], [161217.777619, 192313.29396], [161226.529043, 192314.854792], [161230.632723, 192315.586696], [161237.945747, 192316.891016], [161252.145407, 192319.423619], [161262.779411, 192321.320264], [161263.078446, 192321.300537], [161263.705, 192321.4081], [161261.49, 192355.9211], [161258.555303, 192357.203498], [161258.38379, 192356.951053], [161257.79432, 192357.53603], [161257.204851, 192358.121007], [161257.033338, 192357.868562], [161250.24, 192360.8371], [161253.90958, 192360.600948], [161254.003629, 192360.895517], [161254.546227, 192360.559978], [161255.079379, 192360.23028], [161255.182874, 192360.519007], [161265.919777, 192359.828046], [161265.95881, 192360.126155], [161268.196801, 192359.681511], [161268.709139, 192359.57972], [161269.279059, 192359.466504], [161269.259818, 192359.436323], [161268.915923, 192358.896904], [161268.527697, 192358.287983], [161268.798644, 192358.154916], [161267.091, 192353.4101], [161269.975, 192322.4541], [161271.117266, 192310.196817], [161271.145581, 192309.894058], [161272.712921, 192309.783265], [161272.680458, 192309.484811], [161286.916, 192307.3901], [161294.167307, 192307.210952], [161294.471207, 192307.203444], [161292.161651, 192294.993262], [161291.175062, 192289.777354], [161291.46736, 192289.708506], [161300.23889, 192287.642455], [161300.194514, 192287.344697], [161301.998139, 192287.22808], [161303.284563, 192287.144904], [161303.801795, 192287.111455], [161303.757416, 192286.813699], [161306.917299, 192286.069418], [161307.212035, 192285.999996], [161307.50677, 192285.930574], [161308.256, 192285.7541], [161307.416, 192281.3241], [161309.575406, 192280.980266], [161309.53752, 192280.682519], [161309.766867, 192280.660616], [161309.903534, 192280.928019], [161310.776, 192280.7891], [161310.067001, 192277.309103], [161309.932868, 192276.651244], [161309.872859, 192276.356931], [161309.812851, 192276.062618], [161307.862053, 192266.494879], [161307.566155, 192266.54527], [161306.937943, 192261.962554], [161306.309731, 192257.379838], [161306.013832, 192257.430227], [161302.756, 192241.4521], [161292.979, 192242.9801], [161289.466, 192225.7941], [161290.436305, 192225.629787], [161290.732193, 192225.57968], [161291.028081, 192225.529574], [161340.8, 192217.1011], [161340.758442, 192216.774643], [161340.720558, 192216.477044], [161340.682674, 192216.179446], [161339.982083, 192210.675971], [161339.944199, 192210.378373], [161339.906315, 192210.080775], [161338.693656, 192200.554757], [161338.655765, 192200.257105], [161338.617875, 192199.959455], [161337.361, 192190.0861], [161333.798, 192162.0881], [161331.372, 192140.7561], [161301.398, 192136.2181], [161277.516968, 192132.602208], [161277.208817, 192132.55555], [161276.900667, 192132.508892], [161223.226845, 192124.381992], [161222.918688, 192124.335333], [161222.610531, 192124.288674], [161219.12684, 192123.761199], [161219.128637, 192123.458051], [161218.084997, 192123.60345], [161217.041358, 192123.748849], [161217.043153, 192123.445702], [161210.259969, 192122.418641], [161209.953073, 192122.372173], [161209.646176, 192122.325705], [161209.378, 192122.2851], [161193.241, 192119.8781], [161170.885778, 192116.542679], [161170.579184, 192116.496934], [161170.272589, 192116.45119]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31587.371194756066, \"brdr_diff_area_index\": 7.5, \"brdr_diff_area_index_perc\": 0.0, \"brdr_diff_length_index\": 5.8, \"brdr_diff_length_index_perc\": 0.6, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 922.0490711014104, \"brdr_relevant_distance\": 0.3, \"brdr_remark\": [], \"brdr_shape_index\": 0.46689075955598797, \"brdr_stability\": false, \"brdr_sym_diff_area_index\": 21.8, \"brdr_sym_diff_area_index_perc\": 0.1}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161268.915923, 192358.896904], [161268.283665, 192357.905226], [161268.644926, 192357.727799], [161267.091, 192353.4101], [161269.975, 192322.4541], [161271.107862, 192310.29773], [161271.145581, 192309.894058], [161274.034909, 192309.689816], [161273.991636, 192309.291876], [161286.916, 192307.3901], [161294.066008, 192307.213455], [161294.471207, 192307.203444], [161292.161651, 192294.993262], [161291.175062, 192289.777354], [161291.564792, 192289.685556], [161299.652472, 192287.78058], [161299.593305, 192287.38357], [161301.998139, 192287.22808], [161303.284563, 192287.144904], [161304.40304, 192287.072575], [161304.34387, 192286.675565], [161306.819054, 192286.092559], [161307.212035, 192285.999996], [161307.605014, 192285.907434], [161308.256, 192285.7541], [161307.416, 192281.3241], [161307.998919, 192281.231284], [161307.948414, 192280.834287], [161309.766867, 192280.660616], [161310.087634, 192280.898706], [161310.776, 192280.7891], [161310.067001, 192277.309104], [161309.95287, 192276.749347], [161309.872859, 192276.356931], [161309.792848, 192275.964514], [161308.17009, 192268.005653], [161307.775559, 192268.072842], [161306.937943, 192261.962554], [161306.100326, 192255.852267], [161305.705795, 192255.919451], [161302.756, 192241.4521], [161292.979, 192242.9801], [161292.725648, 192241.740671], [161292.999443, 192241.450311], [161292.825088, 192240.229835], [161292.4308, 192240.298241], [161289.466, 192225.7941], [161290.337676, 192225.646489], [161290.732193, 192225.57968], [161291.12671, 192225.512872], [161340.8, 192217.1011], [161340.77107, 192216.873842], [161340.720558, 192216.477044], [161340.670046, 192216.080246], [161339.994711, 192210.77517], [161339.944199, 192210.378373], [161339.893687, 192209.981575], [161338.706287, 192200.653974], [161338.655765, 192200.257105], [161338.605244, 192199.860237], [161337.361, 192190.0861], [161333.798, 192162.0881], [161331.372, 192140.7561], [161301.398, 192136.2181], [161277.619685, 192132.61776], [161277.208817, 192132.55555], [161276.79795, 192132.493339], [161223.329564, 192124.397545], [161222.918688, 192124.335333], [161222.507812, 192124.273121], [161219.474123, 192123.813782], [161219.476516, 192123.409585], [161218.084997, 192123.60345], [161216.693478, 192123.797316], [161216.695872, 192123.393119], [161210.362268, 192122.434131], [161209.953073, 192122.372173], [161209.543877, 192122.310216], [161209.378, 192122.2851], [161193.241, 192119.8781], [161170.987977, 192116.557927], [161170.579184, 192116.496934], [161170.170391, 192116.435942], [161168.898, 192116.2461], [161125.396895, 192109.75589], [161124.988205, 192109.694915], [161124.579514, 192109.633939], [161124.346, 192109.5991], [161126.024561, 192123.283925], [161126.421992, 192123.238539], [161128.962324, 192147.23465], [161131.502656, 192171.230761], [161131.90008, 192171.185327], [161137.437401, 192216.329495], [161137.488502, 192216.746104], [161137.539602, 192217.162712], [161138.71549, 192226.749383], [161138.766588, 192227.165974], [161138.817687, 192227.582565], [161139.017307, 192229.210009], [161139.420169, 192229.208906], [161139.223329, 192230.889648], [161139.026489, 192232.57039], [161139.429352, 192232.569291], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161183.200095, 192269.089006], [161183.594536, 192269.155719], [161181.245843, 192281.897352], [161181.128167, 192282.535737], [161178.6619, 192295.915088], [161179.056338, 192295.981823], [161177.421, 192306.5951], [161178.291206, 192306.744493], [161178.685468, 192306.812178], [161179.079731, 192306.879863], [161190.20559, 192308.789896], [161190.274479, 192308.395871], [161208.449416, 192311.630213], [161217.777619, 192313.29396], [161226.529043, 192314.854792], [161230.632723, 192315.586696], [161237.945747, 192316.891016], [161252.145407, 192319.423619], [161262.779411, 192321.320264], [161263.179857, 192321.317947], [161263.705, 192321.4081], [161261.49, 192355.9211], [161258.808964, 192357.092653], [161258.58028, 192356.756061], [161257.008361, 192358.315999], [161256.779677, 192357.979406], [161250.24, 192360.8371], [161253.697365, 192360.614605], [161253.822764, 192361.007363], [161254.546227, 192360.559978], [161255.079379, 192360.23028], [161255.368322, 192360.507073], [161265.160767, 192359.876891], [161265.212813, 192360.274369], [161268.196801, 192359.681511], [161268.709139, 192359.57972], [161269.279059, 192359.466504], [161269.259818, 192359.436323], [161268.915923, 192358.896904]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31582.170140565217, \"brdr_diff_area_index\": 12.7, \"brdr_diff_area_index_perc\": 0.0, \"brdr_diff_length_index\": 8.2, \"brdr_diff_length_index_perc\": 0.9, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 924.439018840476, \"brdr_relevant_distance\": 0.4, \"brdr_remark\": [], \"brdr_shape_index\": 0.4644032998363184, \"brdr_stability\": false, \"brdr_sym_diff_area_index\": 38.4, \"brdr_sym_diff_area_index_perc\": 0.1}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161170.068193, 192116.420694], [161168.898, 192116.2461], [161125.499067, 192109.771134], [161124.988205, 192109.694915], [161124.477342, 192109.618696], [161124.346, 192109.5991], [161125.290122, 192117.296252], [161125.786909, 192117.239511], [161128.962324, 192147.23465], [161132.137738, 192177.229789], [161132.634521, 192177.173005], [161137.424626, 192216.225343], [161137.488502, 192216.746104], [161137.552377, 192217.266864], [161138.702715, 192226.645235], [161138.766588, 192227.165974], [161138.830461, 192227.686713], [161138.965801, 192228.790095], [161139.469379, 192228.78872], [161139.223329, 192230.889648], [161138.977279, 192232.990576], [161139.480857, 192232.9892], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161183.718081, 192265.727297], [161184.21113, 192265.810707], [161181.245843, 192281.897351], [161181.128167, 192282.535737], [161178.045334, 192299.259926], [161178.538382, 192299.343334], [161177.421, 192306.5951], [161178.19264, 192306.727571], [161178.685468, 192306.812178], [161178.770899, 192306.348744], [161180.718995, 192306.695367], [161182.994707, 192307.10036], [161184.679443, 192307.4002], [161208.449416, 192311.630213], [161217.777619, 192313.29396], [161226.529043, 192314.854792], [161230.632723, 192315.586696], [161237.945747, 192316.891016], [161252.145407, 192319.423619], [161262.779411, 192321.320264], [161263.278739, 192321.334922], [161263.705, 192321.4081], [161261.49, 192355.9211], [161259.062624, 192356.981809], [161258.77677, 192356.561068], [161257.79432, 192357.53603], [161256.811871, 192358.510992], [161256.526015, 192358.090251], [161250.24, 192360.8371], [161253.485149, 192360.628262], [161253.641898, 192361.119209], [161254.546227, 192360.559978], [161255.079379, 192360.23028], [161255.520131, 192360.497303], [161264.401763, 192359.925736], [161264.466816, 192360.422584], [161268.196801, 192359.681511], [161268.709139, 192359.57972], [161269.279059, 192359.466504], [161269.259818, 192359.436323], [161268.915923, 192358.896904], [161268.039633, 192357.52247], [161268.49121, 192357.300689], [161267.091, 192353.4101], [161269.975, 192322.4541], [161271.098458, 192310.398642], [161271.145581, 192309.894058], [161275.356898, 192309.596366], [161275.3028, 192309.098943], [161286.916, 192307.3901], [161293.964708, 192307.215958], [161294.471207, 192307.203444], [161292.161651, 192294.993262], [161291.175062, 192289.777354], [161291.662223, 192289.662607], [161299.066054, 192287.918705], [161298.992097, 192287.422442], [161301.998139, 192287.22808], [161303.284563, 192287.144904], [161305.004284, 192287.033694], [161304.930319, 192286.537433], [161306.720809, 192286.1157], [161307.212035, 192285.999996], [161307.70326, 192285.884293], [161308.256, 192285.7541], [161307.427791, 192281.386284], [161306.834388, 192280.940682], [161309.766867, 192280.660616], [161310.216552, 192280.878179], [161310.776, 192280.7891], [161310.067001, 192277.309103], [161309.972873, 192276.847452], [161309.872859, 192276.356931], [161309.772845, 192275.86641], [161308.478128, 192269.516433], [161307.984964, 192269.600413], [161305.890922, 192254.324695], [161305.397761, 192254.40869], [161302.756, 192241.4521], [161292.979, 192242.9801], [161292.75527, 192241.885589], [161292.999443, 192241.450311], [161292.588197, 192238.571608], [161292.095335, 192238.657109], [161289.466, 192225.7941], [161290.239047, 192225.663191], [161290.732193, 192225.57968], [161291.22534, 192225.49617], [161340.8, 192217.1011], [161340.783698, 192216.973042], [161340.720558, 192216.477044], [161340.657418, 192215.981047], [161340.00734, 192210.874371], [161339.944199, 192210.378373], [161339.881059, 192209.882375], [161338.718917, 192200.753191], [161338.655765, 192200.257105], [161338.592614, 192199.76102], [161337.361, 192190.0861], [161333.798, 192162.0881], [161331.372, 192140.7561], [161301.398, 192136.2181], [161277.722402, 192132.633313], [161277.208817, 192132.55555], [161276.695233, 192132.477786], [161223.432283, 192124.413097], [161222.918688, 192124.335333], [161222.405094, 192124.257568], [161219.821406, 192123.866365], [161219.824396, 192123.361118], [161218.084997, 192123.60345], [161216.345599, 192123.845782], [161216.348592, 192123.340536], [161210.464567, 192122.44962], [161209.953073, 192122.372173], [161209.441578, 192122.294727], [161209.378, 192122.2851], [161193.241, 192119.8781], [161171.090175, 192116.573175], [161170.579184, 192116.496934], [161170.068193, 192116.420694]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31578.271183765486, \"brdr_diff_area_index\": 16.6, \"brdr_diff_area_index_perc\": 0.1, \"brdr_diff_length_index\": 10.9, \"brdr_diff_length_index_perc\": 1.2, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 927.1086668389571, \"brdr_relevant_distance\": 0.5, \"brdr_remark\": [], \"brdr_shape_index\": 0.4616756103831053, \"brdr_stability\": false, \"brdr_sym_diff_area_index\": 57.3, \"brdr_sym_diff_area_index_perc\": 0.2}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161268.915923, 192358.896904], [161267.795601, 192357.139713], [161268.337493, 192356.873575], [161267.091, 192353.4101], [161269.975, 192322.4541], [161271.089054, 192310.499556], [161271.145581, 192309.894058], [161276.678886, 192309.502917], [161276.613964, 192308.906009], [161286.916, 192307.3901], [161293.863408, 192307.21846], [161294.471207, 192307.203444], [161292.161651, 192294.993262], [161291.175062, 192289.777354], [161291.759656, 192289.639658], [161298.479642, 192288.056829], [161298.390888, 192287.461315], [161301.998139, 192287.22808], [161303.284563, 192287.144904], [161305.605528, 192286.994813], [161305.516774, 192286.399299], [161306.622564, 192286.13884], [161307.212035, 192285.999996], [161307.801506, 192285.861152], [161308.256, 192285.7541], [161307.4465, 192281.484953], [161306.734417, 192280.95023], [161309.766867, 192280.660616], [161310.332366, 192280.859738], [161310.776, 192280.7891], [161310.067001, 192277.309104], [161309.992876, 192276.945556], [161309.872859, 192276.356931], [161309.752843, 192275.768306], [161308.786163, 192271.027197], [161308.194368, 192271.127985], [161306.937943, 192261.962554], [161305.681518, 192252.797123], [161305.089724, 192252.897914], [161302.756, 192241.4521], [161292.979, 192242.9801], [161292.780193, 192242.007515], [161292.999443, 192241.450311], [161292.351305, 192236.913382], [161291.75987, 192237.015977], [161289.466, 192225.7941], [161290.140418, 192225.679893], [161290.732193, 192225.57968], [161291.323969, 192225.479468], [161340.8, 192217.1011], [161340.796326, 192217.072241], [161340.720558, 192216.477044], [161340.64479, 192215.881847], [161340.511113, 192214.831755], [161341.105794, 192214.75193], [161340.927315, 192213.486727], [161340.509523, 192210.525319], [161340.479123, 192210.309895], [161339.931539, 192205.792583], [161339.258185, 192200.238075], [161339.249534, 192200.170115], [161338.655765, 192200.257105], [161338.579984, 192199.661803], [161337.361, 192190.0861], [161333.798, 192162.0881], [161332.458494, 192150.309721], [161333.054307, 192150.238896], [161331.960019, 192141.419911], [161331.808384, 192140.21533], [161331.269774, 192140.740623], [161301.398, 192136.2181], [161277.825119, 192132.648866], [161277.208817, 192132.55555], [161276.592516, 192132.462234], [161223.535002, 192124.42865], [161222.918688, 192124.335333], [161222.302375, 192124.242015], [161220.168685, 192123.918947], [161220.172276, 192123.312652], [161218.084997, 192123.60345], [161215.997719, 192123.894249], [161216.001309, 192123.287953], [161210.566866, 192122.465109], [161209.953077, 192122.372174], [161209.339289, 192122.279326], [161193.241, 192119.8781], [161171.192373, 192116.588423], [161170.579184, 192116.496934], [161169.965995, 192116.405446], [161168.898, 192116.2461], [161125.60124, 192109.786377], [161124.988205, 192109.694915], [161124.375169, 192109.603452], [161124.346, 192109.5991], [161124.555682, 192111.30858], [161125.151825, 192111.240472], [161125.180307, 192111.509511], [161128.962324, 192147.23465], [161132.772821, 192183.228817], [161133.368962, 192183.160689], [161137.411851, 192216.121191], [161137.488502, 192216.746104], [161137.565153, 192217.371017], [161138.689941, 192226.541087], [161138.766588, 192227.165974], [161138.843236, 192227.790861], [161138.914295, 192228.370185], [161139.518589, 192228.368535], [161139.223329, 192230.889648], [161138.928068, 192233.410761], [161139.532362, 192233.409109], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161184.236068, 192262.365588], [161184.827724, 192262.465694], [161181.245843, 192281.897352], [161181.128167, 192282.535737], [161177.428767, 192302.604764], [161178.020427, 192302.704845], [161177.421, 192306.5951], [161178.094074, 192306.71065], [161178.685468, 192306.812178], [161178.770899, 192306.348744], [161180.718995, 192306.695368], [161182.994707, 192307.10036], [161184.679443, 192307.4002], [161208.449416, 192311.630213], [161217.777619, 192313.29396], [161226.529043, 192314.854792], [161230.632723, 192315.586696], [161237.945747, 192316.891016], [161252.145407, 192319.423619], [161262.779411, 192321.320264], [161263.378684, 192321.35208], [161263.705, 192321.4081], [161261.49, 192355.9211], [161259.316285, 192356.870965], [161258.973259, 192356.366076], [161257.79432, 192357.53603], [161256.615381, 192358.705984], [161256.272354, 192358.201095], [161250.24, 192360.8371], [161253.272933, 192360.641919], [161253.526867, 192361.190344], [161254.546227, 192360.559978], [161255.079379, 192360.23028], [161255.408954, 192359.903217], [161255.671941, 192360.487534], [161263.642752, 192359.974581], [161263.720818, 192360.570799], [161268.196801, 192359.681511], [161268.709139, 192359.57972], [161269.279059, 192359.466504], [161269.259818, 192359.436323], [161268.915923, 192358.896904]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31593.796440039187, \"brdr_diff_area_index\": 1.1, \"brdr_diff_area_index_perc\": 0.0, \"brdr_diff_length_index\": 16.2, \"brdr_diff_length_index_perc\": 1.8, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 932.4146362551451, \"brdr_relevant_distance\": 0.6, \"brdr_remark\": [], \"brdr_shape_index\": 0.45666057113707986, \"brdr_stability\": false, \"brdr_sym_diff_area_index\": 87.7, \"brdr_sym_diff_area_index_perc\": 0.3}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161138.86279, 192227.950276], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161177.421, 192306.5951], [161203.842972, 192311.131095], [161206.75746, 192311.631007], [161206.757997, 192311.631099], [161236.577996, 192316.751099], [161263.705, 192321.4081], [161261.49, 192355.9211], [161250.24, 192360.8371], [161269.322, 192359.6091], [161267.091, 192353.4101], [161269.975, 192322.454104], [161271.125999, 192310.103109], [161271.163, 192309.7081], [161286.916, 192307.3901], [161294.728, 192307.1971], [161291.07, 192289.8021], [161308.256, 192285.7541], [161307.416, 192281.3241], [161310.776, 192280.7891], [161310.067006, 192277.309129], [161302.756, 192241.4521], [161292.979, 192242.9801], [161289.466, 192225.7941], [161340.8, 192217.1011], [161337.361001, 192190.086107], [161333.798, 192162.0881], [161331.372, 192140.7561], [161301.398004, 192136.218101], [161209.378, 192122.2851], [161193.241007, 192119.878101], [161168.898, 192116.2461], [161124.346, 192109.5991], [161138.856011, 192227.895009], [161138.86279, 192227.950276]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31594.91709190924, \"brdr_diff_area_index\": 0, \"brdr_diff_area_index_perc\": 0, \"brdr_diff_length_index\": 0, \"brdr_diff_length_index_perc\": 0, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 916.2373493885609, \"brdr_relevant_distance\": 0.7, \"brdr_remark\": [], \"brdr_shape_index\": 0.4729455041975094, \"brdr_stability\": false, \"brdr_sym_diff_area_index\": 0, \"brdr_sym_diff_area_index_perc\": 0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161268.915923, 192358.896904], [161267.307537, 192356.3742], [161268.030061, 192356.01935], [161267.139634, 192353.545232], [161266.330348, 192353.659007], [161266.492549, 192351.209549], [161267.290092, 192351.273103], [161269.975, 192322.4541], [161271.070246, 192310.701382], [161271.145581, 192309.894058], [161279.322863, 192309.316019], [161279.236307, 192308.520141], [161286.916, 192307.3901], [161293.660808, 192307.223466], [161294.471207, 192307.203444], [161292.161651, 192294.993262], [161291.175062, 192289.777354], [161291.954521, 192289.59376], [161297.306809, 192288.333079], [161297.188471, 192287.53906], [161301.998139, 192287.22808], [161303.284563, 192287.144904], [161306.552336, 192286.933585], [161306.551898, 192286.920042], [161303.305932, 192286.920042], [161306.562098, 192286.153083], [161307.203543, 192286.001996], [161307.997996, 192285.81487], [161308.256, 192285.7541], [161307.724565, 192282.951412], [161306.931696, 192283.064196], [161306.729875, 192280.950664], [161309.766867, 192280.660616], [161310.550859, 192280.824948], [161310.776, 192280.7891], [161310.067001, 192277.309104], [161310.032882, 192277.141765], [161309.872859, 192276.356931], [161309.712837, 192275.572098], [161309.402238, 192274.048756], [161308.613176, 192274.183129], [161306.937943, 192261.962554], [161305.26271, 192249.741979], [161304.47365, 192249.876362], [161302.756, 192241.4521], [161292.979, 192242.9801], [161292.825914, 192242.231184], [161292.999443, 192241.450311], [161291.877523, 192233.596928], [161291.088944, 192233.733728], [161289.466, 192225.7941], [161289.943159, 192225.713297], [161290.732193, 192225.57968], [161291.521227, 192225.446064], [161336.644204, 192217.804851], [161336.526627, 192217.013372], [161340.720558, 192216.477044], [161341.250879, 192216.409226], [161341.338003, 192216.398023], [161340.927315, 192213.486727], [161340.509523, 192210.525319], [161340.479123, 192210.309895], [161339.931539, 192205.792583], [161339.249939, 192200.170055], [161339.080851, 192198.807303], [161338.808659, 192196.613895], [161338.597523, 192194.912199], [161337.842515, 192188.827655], [161337.633491, 192187.142983], [161337.265107, 192184.174279], [161336.984339, 192181.911687], [161334.510163, 192161.972103], [161334.275348, 192160.079627], [161334.244243, 192159.829194], [161333.273363, 192152.004295], [161331.960019, 192141.419911], [161331.782426, 192140.009121], [161331.064279, 192140.709512], [161301.398, 192136.2181], [161278.030553, 192132.679971], [161277.208817, 192132.55555], [161276.387082, 192132.431128], [161223.74044, 192124.459756], [161222.918688, 192124.335333], [161222.096937, 192124.210909], [161220.863249, 192124.024113], [161220.868035, 192123.215719], [161218.084997, 192123.60345], [161215.301959, 192123.991181], [161215.306747, 192123.182788], [161210.771464, 192122.496088], [161209.953092, 192122.372176], [161209.134743, 192122.248816], [161193.241, 192119.8781], [161171.39677, 192116.618919], [161170.579184, 192116.496934], [161169.761598, 192116.37495], [161168.898, 192116.2461], [161125.805585, 192109.816865], [161124.988205, 192109.694915], [161125.180307, 192111.509511], [161128.962324, 192147.23465], [161134.042987, 192195.226873], [161134.837843, 192195.136051], [161137.3863, 192215.912886], [161137.488502, 192216.746104], [161137.590703, 192217.579321], [161138.664391, 192226.332792], [161138.766588, 192227.165974], [161139.59159, 192227.320924], [161139.61701, 192227.528164], [161139.223329, 192230.889648], [161138.829648, 192234.251132], [161139.635374, 192234.24893], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161185.272035, 192255.642204], [161186.060911, 192255.775668], [161181.245843, 192281.897352], [161181.128167, 192282.535737], [161176.570503, 192307.260794], [161177.504062, 192306.60936], [161177.896943, 192306.676808], [161178.685468, 192306.812178], [161178.770899, 192306.348744], [161180.718995, 192306.695368], [161182.994707, 192307.10036], [161184.679443, 192307.4002], [161208.449416, 192311.630213], [161217.777619, 192313.29396], [161226.529043, 192314.854792], [161230.632723, 192315.586696], [161237.945747, 192316.891016], [161252.145407, 192319.423619], [161262.779411, 192321.320264], [161263.576735, 192321.38608], [161263.705, 192321.4081], [161261.49, 192355.9211], [161259.823607, 192356.649277], [161259.366239, 192355.976091], [161257.79432, 192357.53603], [161256.222401, 192359.095969], [161255.765032, 192358.422784], [161250.24, 192360.8371], [161252.848466, 192360.669235], [161253.099243, 192361.454752], [161253.526865, 192361.190345], [161254.546227, 192360.559978], [161255.079379, 192360.23028], [161255.624911, 192359.688905], [161255.975562, 192360.467995], [161262.124739, 192360.072271], [161262.228824, 192360.867228], [161268.196801, 192359.681511], [161268.709139, 192359.57972], [161269.279059, 192359.466504], [161269.259818, 192359.436323], [161268.915923, 192358.896904]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31630.77374963042, \"brdr_diff_area_index\": 35.9, \"brdr_diff_area_index_perc\": 0.1, \"brdr_diff_length_index\": 26.8, \"brdr_diff_length_index_perc\": 2.9, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 943.0543781037443, \"brdr_relevant_distance\": 0.8, \"brdr_remark\": [], \"brdr_shape_index\": 0.4469368960568271, \"brdr_stability\": false, \"brdr_sym_diff_area_index\": 159.7, \"brdr_sym_diff_area_index_perc\": 0.5}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161186.534, 192247.4521], [161177.421, 192306.5951], [161203.842965, 192311.131094], [161206.75796, 192311.631093], [161236.517641, 192316.740736], [161236.577995, 192316.751099], [161263.705, 192321.4081], [161261.49, 192355.9211], [161250.24, 192360.8371], [161269.322, 192359.6091], [161267.091, 192353.4101], [161269.974999, 192322.454106], [161271.12599, 192310.103209], [161271.163, 192309.7081], [161286.916, 192307.3901], [161294.728, 192307.1971], [161291.07, 192289.8021], [161308.256, 192285.7541], [161307.416, 192281.3241], [161310.776, 192280.7891], [161310.067007, 192277.309136], [161302.756, 192241.4521], [161292.979, 192242.9801], [161289.466, 192225.7941], [161340.8, 192217.1011], [161337.361001, 192190.086109], [161333.798, 192162.0881], [161331.372, 192140.7561], [161301.398002, 192136.2181], [161209.378, 192122.2851], [161193.241008, 192119.878101], [161168.898, 192116.2461], [161124.346, 192109.5991], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31594.917092011834, \"brdr_diff_area_index\": 0, \"brdr_diff_area_index_perc\": 0, \"brdr_diff_length_index\": 0, \"brdr_diff_length_index_perc\": 0, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 916.2373493856483, \"brdr_prediction_count\": 2, \"brdr_prediction_score\": 2.5, \"brdr_relevant_distance\": 0.9, \"brdr_remark\": [], \"brdr_shape_index\": 0.47294550420205206, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 0, \"brdr_sym_diff_area_index_perc\": 0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161308.129294, 192285.085879], [161307.416, 192281.3241], [161310.776, 192280.7891], [161310.067008, 192277.30914], [161302.756, 192241.4521], [161292.979, 192242.9801], [161289.466, 192225.7941], [161340.8, 192217.1011], [161337.361001, 192190.08611], [161333.798, 192162.0881], [161331.372, 192140.7561], [161301.398004, 192136.218101], [161209.378, 192122.2851], [161193.24101, 192119.878102], [161168.898, 192116.2461], [161124.346, 192109.5991], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161177.421, 192306.5951], [161203.842962, 192311.131093], [161206.757956, 192311.631093], [161236.560844, 192316.748154], [161236.577994, 192316.751099], [161263.705, 192321.4081], [161261.49, 192355.9211], [161250.24, 192360.8371], [161269.322, 192359.6091], [161267.091, 192353.4101], [161269.974999, 192322.454107], [161271.125989, 192310.103218], [161271.125999, 192310.10311], [161271.163, 192309.7081], [161286.916, 192307.3901], [161294.728, 192307.1971], [161291.07, 192289.8021], [161307.212035, 192285.999996], [161308.194486, 192285.768589], [161308.256, 192285.7541], [161308.129294, 192285.085879]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31594.917092002368, \"brdr_diff_area_index\": 0, \"brdr_diff_area_index_perc\": 0, \"brdr_diff_length_index\": 0, \"brdr_diff_length_index_perc\": 0, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 916.2373493865019, \"brdr_relevant_distance\": 1.0, \"brdr_remark\": [], \"brdr_shape_index\": 0.47294550420102904, \"brdr_stability\": false, \"brdr_sym_diff_area_index\": 0, \"brdr_sym_diff_area_index_perc\": 0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161255.004051, 192358.755316], [161250.24, 192360.8371], [161252.21182, 192360.710206], [161252.556697, 192361.790287], [161253.05032, 192361.485002], [161253.526865, 192361.190345], [161254.546227, 192360.559978], [161255.079379, 192360.23028], [161255.094415, 192360.5247], [161269.322, 192359.6091], [161267.091, 192353.4101], [161269.974999, 192322.454107], [161271.077473, 192310.62383], [161271.125988, 192310.10323], [161271.125999, 192310.10311], [161271.163, 192309.7081], [161286.916, 192307.3901], [161294.728, 192307.1971], [161291.07, 192289.8021], [161308.256, 192285.7541], [161307.416, 192281.3241], [161310.776, 192280.7891], [161310.067009, 192277.309144], [161302.756, 192241.4521], [161292.979, 192242.9801], [161289.466, 192225.7941], [161340.8, 192217.1011], [161337.361001, 192190.086111], [161333.798, 192162.0881], [161331.372, 192140.7561], [161301.398004, 192136.218101], [161209.378, 192122.2851], [161193.241011, 192119.878102], [161168.898, 192116.2461], [161124.346, 192109.5991], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161177.421, 192306.5951], [161203.842958, 192311.131093], [161206.756578, 192311.630856], [161206.757952, 192311.631092], [161236.577994, 192316.751099], [161263.705, 192321.4081], [161261.49, 192355.9211], [161255.004051, 192358.755316], [161255.004051, 192358.755316]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31596.122692815905, \"brdr_diff_area_index\": 1.2, \"brdr_diff_area_index_perc\": 0.0, \"brdr_diff_length_index\": 1.5, \"brdr_diff_length_index_perc\": 0.2, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 917.7434679668697, \"brdr_relevant_distance\": 1.1, \"brdr_remark\": [], \"brdr_shape_index\": 0.4714124536493581, \"brdr_stability\": false, \"brdr_sym_diff_area_index\": 1.4, \"brdr_sym_diff_area_index_perc\": 0.0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161203.842956, 192311.131092], [161206.756319, 192311.630812], [161206.757997, 192311.631099], [161236.539559, 192316.7445], [161236.577993, 192316.751099], [161263.705, 192321.4081], [161261.49, 192355.9211], [161254.761319, 192358.861384], [161250.24, 192360.8371], [161251.999623, 192360.723861], [161252.375853, 192361.902132], [161253.05032, 192361.485002], [161253.526865, 192361.190345], [161254.546227, 192360.559978], [161255.079379, 192360.23028], [161255.14953, 192360.521153], [161269.322, 192359.6091], [161267.091, 192353.4101], [161269.974999, 192322.454107], [161271.073653, 192310.664817], [161271.107429, 192310.30238], [161271.125999, 192310.103109], [161271.163, 192309.7081], [161286.916, 192307.3901], [161294.728, 192307.1971], [161291.07, 192289.8021], [161308.256, 192285.7541], [161307.416, 192281.3241], [161310.776, 192280.7891], [161310.226246, 192278.090733], [161310.06701, 192277.309147], [161302.756, 192241.4521], [161292.979, 192242.9801], [161289.466, 192225.7941], [161340.8, 192217.1011], [161337.361, 192190.0861], [161333.798, 192162.0881], [161331.372, 192140.7561], [161301.398005, 192136.218101], [161209.378, 192122.2851], [161193.241012, 192119.878102], [161168.898, 192116.2461], [161124.346, 192109.5991], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161177.421, 192306.5951], [161203.842956, 192311.131092]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31596.359083565334, \"brdr_diff_area_index\": 1.4, \"brdr_diff_area_index_perc\": 0.0, \"brdr_diff_length_index\": 1.6, \"brdr_diff_length_index_perc\": 0.2, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 917.7957210663335, \"brdr_relevant_distance\": 1.2, \"brdr_remark\": [], \"brdr_shape_index\": 0.47136230362053877, \"brdr_stability\": false, \"brdr_sym_diff_area_index\": 1.6, \"brdr_sym_diff_area_index_perc\": 0.0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161290.939885, 192307.290688], [161294.728, 192307.1971], [161291.07, 192289.8021], [161308.256, 192285.7541], [161307.416, 192281.3241], [161310.776, 192280.7891], [161310.06701, 192277.309151], [161302.756, 192241.4521], [161292.979, 192242.9801], [161289.466, 192225.7941], [161340.8, 192217.1011], [161337.361002, 192190.086112], [161333.798, 192162.0881], [161331.372, 192140.7561], [161301.398005, 192136.218101], [161209.378, 192122.2851], [161193.241013, 192119.878102], [161168.898002, 192116.2461], [161124.346, 192109.5991], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161177.421, 192306.5951], [161203.842951, 192311.131092], [161206.757944, 192311.63109], [161236.504992, 192316.738565], [161236.577993, 192316.751099], [161263.705, 192321.4081], [161261.49, 192355.9211], [161250.24, 192360.8371], [161269.322, 192359.6091], [161267.091, 192353.4101], [161269.974999, 192322.454109], [161271.069789, 192310.706283], [161271.125986, 192310.103254], [161271.125999, 192310.10311], [161271.163, 192309.7081], [161286.916, 192307.3901], [161289.037622, 192307.337684], [161290.986779, 192308.589926], [161290.939885, 192307.290688]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31596.15394050648, \"brdr_diff_area_index\": 1.2, \"brdr_diff_area_index_perc\": 0.0, \"brdr_diff_length_index\": 1.7, \"brdr_diff_length_index_perc\": 0.2, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 917.9513383790202, \"brdr_relevant_distance\": 1.3, \"brdr_remark\": [], \"brdr_shape_index\": 0.47119944078520204, \"brdr_stability\": false, \"brdr_sym_diff_area_index\": 1.2, \"brdr_sym_diff_area_index_perc\": 0.0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161250.24, 192360.8371], [161251.575229, 192360.751173], [161252.320147, 192361.936584], [161253.05032, 192361.485002], [161253.526865, 192361.190345], [161254.546227, 192360.559978], [161255.079379, 192360.23028], [161255.285888, 192360.512378], [161269.322, 192359.6091], [161267.091, 192353.4101], [161269.956447, 192322.653247], [161271.109369, 192310.281564], [161271.125985, 192310.103266], [161271.125999, 192310.103109], [161271.163, 192309.7081], [161286.916, 192307.3901], [161294.728, 192307.1971], [161291.07, 192289.8021], [161308.256, 192285.7541], [161307.416, 192281.3241], [161310.776, 192280.7891], [161310.067011, 192277.309155], [161302.756, 192241.4521], [161292.979, 192242.9801], [161289.466, 192225.7941], [161340.8, 192217.1011], [161337.361002, 192190.086114], [161333.798, 192162.0881], [161331.372, 192140.7561], [161301.398, 192136.2181], [161209.378, 192122.2851], [161193.241, 192119.8781], [161168.898, 192116.2461], [161124.346, 192109.5991], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161177.421, 192306.5951], [161203.842948, 192311.131091], [161206.754371, 192311.630478], [161206.757997, 192311.631099], [161236.577992, 192316.751099], [161263.705, 192321.4081], [161261.49, 192355.9211], [161254.243067, 192359.087849], [161250.24, 192360.8371]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31596.639988379466, \"brdr_diff_area_index\": 1.7, \"brdr_diff_area_index_perc\": 0.0, \"brdr_diff_length_index\": 1.3, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 917.5128584786564, \"brdr_relevant_distance\": 1.4, \"brdr_remark\": [], \"brdr_shape_index\": 0.4716571768004321, \"brdr_stability\": false, \"brdr_sym_diff_area_index\": 1.9, \"brdr_sym_diff_area_index_perc\": 0.0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161292.976781, 192242.969244], [161289.466, 192225.7941], [161340.8, 192217.1011], [161337.361, 192190.0861], [161334.032184, 192163.928313], [161333.798, 192162.0881], [161331.372, 192140.7561], [161301.398005, 192136.218101], [161209.378, 192122.2851], [161193.241, 192119.8781], [161168.898, 192116.2461], [161124.346, 192109.5991], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161177.421, 192306.5951], [161203.842944, 192311.13109], [161206.756158, 192311.630784], [161206.757997, 192311.631099], [161236.577992, 192316.751099], [161263.705, 192321.4081], [161261.49, 192355.9211], [161250.24, 192360.8371], [161269.322, 192359.6091], [161267.091, 192353.4101], [161269.975, 192322.4541], [161271.125999, 192310.103109], [161271.163, 192309.7081], [161286.916, 192307.3901], [161294.728, 192307.1971], [161291.07, 192289.8021], [161308.256, 192285.7541], [161307.416, 192281.3241], [161310.776, 192280.7891], [161310.532576, 192279.594298], [161310.067012, 192277.309158], [161302.756, 192241.4521], [161293.95489, 192242.827583], [161292.999443, 192241.450311], [161292.976781, 192242.969244]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31595.66379368122, \"brdr_diff_area_index\": 0.7, \"brdr_diff_area_index_perc\": 0.0, \"brdr_diff_length_index\": 2.2, \"brdr_diff_length_index_perc\": 0.2, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 918.433867217055, \"brdr_relevant_distance\": 1.5, \"brdr_remark\": [], \"brdr_shape_index\": 0.47069714924395784, \"brdr_stability\": false, \"brdr_sym_diff_area_index\": 0.7, \"brdr_sym_diff_area_index_perc\": 0.0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161250.24, 192360.8371], [161251.220228, 192360.774019], [161252.320147, 192361.936584], [161253.05032, 192361.485002], [161253.526867, 192361.190344], [161253.348613, 192360.637049], [161269.322, 192359.6091], [161267.091, 192353.4101], [161269.975, 192322.4541], [161271.125999, 192310.103109], [161271.163, 192309.7081], [161286.916, 192307.3901], [161294.728, 192307.1971], [161291.07, 192289.8021], [161308.256, 192285.7541], [161307.416, 192281.3241], [161310.776, 192280.7891], [161310.067013, 192277.309162], [161302.756, 192241.4521], [161292.979, 192242.9801], [161289.466, 192225.7941], [161340.8, 192217.1011], [161337.361002, 192190.086117], [161333.798, 192162.0881], [161331.372, 192140.7561], [161301.398, 192136.2181], [161209.378, 192122.2851], [161193.241015, 192119.878102], [161168.898, 192116.2461], [161124.346, 192109.5991], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161177.421, 192306.5951], [161203.84294, 192311.13109], [161206.756699, 192311.630877], [161206.757997, 192311.631099], [161236.577992, 192316.751099], [161263.705, 192321.4081], [161261.49, 192355.9211], [161253.021484, 192359.621653], [161250.24, 192360.8371]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31596.62993398444, \"brdr_diff_area_index\": 1.7, \"brdr_diff_area_index_perc\": 0.0, \"brdr_diff_length_index\": 1.5, \"brdr_diff_length_index_perc\": 0.2, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 917.7051120337965, \"brdr_relevant_distance\": 1.6, \"brdr_remark\": [], \"brdr_shape_index\": 0.4714594289436507, \"brdr_stability\": false, \"brdr_sym_diff_area_index\": 1.7, \"brdr_sym_diff_area_index_perc\": 0.0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161250.24, 192360.8371], [161251.05958, 192360.784357], [161252.320147, 192361.936584], [161253.050323, 192361.485], [161252.704743, 192360.678484], [161269.322, 192359.6091], [161267.091, 192353.4101], [161269.974999, 192322.454111], [161271.125999, 192310.103109], [161271.163, 192309.7081], [161286.916, 192307.3901], [161294.728, 192307.1971], [161291.07, 192289.8021], [161308.256, 192285.7541], [161307.416, 192281.3241], [161310.776, 192280.7891], [161310.14903, 192277.711731], [161310.067013, 192277.309166], [161302.756, 192241.4521], [161292.979, 192242.9801], [161289.466, 192225.7941], [161340.8, 192217.1011], [161337.361, 192190.0861], [161333.798, 192162.0881], [161331.372, 192140.7561], [161301.398007, 192136.218101], [161209.378, 192122.2851], [161193.241016, 192119.878102], [161168.898, 192116.2461], [161124.346, 192109.5991], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161177.421, 192306.5951], [161203.842937, 192311.131089], [161206.755235, 192311.630626], [161206.757997, 192311.631099], [161236.556204, 192316.747358], [161236.577991, 192316.751098], [161263.705, 192321.4081], [161261.49, 192355.9211], [161252.373276, 192359.904906], [161250.24, 192360.8371]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31596.304100269983, \"brdr_diff_area_index\": 1.4, \"brdr_diff_area_index_perc\": 0.0, \"brdr_diff_length_index\": 1.8, \"brdr_diff_length_index_perc\": 0.2, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 918.0325765492697, \"brdr_relevant_distance\": 1.7, \"brdr_remark\": [], \"brdr_shape_index\": 0.471118289056263, \"brdr_stability\": false, \"brdr_sym_diff_area_index\": 1.4, \"brdr_sym_diff_area_index_perc\": 0.0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161250.239999, 192360.8371], [161250.726215, 192360.80581], [161250.728663, 192360.805653], [161250.898929, 192360.794696], [161252.320147, 192361.936584], [161251.909492, 192360.729662], [161269.322, 192359.6091], [161267.091, 192353.4101], [161269.974999, 192322.454113], [161271.117923, 192310.189775], [161271.125979, 192310.103321], [161271.125999, 192310.103112], [161271.163, 192309.7081], [161286.916, 192307.3901], [161294.728, 192307.1971], [161291.07, 192289.8021], [161308.256, 192285.7541], [161307.416, 192281.3241], [161310.776, 192280.7891], [161310.067014, 192277.309169], [161302.756, 192241.4521], [161292.979, 192242.9801], [161289.466, 192225.7941], [161340.8, 192217.1011], [161337.361002, 192190.086119], [161333.798, 192162.0881], [161331.372, 192140.7561], [161301.398005, 192136.218101], [161209.378, 192122.2851], [161193.241019, 192119.878103], [161168.898, 192116.2461], [161124.346, 192109.5991], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161177.421, 192306.5951], [161203.842934, 192311.131089], [161206.755145, 192311.63061], [161206.757924, 192311.631087], [161236.577989, 192316.751098], [161263.705, 192321.4081], [161261.49, 192355.9211], [161251.739227, 192360.181972], [161250.239999, 192360.8371]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31595.540309598506, \"brdr_diff_area_index\": 0.6, \"brdr_diff_area_index_perc\": 0.0, \"brdr_diff_length_index\": 2.1, \"brdr_diff_length_index_perc\": 0.2, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 918.322687403589, \"brdr_relevant_distance\": 1.8, \"brdr_remark\": [], \"brdr_shape_index\": 0.47080928914608944, \"brdr_stability\": false, \"brdr_sym_diff_area_index\": 0.6, \"brdr_sym_diff_area_index_perc\": 0.0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161250.24, 192360.8371], [161250.722454, 192360.806052], [161250.738281, 192360.805034], [161252.320147, 192361.936584], [161251.418982, 192360.761228], [161269.322, 192359.6091], [161267.091, 192353.4101], [161269.974999, 192322.454112], [161271.105799, 192310.319875], [161271.125979, 192310.103325], [161271.125999, 192310.10311], [161271.163, 192309.7081], [161286.916, 192307.3901], [161294.728, 192307.1971], [161291.07, 192289.8021], [161308.256, 192285.7541], [161307.416, 192281.3241], [161310.776, 192280.7891], [161310.067015, 192277.309173], [161302.756, 192241.4521], [161292.979, 192242.9801], [161289.466, 192225.7941], [161340.8, 192217.1011], [161337.361002, 192190.086119], [161333.798, 192162.0881], [161331.372, 192140.7561], [161301.398006, 192136.218101], [161209.378, 192122.2851], [161193.241019, 192119.878103], [161168.898, 192116.2461], [161124.346, 192109.5991], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161177.421, 192306.5951], [161203.84293, 192311.131088], [161206.757096, 192311.630945], [161206.757919, 192311.631086], [161236.577989, 192316.751098], [161263.705, 192321.4081], [161261.49, 192355.9211], [161251.16668, 192360.432161], [161250.24, 192360.8371]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31595.33686288184, \"brdr_diff_area_index\": 0.4, \"brdr_diff_area_index_perc\": 0.0, \"brdr_diff_length_index\": 2.7, \"brdr_diff_length_index_perc\": 0.3, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 918.9812255625792, \"brdr_relevant_distance\": 1.9, \"brdr_remark\": [], \"brdr_shape_index\": 0.47013174367562527, \"brdr_stability\": false, \"brdr_sym_diff_area_index\": 0.4, \"brdr_sym_diff_area_index_perc\": 0.0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161250.24, 192360.8371], [161250.297833, 192360.833378], [161250.484334, 192360.821376], [161250.577631, 192360.815372], [161252.308363, 192361.929001], [161252.30987, 192361.927058], [161251.07592, 192360.783305], [161269.322, 192359.6091], [161267.091, 192353.4101], [161269.975, 192322.4541], [161271.125999, 192310.103109], [161271.163, 192309.7081], [161274.702347, 192309.187297], [161286.916, 192307.3901], [161294.728, 192307.1971], [161291.07, 192289.8021], [161308.256, 192285.7541], [161307.416, 192281.3241], [161310.776, 192280.7891], [161310.067016, 192277.309177], [161302.756, 192241.4521], [161292.979, 192242.9801], [161289.466, 192225.7941], [161340.8, 192217.1011], [161337.361, 192190.0861], [161333.798, 192162.0881], [161331.372, 192140.7561], [161301.398008, 192136.218101], [161209.378, 192122.2851], [161193.241, 192119.8781], [161169.34442, 192116.312706], [161168.898003, 192116.2461], [161124.346, 192109.5991], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161177.421, 192306.5951], [161203.842926, 192311.131087], [161206.755024, 192311.630589], [161206.757997, 192311.631099], [161236.57799, 192316.751098], [161263.705, 192321.4081], [161261.49, 192355.9211], [161250.568305, 192360.693638], [161250.24, 192360.8371]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31595.22435674417, \"brdr_diff_area_index\": 0.3, \"brdr_diff_area_index_perc\": 0.0, \"brdr_diff_length_index\": 3.2, \"brdr_diff_length_index_perc\": 0.4, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 919.481046657889, \"brdr_relevant_distance\": 2.0, \"brdr_remark\": [], \"brdr_shape_index\": 0.46961909211663083, \"brdr_stability\": false, \"brdr_sym_diff_area_index\": 0.3, \"brdr_sym_diff_area_index_perc\": 0.0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161250.24, 192360.8371], [161250.416982, 192360.825711], [161252.201835, 192361.867525], [161252.208083, 192361.857791], [161250.713089, 192360.806655], [161252.092096, 192360.717911], [161269.322, 192359.6091], [161267.091, 192353.4101], [161269.974999, 192322.454113], [161271.102744, 192310.352653], [161271.107419, 192310.302486], [161271.125999, 192310.103109], [161271.163, 192309.7081], [161286.916, 192307.3901], [161294.728, 192307.1971], [161291.07, 192289.8021], [161308.256, 192285.7541], [161307.416, 192281.3241], [161310.776, 192280.7891], [161310.458855, 192279.232449], [161310.067016, 192277.30918], [161302.756, 192241.4521], [161292.979, 192242.9801], [161289.466, 192225.7941], [161340.8, 192217.1011], [161337.361003, 192190.086121], [161333.798, 192162.0881], [161331.372, 192140.7561], [161301.398, 192136.2181], [161209.378, 192122.2851], [161193.24102, 192119.878103], [161169.028016, 192116.265499], [161168.898, 192116.2461], [161124.346, 192109.5991], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161177.421, 192306.5951], [161203.842922, 192311.131087], [161206.756264, 192311.630802], [161206.757997, 192311.631099], [161236.567423, 192316.749284], [161236.577988, 192316.751098], [161263.705, 192321.4081], [161261.49, 192355.9211], [161250.563619, 192360.695686], [161250.24, 192360.8371]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31595.098901677677, \"brdr_diff_area_index\": 0.2, \"brdr_diff_area_index_perc\": 0.0, \"brdr_diff_length_index\": 3.6, \"brdr_diff_length_index_perc\": 0.4, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 919.8463932586685, \"brdr_relevant_distance\": 2.1, \"brdr_remark\": [], \"brdr_shape_index\": 0.46924425429186617, \"brdr_stability\": false, \"brdr_sym_diff_area_index\": 0.2, \"brdr_sym_diff_area_index_perc\": 0.0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161193.428943, 192119.906141], [161169.016027, 192116.26371], [161168.898, 192116.2461], [161124.346, 192109.5991], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161177.421, 192306.5951], [161203.842919, 192311.131086], [161206.756646, 192311.630868], [161206.757997, 192311.631099], [161236.577989, 192316.751098], [161263.705, 192321.4081], [161261.49, 192355.9211], [161250.24, 192360.8371], [161269.322, 192359.6091], [161267.091, 192353.4101], [161269.974999, 192322.454115], [161271.081674, 192310.578752], [161271.125976, 192310.103361], [161271.125999, 192310.10311], [161271.163, 192309.7081], [161286.916, 192307.3901], [161294.728, 192307.1971], [161291.07, 192289.8021], [161308.256, 192285.7541], [161307.416, 192281.3241], [161310.776, 192280.7891], [161310.067017, 192277.309184], [161302.756, 192241.4521], [161292.979, 192242.9801], [161289.466, 192225.7941], [161340.8, 192217.1011], [161337.361, 192190.0861], [161333.880428, 192162.735815], [161333.798, 192162.0881], [161331.372, 192140.7561], [161301.398009, 192136.218101], [161222.918688, 192124.335333], [161222.746195, 192122.954055], [161218.084997, 192123.60345], [161209.378, 192122.2851], [161193.428944, 192119.906134], [161193.428943, 192119.906141]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31598.192302371393, \"brdr_diff_area_index\": 3.3, \"brdr_diff_area_index_perc\": 0.0, \"brdr_diff_length_index\": 1.2, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 917.4467947058812, \"brdr_prediction_count\": 2, \"brdr_prediction_score\": 20.0, \"brdr_relevant_distance\": 2.2, \"brdr_remark\": [], \"brdr_shape_index\": 0.47174828111998424, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 3.3, \"brdr_sym_diff_area_index_perc\": 0.0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161218.084997, 192123.60345], [161209.378, 192122.2851], [161193.241, 192119.8781], [161169.309961, 192116.307565], [161168.898004, 192116.246101], [161124.346, 192109.5991], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161177.421, 192306.5951], [161203.842915, 192311.131085], [161206.754864, 192311.630562], [161206.757997, 192311.631099], [161236.577987, 192316.751098], [161263.705, 192321.4081], [161261.49, 192355.9211], [161250.24, 192360.8371], [161269.322, 192359.6091], [161267.091, 192353.4101], [161269.974999, 192322.454116], [161271.107416, 192310.302514], [161271.125999, 192310.103109], [161271.163, 192309.7081], [161286.916, 192307.3901], [161294.728, 192307.1971], [161291.07, 192289.8021], [161308.256, 192285.7541], [161307.416, 192281.3241], [161310.776, 192280.7891], [161310.067018, 192277.309188], [161302.756, 192241.4521], [161292.979, 192242.9801], [161289.466, 192225.7941], [161340.8, 192217.1011], [161337.361003, 192190.086123], [161333.798, 192162.0881], [161331.372, 192140.7561], [161301.398007, 192136.218101], [161222.918688, 192124.335333], [161222.746195, 192122.954055], [161218.084997, 192123.60345]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31598.192303078125, \"brdr_diff_area_index\": 3.3, \"brdr_diff_area_index_perc\": 0.0, \"brdr_diff_length_index\": 1.2, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 917.446787144112, \"brdr_relevant_distance\": 2.3, \"brdr_remark\": [], \"brdr_shape_index\": 0.4717482889070118, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 3.3, \"brdr_sym_diff_area_index_perc\": 0.0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161218.084997, 192123.60345], [161210.547334, 192122.462152], [161209.378, 192122.2851], [161193.241, 192119.8781], [161169.446981, 192116.328008], [161168.898002, 192116.2461], [161124.346, 192109.5991], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161177.421, 192306.5951], [161203.842912, 192311.131085], [161206.75642, 192311.630829], [161206.757997, 192311.631099], [161236.570482, 192316.749809], [161236.577988, 192316.751098], [161263.705, 192321.4081], [161261.49, 192355.9211], [161250.24, 192360.8371], [161269.322, 192359.6091], [161267.091, 192353.4101], [161269.975, 192322.4541], [161271.125999, 192310.103109], [161271.163, 192309.7081], [161286.916, 192307.3901], [161294.728, 192307.1971], [161291.07, 192289.8021], [161308.256, 192285.7541], [161307.416, 192281.3241], [161310.776, 192280.7891], [161310.067019, 192277.309192], [161302.756, 192241.4521], [161292.979, 192242.9801], [161289.466, 192225.7941], [161340.8, 192217.1011], [161337.386259, 192190.284525], [161333.919376, 192163.041873], [161333.798, 192162.0881], [161331.372, 192140.7561], [161301.398, 192136.2181], [161225.587885, 192124.739483], [161222.918688, 192124.335333], [161222.746195, 192122.954055], [161218.084997, 192123.60345]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31598.192411873923, \"brdr_diff_area_index\": 3.3, \"brdr_diff_area_index_perc\": 0.0, \"brdr_diff_length_index\": 1.2, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 917.4467871440147, \"brdr_relevant_distance\": 2.4, \"brdr_remark\": [], \"brdr_shape_index\": 0.4717482905313894, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 3.3, \"brdr_sym_diff_area_index_perc\": 0.0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161218.084997, 192123.60345], [161209.378, 192122.2851], [161207.053408, 192121.938363], [161193.241025, 192119.878104], [161168.898, 192116.2461], [161124.346, 192109.5991], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161177.421, 192306.5951], [161203.842908, 192311.131084], [161206.756753, 192311.630886], [161206.757997, 192311.631099], [161236.577987, 192316.751098], [161263.705, 192321.4081], [161261.49, 192355.9211], [161250.24, 192360.8371], [161269.322, 192359.6091], [161267.091, 192353.4101], [161269.974998, 192322.454116], [161271.125999, 192310.103109], [161271.163, 192309.7081], [161286.916, 192307.3901], [161294.728, 192307.1971], [161291.07, 192289.8021], [161308.256, 192285.7541], [161307.416, 192281.3241], [161310.776, 192280.7891], [161310.067019, 192277.309195], [161302.756, 192241.4521], [161292.979, 192242.9801], [161289.466, 192225.7941], [161340.8, 192217.1011], [161337.361003, 192190.086125], [161333.913423, 192162.995089], [161333.798, 192162.0881], [161331.372, 192140.7561], [161301.398, 192136.2181], [161222.918688, 192124.335333], [161222.746195, 192122.954055], [161218.084997, 192123.60345]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31598.192303062202, \"brdr_diff_area_index\": 3.3, \"brdr_diff_area_index_perc\": 0.0, \"brdr_diff_length_index\": 1.2, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 917.4467871441532, \"brdr_relevant_distance\": 2.5, \"brdr_remark\": [], \"brdr_shape_index\": 0.47174828890673176, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 3.3, \"brdr_sym_diff_area_index_perc\": 0.0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161218.084997, 192123.60345], [161209.378, 192122.2851], [161193.241026, 192119.878104], [161168.898, 192116.2461], [161124.346, 192109.5991], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161177.421, 192306.5951], [161203.842905, 192311.131084], [161206.755173, 192311.630615], [161206.757894, 192311.631082], [161206.757997, 192311.631099], [161236.577985, 192316.751097], [161263.705, 192321.4081], [161261.49, 192355.9211], [161250.24, 192360.8371], [161269.322, 192359.6091], [161267.091, 192353.4101], [161269.974998, 192322.454116], [161271.122999, 192310.135301], [161271.125971, 192310.103408], [161271.125999, 192310.103109], [161271.163, 192309.7081], [161286.916, 192307.3901], [161294.728, 192307.1971], [161291.07, 192289.8021], [161308.256, 192285.7541], [161307.416, 192281.3241], [161310.776, 192280.7891], [161310.06702, 192277.309199], [161302.756, 192241.4521], [161292.979, 192242.9801], [161289.466, 192225.7941], [161340.8, 192217.1011], [161337.361003, 192190.086126], [161333.798, 192162.0881], [161331.372, 192140.7561], [161301.398009, 192136.218101], [161222.918688, 192124.335333], [161222.746195, 192122.954055], [161218.084997, 192123.60345]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31598.19230306292, \"brdr_diff_area_index\": 3.3, \"brdr_diff_area_index_perc\": 0.0, \"brdr_diff_length_index\": 1.2, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 917.4467871441636, \"brdr_relevant_distance\": 2.6, \"brdr_remark\": [], \"brdr_shape_index\": 0.47174828890673176, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 3.3, \"brdr_sym_diff_area_index_perc\": 0.0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161203.842902, 192311.131083], [161206.757563, 192311.631025], [161206.757997, 192311.631099], [161236.577986, 192316.751098], [161263.705, 192321.4081], [161261.49, 192355.9211], [161250.24, 192360.8371], [161269.322, 192359.6091], [161267.091, 192353.4101], [161269.975, 192322.4541], [161271.125999, 192310.103109], [161271.163, 192309.7081], [161286.916, 192307.3901], [161294.728, 192307.1971], [161291.07, 192289.8021], [161308.256, 192285.7541], [161307.416, 192281.3241], [161310.776, 192280.7891], [161310.067021, 192277.309203], [161302.756, 192241.4521], [161292.979, 192242.9801], [161289.466, 192225.7941], [161340.8, 192217.1011], [161337.361003, 192190.086127], [161333.798, 192162.0881], [161332.082635, 192147.004764], [161331.372, 192140.7561], [161309.64325, 192137.466413], [161301.398, 192136.2181], [161224.849761, 192124.627722], [161222.918688, 192124.335333], [161222.746195, 192122.954055], [161218.084997, 192123.60345], [161209.378, 192122.2851], [161193.241, 192119.8781], [161169.25059, 192116.298707], [161168.898003, 192116.2461], [161124.346, 192109.5991], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161177.421, 192306.5951], [161203.842902, 192311.131083]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31598.192303029427, \"brdr_diff_area_index\": 3.3, \"brdr_diff_area_index_perc\": 0.0, \"brdr_diff_length_index\": 1.2, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 917.4467871441142, \"brdr_relevant_distance\": 2.7, \"brdr_remark\": [], \"brdr_shape_index\": 0.4717482889062826, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 3.3, \"brdr_sym_diff_area_index_perc\": 0.0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161218.084997, 192123.60345], [161209.378, 192122.2851], [161193.241, 192119.8781], [161169.373123, 192116.316989], [161168.898001, 192116.2461], [161124.346, 192109.5991], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161177.421, 192306.5951], [161203.842897, 192311.131082], [161206.757237, 192311.630969], [161206.757997, 192311.631099], [161236.561541, 192316.748274], [161236.577984, 192316.751097], [161263.705, 192321.4081], [161261.49, 192355.9211], [161250.24, 192360.8371], [161269.322, 192359.6091], [161267.091, 192353.4101], [161269.974998, 192322.454119], [161271.125999, 192310.103109], [161271.163, 192309.7081], [161286.916, 192307.3901], [161294.728, 192307.1971], [161291.07, 192289.8021], [161308.256, 192285.7541], [161307.416, 192281.3241], [161310.776, 192280.7891], [161310.067022, 192277.309207], [161302.756, 192241.4521], [161292.979, 192242.9801], [161289.466, 192225.7941], [161340.8, 192217.1011], [161337.361004, 192190.086128], [161333.838982, 192162.410138], [161333.798, 192162.0881], [161331.372, 192140.7561], [161301.398008, 192136.218101], [161222.918688, 192124.335333], [161222.746195, 192122.954055], [161218.084997, 192123.60345]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31598.192303024298, \"brdr_diff_area_index\": 3.3, \"brdr_diff_area_index_perc\": 0.0, \"brdr_diff_length_index\": 1.2, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 917.4467871439704, \"brdr_relevant_distance\": 2.8, \"brdr_remark\": [], \"brdr_shape_index\": 0.47174828890635395, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 3.3, \"brdr_sym_diff_area_index_perc\": 0.0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161218.084997, 192123.60345], [161209.378, 192122.2851], [161202.980484, 192121.330844], [161193.241029, 192119.878104], [161168.898001, 192116.2461], [161124.346, 192109.5991], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161177.421, 192306.5951], [161203.842894, 192311.131082], [161206.755798, 192311.630722], [161206.757997, 192311.631099], [161236.560161, 192316.748037], [161236.577984, 192316.751097], [161263.705, 192321.4081], [161261.49, 192355.9211], [161256.873626, 192357.938353], [161250.24, 192360.8371], [161268.23403, 192359.679115], [161269.322, 192359.6091], [161267.091, 192353.4101], [161267.532947, 192348.666371], [161269.975, 192322.4541], [161271.115322, 192310.217687], [161271.125967, 192310.103452], [161271.125999, 192310.103109], [161271.163, 192309.7081], [161286.916, 192307.3901], [161294.728, 192307.1971], [161291.07, 192289.8021], [161308.256, 192285.7541], [161307.416, 192281.3241], [161310.776, 192280.7891], [161310.067022, 192277.30921], [161302.756, 192241.4521], [161292.979, 192242.9801], [161289.466, 192225.7941], [161340.8, 192217.1011], [161337.361004, 192190.086129], [161333.798, 192162.0881], [161331.372, 192140.7561], [161301.39801, 192136.218102], [161222.918688, 192124.335333], [161222.746195, 192122.954055], [161218.084997, 192123.60345]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31598.19230302506, \"brdr_diff_area_index\": 3.3, \"brdr_diff_area_index_perc\": 0.0, \"brdr_diff_length_index\": 1.2, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 917.4467871438708, \"brdr_relevant_distance\": 2.9, \"brdr_remark\": [], \"brdr_shape_index\": 0.47174828890646764, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 3.3, \"brdr_sym_diff_area_index_perc\": 0.0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161203.842883, 192311.13108], [161206.756473, 192311.630838], [161206.757997, 192311.631099], [161236.573146, 192316.750267], [161236.577984, 192316.751097], [161263.705, 192321.4081], [161261.49, 192355.9211], [161250.24, 192360.8371], [161260.07843, 192360.203959], [161269.322, 192359.6091], [161267.091, 192353.4101], [161269.975, 192322.4541], [161271.085562, 192310.537025], [161271.107409, 192310.302595], [161271.125999, 192310.103109], [161271.163, 192309.7081], [161286.916, 192307.3901], [161294.728, 192307.1971], [161291.07, 192289.8021], [161308.256, 192285.7541], [161307.416, 192281.3241], [161310.776, 192280.7891], [161310.067023, 192277.309214], [161302.756, 192241.4521], [161292.979, 192242.9801], [161289.466, 192225.7941], [161340.8, 192217.1011], [161337.361, 192190.0861], [161333.798, 192162.0881], [161331.372, 192140.7561], [161301.39801, 192136.218102], [161222.918688, 192124.335333], [161222.746195, 192122.954055], [161218.084997, 192123.60345], [161209.378, 192122.2851], [161193.24103, 192119.878104], [161169.158736, 192116.285002], [161168.898, 192116.2461], [161124.346, 192109.5991], [161140.121, 192238.2081], [161139.788, 192240.7681], [161186.534, 192247.4521], [161177.421, 192306.5951], [161203.842883, 192311.13108]]], \"type\": \"Polygon\"}, \"id\": \"id_wkt\", \"properties\": {\"brdr_area\": 31598.192302997, \"brdr_diff_area_index\": 3.3, \"brdr_diff_area_index_perc\": 0.0, \"brdr_diff_length_index\": 1.2, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"id_wkt\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 917.4467871439481, \"brdr_relevant_distance\": 3.0, \"brdr_remark\": [], \"brdr_shape_index\": 0.4717482889059693, \"brdr_stability\": false, \"brdr_sym_diff_area_index\": 3.3, \"brdr_sym_diff_area_index_perc\": 0.0}, \"type\": \"Feature\"}], \"type\": \"FeatureCollection\"}\n\n\n\n\n\nPrediction with NetworkGeometryProcessor\n\n\n\n\n/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/brdr/viz.py:77: UserWarning: The GeoSeries you are attempting to plot is composed of empty geometries. Nothing has been displayed.\n  gpd.GeoSeries(list(results_diff_pos.values())).plot(\n/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/brdr/viz.py:80: UserWarning: The GeoSeries you are attempting to plot is composed of empty geometries. Nothing has been displayed.\n  gpd.GeoSeries(list(results_diff_neg.values())).plot(\n/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/brdr/viz.py:80: UserWarning: The GeoSeries you are attempting to plot is composed of empty geometries. Nothing has been displayed.\n  gpd.GeoSeries(list(results_diff_neg.values())).plot("
  },
  {
    "objectID": "examples/example_animation.html",
    "href": "examples/example_animation.html",
    "title": "Animated GIF",
    "section": "",
    "text": "Animated GIF\nExample to create a animated GIF showing the principle of brdr. For every augmented relevant distance (~distance that adaptions are allowed), the resulting geometry is shown. In the graphic you can ‘see’ the moments where augmenting relevant distance does not give any change, so stable geometries are found.\n\n\nCode\nfrom datetime import datetime\n\nimport numpy as np\n\nfrom brdr.aligner import Aligner\nfrom brdr.be.grb.enums import GRBType\nfrom brdr.be.grb.loader import GRBActualLoader\nfrom brdr.loader import GeoJsonLoader\nfrom brdr.viz import animated_map\n\nif __name__ == \"__main__\":\n    # EXAMPLE to process a series of relevant distances\n    # Initiate brdr\n    aligner = Aligner()\n    # Load thematic data\n    geometry = {\n        \"coordinates\": [\n            [\n                [171136.16765265574, 170605.6084498393],\n                [171164.53923982676, 170663.78453262427],\n                [171071.40019103308, 170714.22290981715],\n                [171037.87013346734, 170676.6807086111],\n                [171136.16765265574, 170605.6084498393],\n            ]\n        ],\n        \"type\": \"Polygon\",\n    }\n\n    geometry = {\n        \"coordinates\": [\n            [\n                [171132.08386359326, 170804.71107799126],\n                [171168.04986551206, 170776.33949082025],\n                [171144.2635853586, 170743.09601494312],\n                [171118.32794254067, 170761.58053385757],\n                [171111.52162743648, 170766.9897632298],\n                [171125.34919391124, 170785.6892184107],\n                [171126.13729355487, 170786.83554516506],\n                [171121.9102136481, 170789.8804756064],\n                [171132.08386359326, 170804.71107799126],\n            ]\n        ],\n        \"type\": \"Polygon\",\n    }\n    thematic_json = {\n        \"type\": \"FeatureCollection\",\n        \"name\": \"test\",\n        \"crs\": {\"type\": \"name\", \"properties\": {\"name\": \"urn:ogc:def:crs:EPSG::31370\"}},\n        \"features\": [\n            {\n                \"type\": \"Feature\",\n                \"properties\": {\"fid\": 1100, \"id\": 1100, \"theme_identifier\": \"1100\"},\n                \"geometry\": geometry,\n            }\n        ],\n    }\n\n    loader = GeoJsonLoader(_input=thematic_json, id_property=\"theme_identifier\")\n    aligner.load_thematic_data(loader)\n    # Load reference data: The actual GRB-parcels\n    aligner.load_reference_data(\n        GRBActualLoader(grb_type=GRBType.ADP, partition=1000, aligner=aligner)\n    )\n    # PROCESS a series of relevant distances\n    relevant_distances = np.arange(0, 710, 10, dtype=int) / 100\n    aligner_result = aligner.process(\n        relevant_distances=relevant_distances,\n    )\n    thematic_geometries = {\n        key: feat.geometry for key, feat in aligner.thematic_data.features.items()\n    }\n    reference_geometries = {\n        key: feat.geometry for key, feat in aligner.reference_data.features.items()\n    }\n    # SHOW results: map and plotted changes\n    now = datetime.now()  # current date and time\n    date_time = now.strftime(\"%m_%d_%Y_%H_%M_%S\")\n    # filename = \"animation_\" + str(date_time) + \".gif\"\n    filename = \"animation.gif\"\n    animated_map(\n        aligner_result.results,\n        thematic_geometries,\n        reference_geometries,\n        relevant_distances[-1],\n        25,\n        150,\n        filename,\n    )\n\n\n/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/brdr/viz.py:77: UserWarning: The GeoSeries you are attempting to plot is composed of empty geometries. Nothing has been displayed.\n  gpd.GeoSeries(list(results_diff_pos.values())).plot(\n/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/brdr/viz.py:80: UserWarning: The GeoSeries you are attempting to plot is composed of empty geometries. Nothing has been displayed.\n  gpd.GeoSeries(list(results_diff_neg.values())).plot(\n/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/brdr/viz.py:77: UserWarning: The GeoSeries you are attempting to plot is composed of empty geometries. Nothing has been displayed.\n  gpd.GeoSeries(list(results_diff_pos.values())).plot(\n/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/brdr/viz.py:80: UserWarning: The GeoSeries you are attempting to plot is composed of empty geometries. Nothing has been displayed.\n  gpd.GeoSeries(list(results_diff_neg.values())).plot(\n\n\nAnimation successfully saved to: animation.gif\n\n\n\n\n\n\n\n\nFigure 1: Graphic"
  },
  {
    "objectID": "qa.html",
    "href": "qa.html",
    "title": "Q&A",
    "section": "",
    "text": "Short answer: All kinds of Geodata quality assurance: validation, correction, alignment, actualization, (auto-)updates, …\nLong answer:\n\nGeodata-management:\n\nImplementation of brdr in business-processes and tooling\nBulk geodata-alignment\nAlignment after reprojection of data\nCleaning data: In a postprocessing-phase, the algorithm executes sliver-cleanup and validity-cleaning on the resulting geometries\n…\n\nData-Analysis: Investigate the pattern in deviation and change between thematic and reference boundaries\nUpdate-detection: Investigate the descriptive formula before and after alignment to check for (automatic) alignment of geodata\n\n\n\n\n\n\nShort answer: Yes\nLong answer: Yes it does. When creating a aligner you can define the crs you want to use. This has to be a projected coordinate system with units in meter. When loading data, you have to provide the data in this CRS. When on-the-fly dataloaders are used, they will try to download the data in the provided crs if available. if not available, an error is returned.\n\n\n\n\n\nShort answer: (Multi-)Points, (Multi-)LineStrings, and (Multi-)Polygons.\nLong answer: brdr was initially started to align thematic (Multi-)Polygons to reference (Multi-)Polygons. Afterwards processors are added to also support (multi-)linestrings and (multi-)Points.\n\n\n\n\n\nShort answer: AlignerGeometryProcessor (default) checks the type of your thematic & reference-data and uses the other Processors underneath. DieussaertGeometryProcessor is a quicker algoritm for aligning Polygons to Polygons. NetworkGeometryPorcessor can be used for all combinations of geometries (Points, Lines, Polygons), but has a longer calculation time.\nLong answer:\n\nAlignerGeometryProcessor (default) is a wrapper around DieussaertGeometryProcessor & NetworkGeometryProcessor. It checks the geometry-types and uses the DieussaertGeometryProcessor if possible, otherwise NetworkGeometryProcessor.\nDieussaertGeometryProcessor: It is a using an algorithm based on buffers, relevant intersections and relevant differences. This is a quick algorithm, but can only be used to align polygon-to-polygon. For most of these cases this is the best option, in some edge cases some detail of the polygon can be simplified.\nNetworkGeometryProcessor: It is using an algorithm based on graphs/networks. This is the most generic processor as this can be used for all point-line-polygon combinations. However he calculation is much slower than Dieussaertprocessor.\nTopologyProcessor: This is an experimental processor and is a special usage of the NetworkGeometryProcessor. The thematic input geometries are ‘converted’ to their topolgical arcs, and these arcs are aligned with the NetworkGeometryProcessor. Afterwards the arcs are re-combined to get a result that keeps a topological relation with its neighbours.\n\nSummary; if you have polygon-to-polygon, start with DieussaertProcessor and see if these results fits your goal. If not, try NetworkGeometryProcessor\n\n\n\n\n\nShort answer: No, it is currently 2D-only. (3D and M-Z values are not supported)\nLong answer: The library is optimized for 2D alignment. If you provide geometries with M- or Z-coordinates, the alignment will be calculated based on the \\(X\\) and \\(Y\\) planes. M/Z-values are stripped.\n\n\n\n\n\nShort answer: No, but…\nLong answer: Every thematic input geometry is processed individually to find a result/prediction. So there is no topology preserved between multiple thematic input geometries. However there is a TopologyGeometryProcessor (experimental) that searches for predictions for every thematic geometry, while trying to preserve topology between these geometries."
  },
  {
    "objectID": "qa.html#where-can-brdr-be-used-for",
    "href": "qa.html#where-can-brdr-be-used-for",
    "title": "Q&A",
    "section": "",
    "text": "Short answer: All kinds of Geodata quality assurance: validation, correction, alignment, actualization, (auto-)updates, …\nLong answer:\n\nGeodata-management:\n\nImplementation of brdr in business-processes and tooling\nBulk geodata-alignment\nAlignment after reprojection of data\nCleaning data: In a postprocessing-phase, the algorithm executes sliver-cleanup and validity-cleaning on the resulting geometries\n…\n\nData-Analysis: Investigate the pattern in deviation and change between thematic and reference boundaries\nUpdate-detection: Investigate the descriptive formula before and after alignment to check for (automatic) alignment of geodata"
  },
  {
    "objectID": "qa.html#does-brdr-support-multiple-coordinate-systems-crs",
    "href": "qa.html#does-brdr-support-multiple-coordinate-systems-crs",
    "title": "Q&A",
    "section": "",
    "text": "Short answer: Yes\nLong answer: Yes it does. When creating a aligner you can define the crs you want to use. This has to be a projected coordinate system with units in meter. When loading data, you have to provide the data in this CRS. When on-the-fly dataloaders are used, they will try to download the data in the provided crs if available. if not available, an error is returned."
  },
  {
    "objectID": "qa.html#which-geometry-types-are-supported",
    "href": "qa.html#which-geometry-types-are-supported",
    "title": "Q&A",
    "section": "",
    "text": "Short answer: (Multi-)Points, (Multi-)LineStrings, and (Multi-)Polygons.\nLong answer: brdr was initially started to align thematic (Multi-)Polygons to reference (Multi-)Polygons. Afterwards processors are added to also support (multi-)linestrings and (multi-)Points."
  },
  {
    "objectID": "qa.html#how-to-choose-the-best-processor-for-my-data",
    "href": "qa.html#how-to-choose-the-best-processor-for-my-data",
    "title": "Q&A",
    "section": "",
    "text": "Short answer: AlignerGeometryProcessor (default) checks the type of your thematic & reference-data and uses the other Processors underneath. DieussaertGeometryProcessor is a quicker algoritm for aligning Polygons to Polygons. NetworkGeometryPorcessor can be used for all combinations of geometries (Points, Lines, Polygons), but has a longer calculation time.\nLong answer:\n\nAlignerGeometryProcessor (default) is a wrapper around DieussaertGeometryProcessor & NetworkGeometryProcessor. It checks the geometry-types and uses the DieussaertGeometryProcessor if possible, otherwise NetworkGeometryProcessor.\nDieussaertGeometryProcessor: It is a using an algorithm based on buffers, relevant intersections and relevant differences. This is a quick algorithm, but can only be used to align polygon-to-polygon. For most of these cases this is the best option, in some edge cases some detail of the polygon can be simplified.\nNetworkGeometryProcessor: It is using an algorithm based on graphs/networks. This is the most generic processor as this can be used for all point-line-polygon combinations. However he calculation is much slower than Dieussaertprocessor.\nTopologyProcessor: This is an experimental processor and is a special usage of the NetworkGeometryProcessor. The thematic input geometries are ‘converted’ to their topolgical arcs, and these arcs are aligned with the NetworkGeometryProcessor. Afterwards the arcs are re-combined to get a result that keeps a topological relation with its neighbours.\n\nSummary; if you have polygon-to-polygon, start with DieussaertProcessor and see if these results fits your goal. If not, try NetworkGeometryProcessor"
  },
  {
    "objectID": "qa.html#does-brdr-support-3d-geometries-mz-coordinates",
    "href": "qa.html#does-brdr-support-3d-geometries-mz-coordinates",
    "title": "Q&A",
    "section": "",
    "text": "Short answer: No, it is currently 2D-only. (3D and M-Z values are not supported)\nLong answer: The library is optimized for 2D alignment. If you provide geometries with M- or Z-coordinates, the alignment will be calculated based on the \\(X\\) and \\(Y\\) planes. M/Z-values are stripped."
  },
  {
    "objectID": "qa.html#is-topology-preserved-between-the-thematic-geometries-input",
    "href": "qa.html#is-topology-preserved-between-the-thematic-geometries-input",
    "title": "Q&A",
    "section": "",
    "text": "Short answer: No, but…\nLong answer: Every thematic input geometry is processed individually to find a result/prediction. So there is no topology preserved between multiple thematic input geometries. However there is a TopologyGeometryProcessor (experimental) that searches for predictions for every thematic geometry, while trying to preserve topology between these geometries."
  },
  {
    "objectID": "examples/example_geojsonloader.html",
    "href": "examples/example_geojsonloader.html",
    "title": "GeojsonLoader",
    "section": "",
    "text": "DictLoader\nThis example shows how a GeojsonLoader can be used to add data to the aligner\n\nfrom brdr.aligner import Aligner\nfrom brdr.be.grb.enums import GRBType\nfrom brdr.be.grb.loader import GRBActualLoader\nfrom brdr.geometry_utils import geom_from_wkt\n\nfrom brdr.loader import DictLoader\n\nif __name__ == \"__main__\":\n    \"\"\"\n    Example to load dat with a DictLoader, and also adding the properties to the result\n    \"\"\"\n    # CREATE AN ALIGNER\n    aligner = Aligner(crs=\"EPSG:31370\")\n    # ADD A THEMATIC POLYGON TO THEMATIC DICTIONARY and LOAD into Aligner\n    id = \"my_theme_id\"\n    wkt = \"MULTIPOLYGON (((141894.30860000103712082 192030.99359999969601631, 141895.30039999634027481 192030.43499999865889549, 141916.94680000096559525 192018.24240000173449516, 141935.11959999799728394 192008.00629999861121178, 141938.46660000085830688 192006.36679999902844429, 141938.01630000025033951 192004.09310000017285347, 141936.13579999655485153 191997.07739999890327454, 141927.83190000057220459 191974.37330000102519989, 141924.48290000110864639 191964.26909999921917915, 141918.48789999634027481 191946.18219999969005585, 141897.54580000042915344 191892.38010000064969063, 141885.81229999661445618 191863.05810000002384186, 141883.73430000245571136 191858.32620000094175339, 141881.57930000126361847 191851.27149999886751175, 141880.02970000356435776 191844.1534000001847744, 141875.37430000305175781 191822.76999999955296516, 141875.30219999700784683 191822.43849999830126762, 141875.31379999965429306 191822.42839999869465828, 141875.32599999755620956 191822.41780000180006027, 141873.66679999977350235 191810.330400001257658, 141873.53939999639987946 191810.47140000015497208, 141824.16929999738931656 191865.09059999883174896, 141807.49130000174045563 191883.54179999977350235, 141806.4221000000834465 191884.39990000054240227, 141804.12879999727010727 191884.68789999932050705, 141802.18280000239610672 191884.19500000029802322, 141799.86169999837875366 191882.65430000051856041, 141797.43410000205039978 191879.70760000124573708, 141796.65850000083446503 191879.23550000041723251, 141795.6005999967455864 191879.14139999821782112, 141793.61129999905824661 191879.65769999846816063, 141791.29720000177621841 191881.41699999943375587, 141775.49679999798536301 191898.58630000054836273, 141762.63560000061988831 191912.02459999918937683, 141746.34480000287294388 191931.99890000000596046, 141739.71980000287294388 191941.33379999920725822, 141718.17260000109672546 191963.87099999934434891, 141707.33889999985694885 191974.1517999991774559, 141691.99570000171661377 191990.56419999897480011, 141682.7752000018954277 191999.544599998742342, 141680.59319999814033508 192001.8539000004529953, 141677.57880000025033951 192009.98910000175237656, 141677.57880000025033951 192024.72419999912381172, 141687.39810000360012054 192032.38650000095367432, 141710.51529999822378159 192048.2443000003695488, 141718.70740000158548355 192054.53130000084638596, 141792.93550000339746475 192111.49830000102519989, 141790.39050000160932541 192115.83139999955892563, 141771.93940000236034393 192145.56280000135302544, 141756.72280000150203705 192171.94390000030398369, 141750.73979999870061874 192185.24599999934434891, 141746.87189999967813492 192192.59640000015497208, 141744.20000000298023224 192197.03090000152587891, 141741.65730000287294388 192203.05490000173449516, 141738.98480000346899033 192211.15890000015497208, 141736.27549999952316284 192222.19130000099539757, 141734.4122999981045723 192232.36960000172257423, 141734.01650000363588333 192233.20839999988675117, 141733.4156000018119812 192233.86070000007748604, 141732.60769999772310257 192234.36529999971389771, 141731.69009999930858612 192234.72720000147819519, 141730.37650000303983688 192234.86820000037550926, 141727.74570000171661377 192234.72109999880194664, 141708.45470000058412552 192234.2791999988257885, 141680.76659999787807465 192234.02210000157356262, 141656.07289999723434448 192234.38520000129938126, 141629.07209999859333038 192233.29850000143051147, 141618.51850000023841858 192231.88439999893307686, 141603.34749999642372131 192228.10990000143647194, 141597.26340000331401825 192226.65670000016689301, 141592.5292000025510788 192225.30229999870061874, 141568.39479999989271164 192219.11100000143051147, 141554.37330000102519989 192214.54509999975562096, 141541.26389999687671661 192208.97210000082850456, 141529.27139999717473984 192202.5982000008225441, 141527.42339999973773956 192207.54980000108480453, 141526.95019999891519547 192208.81769999861717224, 141538.93559999763965607 192213.12829999998211861, 141551.88490000367164612 192218.77100000157952309, 141563.40359999984502792 192223.01000000163912773, 141568.94730000197887421 192224.56370000168681145, 141588.22190000116825104 192230.68310000002384186, 141599.65079999715089798 192233.4813000001013279, 141604.27549999952316284 192234.52360000088810921, 141612.59619999676942825 192236.39869999885559082, 141625.6671999990940094 192238.60940000042319298, 141640.7581000030040741 192239.92980000004172325, 141687.70180000364780426 192239.60280000045895576, 141708.04810000211000443 192239.78669999912381172, 141725.32699999958276749 192239.62020000070333481, 141736.44510000199079514 192239.40599999949336052, 141738.10999999940395355 192233.08529999852180481, 141744.46729999780654907 192208.94959999993443489, 141747.24490000307559967 192201.90359999984502792, 141750.76910000294446945 192194.79340000078082085, 141757.62960000336170197 192183.66059999912977219, 141765.30849999934434891 192168.3214000016450882, 141766.5877000018954277 192166.07369999960064888, 141779.35530000180006027 192173.02180000022053719, 141801.67239999771118164 192199.32169999927282333, 141831.40259999781847 192121.48229999840259552, 141831.68190000206232071 192121.63430000096559525, 141839.40439999848604202 192125.83700000122189522, 141847.05669999867677689 192105.80189999938011169, 141848.41929999738931656 192102.23440000042319298, 141852.30349999666213989 192092.06469999998807907, 141856.9464000016450882 192074.37240000069141388, 141855.61249999701976776 192070.44669999927282333, 141854.58449999988079071 192067.42040000110864639, 141851.04050000011920929 192056.98910000175237656, 141853.14169999957084656 192055.68459999933838844, 141855.8546999990940094 192053.98660000041127205, 141857.53270000219345093 192052.94280000030994415, 141865.36980000138282776 192048.06769999861717224, 141878.53230000287294388 192039.87979999929666519, 141877.30830000340938568 192037.69469999894499779, 141888.70970000326633453 192031.27279999852180481, 141889.19900000095367432 192031.21249999850988388, 141890.32779999822378159 192033.23580000177025795, 141894.30860000103712082 192030.99359999969601631),(141798.70589999854564667 192111.06799999997019768, 141801.00859999656677246 192106.89739999920129776, 141829.50010000169277191 192122.21880000084638596, 141800.99939999729394913 192196.83920000120997429, 141781.65139999985694885 192173.08870000019669533, 141767.0609000027179718 192165.24260000139474869, 141773.47720000147819519 192153.96849999949336052, 141785.42890000343322754 192135.11470000073313713, 141798.70589999854564667 192111.06799999997019768)))\"\n    thematic_dict = {id: geom_from_wkt(wkt)}\n    loader = DictLoader(data_dict=thematic_dict)\n    aligner.load_thematic_data(loader)\n\n    # Load reference data: The actual GRB-parcels\n    loader = GRBActualLoader(grb_type=GRBType.ADP, partition=1000, aligner=aligner)\n    aligner.load_reference_data(loader)\n    # EXECUTE THE ALIGNMENT\n    relevant_distance = 5\n    aligner_result = aligner.process(relevant_distances=[relevant_distance])\n    process_results = aligner_result.get_results(aligner=aligner)\n    # PRINT RESULTS IN WKT\n    print(\"result: \" + process_results[id][relevant_distance][\"result\"].wkt)\n    print(\n        \"added area: \" + process_results[id][relevant_distance][\"result_diff_plus\"].wkt\n    )\n    print(\n        \"removed area: \" + process_results[id][relevant_distance][\"result_diff_min\"].wkt\n    )\n\nresult: MULTIPOLYGON (((141793.03305738285 192111.57318755027, 141790.3904695799 192115.8313674, 141771.93939757044 192145.56282341923, 141756.72275755982 192171.94387944016, 141750.7398455493 192185.2460234514, 141746.87194155 192192.59642345, 141742.82794304754 192200.28146594105, 141741.65728554007 192203.0549194593, 141739.89092246076 192208.41111370703, 141741.73062030482 192209.46040323336, 141750.76909355 192194.79341545, 141757.6296375507 192183.66061543886, 141765.30848556166 192168.32135143687, 141766.5828628447 192166.08220142793, 141767.06086818798 192165.24256983973, 141773.4771895606 192153.96845541894, 141785.4289335803 192135.1146954095, 141796.82158037843 192114.48072135754, 141797.44501794243 192113.35157246463, 141797.60589956064 192113.06018915444, 141798.28997375924 192111.8212172532, 141798.70586158 192111.0679753901, 141801.0038013616 192106.90600920998, 141801.6800913187 192105.68115173615, 141801.83878959 192105.39373539, 141831.4026264999 192121.48230970738, 141831.6818585496 192121.634309734, 141839.40442161 192125.8370634101, 141847.05670962 192105.80186339008, 141848.41933292866 192102.23450520015, 141852.3034936202 192092.0647113792, 141856.94637363 192074.37242337025, 141855.6125496299 192070.44666336008, 141854.5844539097 192067.42036021277, 141851.04045362 192056.98912736, 141852.39097125817 192056.15064807926, 141853.1417016185 192055.68455135095, 141854.7287057269 192054.69134007988, 141855.85472564306 192053.9866313356, 141857.53274162 192052.94279135, 141865.36978304185 192048.0676644248, 141866.81699864636 192047.1673787629, 141866.85261363 192047.1452233501, 141876.4258150617 192041.1901092554, 141878.53229363996 192039.87975133993, 141877.30829364 192037.69466334017, 141888.31859764 192031.49306334008, 141888.70970164993 192031.27277534, 141889.19904564018 192031.21248734, 141890.32781365007 192033.23578333991, 141894.3086136501 192030.99360734, 141895.30042165008 192030.43495134008, 141916.94675767008 192018.24237533, 141935.11955768114 192008.0063433195, 141938.46662968 192006.36679132, 141938.01632567964 192004.09312731825, 141936.13581368045 191997.07744731105, 141927.83194167062 191974.37331930175, 141924.4854072258 191964.27673489143, 141924.4828872273 191964.26913198843, 141918.4878776708 191946.182215282, 141897.54579764695 191892.38010323196, 141885.81229364063 191863.05811922147, 141883.7343416403 191858.32621522073, 141881.57933363982 191851.27149521885, 141880.02970324864 191844.153422599, 141875.3021755949 191822.43851153212, 141875.3254736129 191822.41380685786, 141873.66682164 191810.33043919006, 141873.53940063194 191810.47136385995, 141824.16934979084 191865.09056700877, 141807.49126958975 191883.54183124026, 141806.4220855899 191884.39994324007, 141804.12877357993 191884.68794324, 141802.18278958995 191884.19501524014, 141799.86170159004 191882.65427923997, 141797.43405357964 191879.70759122973, 141796.65850158 191879.23552723, 141795.60058157754 191879.14144723074, 141793.61126957982 191879.6576712401, 141791.29722157962 191881.41703124024, 141775.4967735719 191898.58631124764, 141762.63558956096 191912.02464724876, 141746.34477355 191931.99891927, 141739.71981353982 191941.33383128035, 141718.17261353089 191963.87104728923, 141707.3389495192 191974.1517513007, 141691.99571750825 191990.5641673119, 141682.7752375 191999.5446473201, 141680.5932215 192001.85389532015, 141677.57882149992 192009.98906332042, 141677.57882149992 192024.7241673399, 141687.3980854999 192032.38650334, 141710.5152695301 192048.24429535, 141718.70739026685 192054.5313297759, 141749.1093688275 192077.86358368513, 141751.58060556688 192074.77973901018, 141791.9401655799 192108.53645538993, 141790.96320244708 192109.984659987, 141792.9354935801 192111.49831139, 141793.03305738285 192111.57318755027)), ((141725.3270455372 192239.62016747976, 141736.44512554 192239.40602347982, 141737.61955949193 192234.94725314045, 141737.64666152475 192234.8443595378, 141738.78980980895 192230.5043660842, 141733.4156215401 192233.86067948, 141732.60768554022 192234.36525547988, 141731.69005354 192234.72723948, 141731.4883200514 192234.8068185435, 141731.04332745058 192234.79662609258, 141730.37651752948 192234.86816748008, 141727.74573353713 192234.7210954799, 141708.45472552654 192234.2792394801, 141680.76659750368 192234.0220874799, 141656.07290149166 192234.38522348, 141629.07206946905 192233.29850347992, 141618.5185334608 192231.88435948017, 141603.34752545008 192228.10989548, 141597.26342945182 192226.65671147034, 141592.5292214508 192225.30234347016, 141568.39482142948 192219.1109834698, 141554.3732534101 192214.54509547, 141547.59936119211 192212.33929130126, 141541.2639414099 192208.97210346008, 141529.2713654 192202.5982154602, 141527.42342940008 192207.54976746, 141526.95021872703 192208.8177373759, 141533.91939805186 192211.32418877794, 141538.93562139958 192213.12826346981, 141551.88486940946 192218.77101546992, 141563.40358942084 192223.00999147023, 141568.94726942235 192224.5636554708, 141588.22189343965 192230.68307947982, 141599.6508214521 192233.48128748054, 141604.2754954486 192234.52358471838, 141612.59616546106 192236.39866348018, 141625.66720547026 192238.6093514799, 141640.75814947 192239.92979947993, 141687.70182951 192239.60275947992, 141708.04813351537 192239.7866954799, 141719.13516967124 192239.67984257417, 141725.3270455372 192239.62016747976)))\nadded area: GEOMETRYCOLLECTION EMPTY\nremoved area: MULTIPOLYGON (((141751.58060556688 192074.77973901018, 141749.10938305568 192077.86356592987, 141790.96320994748 192109.98464886873, 141791.9401655799 192108.53645538993, 141751.58060556688 192074.77973901018)), ((141792.93549358012 192111.49831138997, 141790.75651614694 192115.20822342104, 141790.77155240465 192115.21730295772, 141793.03305738285 192111.57318755027, 141792.93549358012 192111.49831138997)), ((141801.6723999977 192199.32169999927, 141831.40260148828 192121.48229609613, 141801.83878959 192105.39373539, 141801.6800913187 192105.68115173615, 141801.00856517133 192106.8973812718, 141829.5001000017 192122.21880000085, 141800.9993999973 192196.8392000012, 141781.65139999986 192173.0887000002, 141767.06086249847 192165.24257983334, 141766.5877020916 192166.0737011368, 141779.3553000018 192173.02180000022, 141801.6723999977 192199.32169999927)), ((141742.88068583191 192200.15653360618, 141742.89109347828 192200.16145755255, 141746.75789507607 192192.81315251102, 141746.74550845352 192192.8061695695, 141744.20000000298 192197.03090000153, 141742.88068583191 192200.15653360618)), ((141541.3799938568 192209.03378372776, 141547.59936119211 192212.33929130126, 141554.2501284672 192214.5050019014, 141554.25409109317 192214.49442252837, 141541.38488562324 192209.02353278152, 141541.3799938568 192209.03378372776)), ((141750.71698525207 192194.8985433813, 141750.70753692367 192194.89330513956, 141741.73062030482 192209.46040323336, 141739.8909476443 192208.4111280707, 141738.98480000347 192211.15890000015, 141736.27549999952 192222.191300001, 141734.4122999981 192232.36960000172, 141734.01650000364 192233.2083999999, 141733.41561533514 192233.86068335516, 141738.78981405136 192230.50436343474, 141744.4672999978 192208.94959999993, 141747.24490000308 192201.90359999985, 141750.71698525207 192194.8985433813)), ((141731.6901736623 192234.72719209458, 141731.09726907214 192234.79083364972, 141731.09756480512 192234.79786838643, 141731.4883200514 192234.8068185435, 141731.6901736623 192234.72719209458)))"
  },
  {
    "objectID": "examples/example_predict.html",
    "href": "examples/example_predict.html",
    "title": "Prediction",
    "section": "",
    "text": "Prediction\nThis example shows a simple Prediction by using brdr\n\nimport numpy as np\n\nfrom brdr.aligner import Aligner\nfrom brdr.be.grb.enums import GRBType\nfrom brdr.be.grb.loader import GRBActualLoader\nfrom brdr.enums import AlignerResultType\nfrom brdr.loader import GeoJsonLoader\nfrom brdr.viz import show_map, plot_difference_by_relevant_distance\n\n# Press the green button in the gutter to run the script.\nif __name__ == \"__main__\":\n    \"\"\"\n    EXAMPLE to use the predictor-function to automatically predict which resulting\n    geometries are interesting to look at (based on detection of breakpoints and\n    relevant distances of 'no-change')\n    \"\"\"\n\n    input_geojson = {\n        \"type\": \"FeatureCollection\",\n        \"name\": \"test_wanted_changes\",\n        \"crs\": {\"type\": \"name\", \"properties\": {\"name\": \"urn:ogc:def:crs:EPSG::31370\"}},\n        \"features\": [\n            {\n                \"type\": \"Feature\",\n                \"properties\": {\"id\": 1, \"theme_id\": \"1\"},\n                \"geometry\": {\n                    \"type\": \"MultiPolygon\",\n                    \"coordinates\": [\n                        [\n                            [\n                                [161658.784979313611984, 196026.640970099717379],\n                                [161653.250003308057785, 196011.45697008818388],\n                                [161615.133042572706472, 196023.607370208803331],\n                                [161616.975955285131931, 196029.205066103488207],\n                                [161619.898451283574104, 196037.769162107259035],\n                                [161620.363155283033848, 196039.130890108644962],\n                                [161620.517940590012586, 196039.567879189708037],\n                                [161633.552001053554704, 196038.117011958122021],\n                                [161631.926488338969648, 196035.414327338279691],\n                                [161658.784979313611984, 196026.640970099717379],\n                            ]\n                        ]\n                    ],\n                },\n            }\n        ],\n    }\n    # Initiate an Aligner\n    aligner = Aligner()\n    # Load thematic data & reference data\n    loader = GeoJsonLoader(_input=input_geojson, id_property=\"theme_id\")\n\n    aligner.load_thematic_data(loader)\n    # Load reference data\n    loader = GRBActualLoader(grb_type=GRBType.ADP, partition=1000, aligner=aligner)\n    aligner.load_reference_data(loader)\n\n    # PREDICT the 'stable' relevant distances, for a series of relevant distances\n    series = np.arange(0, 310, 10, dtype=int) / 100\n    # predict which relevant distances are interesting to propose as resulting geometry\n    aligner_result = aligner.predict(\n        relevant_distances=series,\n    )\n    dict_predictions = aligner_result.get_results(\n        aligner=aligner, result_type=AlignerResultType.PREDICTIONS\n    )\n\n    # SHOW results of the predictions\n    fcs = aligner_result.get_results_as_geojson(add_metadata=False, aligner=aligner)\n    diffs_dict = aligner.get_difference_metrics_for_thematic_data(\n        dict_processresults=aligner_result.results, thematic_data=aligner.thematic_data\n    )\n    reference_geometries = {\n        key: feat.geometry for key, feat in aligner.reference_data.features.items()\n    }\n    if fcs is None or \"result\" not in fcs:\n        print(\"empty predictions\")\n    else:\n        print(fcs[\"result\"])\n        for key in dict_predictions:\n            plot_difference_by_relevant_distance({key: diffs_dict[key]})\n            show_map(\n                {key: dict_predictions[key]},\n                {key: aligner.thematic_data.features[key].geometry},\n                reference_geometries,\n            )\n\n{\"crs\": {\"properties\": {\"name\": \"http://www.opengis.net/def/crs/EPSG/0/31370\"}, \"type\": \"name\"}, \"features\": [{\"geometry\": {\"coordinates\": [[[161658.784979, 196026.64097], [161653.250003, 196011.45697], [161615.133043, 196023.60737], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.13089], [161620.517941, 196039.567879], [161633.552001, 196038.117012], [161631.926488, 196035.414327], [161658.784979, 196026.64097]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 676.6478098097134, \"brdr_diff_area_index\": 0, \"brdr_diff_area_index_perc\": 0, \"brdr_diff_length_index\": 0, \"brdr_diff_length_index_perc\": 0, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.53627315584188, \"brdr_relevant_distance\": 0.0, \"brdr_remark\": [\"resulting geometry equal to original geometry\"], \"brdr_shape_index\": 0.6155009286202524, \"brdr_stability\": false, \"brdr_sym_diff_area_index\": 0, \"brdr_sym_diff_area_index_perc\": 0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363156, 196039.130891], [161620.512483, 196039.568487], [161633.552001, 196038.117012], [161631.935603, 196035.429481], [161631.905182, 196035.378901], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161637.08815, 196016.71078], [161637.058383, 196016.618312], [161616.628826, 196023.130565], [161615.15326, 196023.600926], [161615.072394, 196023.626703], [161615.146387, 196023.84353]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 675.4422316076856, \"brdr_diff_area_index\": 1.2, \"brdr_diff_area_index_perc\": 0.2, \"brdr_diff_length_index\": 0.2, \"brdr_diff_length_index_perc\": 0.2, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.75291145883185, \"brdr_relevant_distance\": 0.1, \"brdr_remark\": [], \"brdr_shape_index\": 0.6121456494698921, \"brdr_stability\": false, \"brdr_sym_diff_area_index\": 1.4, \"brdr_sym_diff_area_index_perc\": 0.2}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161620.363156, 196039.130891], [161620.512483, 196039.568487], [161633.552001, 196038.117012], [161631.905182, 196035.378901], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161620.930595, 196021.963221], [161620.871061, 196021.778284], [161615.133043, 196023.60737], [161615.072394, 196023.626703], [161615.119502, 196023.764748], [161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363156, 196039.130891]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 672.9666116038743, \"brdr_diff_area_index\": 3.7, \"brdr_diff_area_index_perc\": 0.5, \"brdr_diff_length_index\": 0.3, \"brdr_diff_length_index_perc\": 0.3, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.85005304211154, \"brdr_relevant_distance\": 0.2, \"brdr_remark\": [], \"brdr_shape_index\": 0.608896975928062, \"brdr_stability\": false, \"brdr_sym_diff_area_index\": 3.9, \"brdr_sym_diff_area_index_perc\": 0.6}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161620.512483, 196039.568487], [161633.552001, 196038.117012], [161631.926488, 196035.414327], [161631.905182, 196035.378901], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.130889], [161620.487061, 196039.493988], [161620.512483, 196039.568487]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 671.6787441626535, \"brdr_diff_area_index\": 5.0, \"brdr_diff_area_index_perc\": 0.7, \"brdr_diff_length_index\": 0.1, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.42267392886258, \"brdr_prediction_count\": 2, \"brdr_prediction_score\": 60.0, \"brdr_relevant_distance\": 0.3, \"brdr_remark\": [], \"brdr_shape_index\": 0.6121636492121675, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 5.1, \"brdr_sym_diff_area_index_perc\": 0.8}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161633.552001, 196038.117012], [161631.926488, 196035.414327], [161631.905182, 196035.378901], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.13089], [161620.512483, 196039.568487], [161633.552001, 196038.117012]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 671.67874416285, \"brdr_diff_area_index\": 5.0, \"brdr_diff_area_index_perc\": 0.7, \"brdr_diff_length_index\": 0.1, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.42267392889335, \"brdr_relevant_distance\": 0.4, \"brdr_remark\": [], \"brdr_shape_index\": 0.6121636492120258, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 5.1, \"brdr_sym_diff_area_index_perc\": 0.8}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161620.512483, 196039.568487], [161633.552001, 196038.117012], [161631.905182, 196035.378901], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.130891], [161620.452824, 196039.39366], [161620.512483, 196039.568487]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 671.6787441629349, \"brdr_diff_area_index\": 5.0, \"brdr_diff_area_index_perc\": 0.7, \"brdr_diff_length_index\": 0.1, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.42267392875263, \"brdr_relevant_distance\": 0.5, \"brdr_remark\": [], \"brdr_shape_index\": 0.6121636492135704, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 5.1, \"brdr_sym_diff_area_index_perc\": 0.8}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161633.552001, 196038.117012], [161631.905182, 196035.378901], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.13089], [161620.512483, 196039.568487], [161633.552001, 196038.117012]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 671.678744162797, \"brdr_diff_area_index\": 5.0, \"brdr_diff_area_index_perc\": 0.7, \"brdr_diff_length_index\": 0.1, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.4226739288893, \"brdr_relevant_distance\": 0.6, \"brdr_remark\": [], \"brdr_shape_index\": 0.6121636492120198, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 5.1, \"brdr_sym_diff_area_index_perc\": 0.8}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161633.552001, 196038.117012], [161631.926488, 196035.414327], [161631.905182, 196035.378901], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.130891], [161620.512483, 196039.568487], [161633.552001, 196038.117012]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 671.678744162638, \"brdr_diff_area_index\": 5.0, \"brdr_diff_area_index_perc\": 0.7, \"brdr_diff_length_index\": 0.1, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.42267392886258, \"brdr_relevant_distance\": 0.7, \"brdr_remark\": [], \"brdr_shape_index\": 0.6121636492121535, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 5.1, \"brdr_sym_diff_area_index_perc\": 0.8}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161633.552001, 196038.117012], [161631.905182, 196035.378901], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.130889], [161620.512483, 196039.568487], [161633.552001, 196038.117012]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 671.6787441629815, \"brdr_diff_area_index\": 5.0, \"brdr_diff_area_index_perc\": 0.7, \"brdr_diff_length_index\": 0.1, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.42267392893959, \"brdr_relevant_distance\": 0.8, \"brdr_remark\": [], \"brdr_shape_index\": 0.6121636492116636, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 5.1, \"brdr_sym_diff_area_index_perc\": 0.8}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161633.552001, 196038.117012], [161631.93206, 196035.423591], [161631.905182, 196035.378901], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.13089], [161620.512483, 196039.568487], [161633.552001, 196038.117012]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 671.6787441628469, \"brdr_diff_area_index\": 5.0, \"brdr_diff_area_index_perc\": 0.7, \"brdr_diff_length_index\": 0.1, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.42267392889335, \"brdr_relevant_distance\": 0.9, \"brdr_remark\": [], \"brdr_shape_index\": 0.612163649212023, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 5.1, \"brdr_sym_diff_area_index_perc\": 0.8}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161633.552001, 196038.117012], [161631.926488, 196035.414327], [161631.905182, 196035.378901], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.130891], [161620.512483, 196039.568487], [161633.552001, 196038.117012]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 671.6787441630211, \"brdr_diff_area_index\": 5.0, \"brdr_diff_area_index_perc\": 0.7, \"brdr_diff_length_index\": 0.1, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.42267392873454, \"brdr_relevant_distance\": 1.0, \"brdr_remark\": [], \"brdr_shape_index\": 0.6121636492138376, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 5.1, \"brdr_sym_diff_area_index_perc\": 0.8}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161633.552001, 196038.117012], [161632.577345, 196036.496484], [161631.905182, 196035.378901], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.130891], [161620.512483, 196039.568487], [161633.552001, 196038.117012]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 671.6787441627348, \"brdr_diff_area_index\": 5.0, \"brdr_diff_area_index_perc\": 0.7, \"brdr_diff_length_index\": 0.1, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.42267392893199, \"brdr_relevant_distance\": 1.1, \"brdr_remark\": [], \"brdr_shape_index\": 0.612163649211518, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 5.1, \"brdr_sym_diff_area_index_perc\": 0.8}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161633.552001, 196038.117012], [161631.905182, 196035.378901], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.13089], [161620.512483, 196039.568487], [161633.552001, 196038.117012]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 671.6787441626301, \"brdr_diff_area_index\": 5.0, \"brdr_diff_area_index_perc\": 0.7, \"brdr_diff_length_index\": 0.1, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.42267392893199, \"brdr_relevant_distance\": 1.2, \"brdr_remark\": [], \"brdr_shape_index\": 0.6121636492114225, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 5.1, \"brdr_sym_diff_area_index_perc\": 0.8}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161629.675154, 196038.548557], [161633.552001, 196038.117012], [161631.926488, 196035.414327], [161631.905182, 196035.378901], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.130889], [161620.512483, 196039.568487], [161629.675154, 196038.548557]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 671.678744162767, \"brdr_diff_area_index\": 5.0, \"brdr_diff_area_index_perc\": 0.7, \"brdr_diff_length_index\": 0.1, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.42267392883181, \"brdr_relevant_distance\": 1.3, \"brdr_remark\": [], \"brdr_shape_index\": 0.6121636492125918, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 5.1, \"brdr_sym_diff_area_index_perc\": 0.8}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161632.715294, 196038.210149], [161633.552001, 196038.117012], [161631.926488, 196035.414327], [161631.905182, 196035.378901], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.130891], [161620.512483, 196039.568487], [161632.715294, 196038.210149]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 671.6787441628552, \"brdr_diff_area_index\": 5.0, \"brdr_diff_area_index_perc\": 0.7, \"brdr_diff_length_index\": 0.1, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.42267392892796, \"brdr_relevant_distance\": 1.4, \"brdr_remark\": [], \"brdr_shape_index\": 0.6121636492116697, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 5.1, \"brdr_sym_diff_area_index_perc\": 0.8}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161633.552001, 196038.117012], [161631.905182, 196035.378901], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.130889], [161620.512483, 196039.568487], [161633.552001, 196038.117012]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 671.6787441628146, \"brdr_diff_area_index\": 5.0, \"brdr_diff_area_index_perc\": 0.7, \"brdr_diff_length_index\": 0.1, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.42267392898228, \"brdr_relevant_distance\": 1.5, \"brdr_remark\": [], \"brdr_shape_index\": 0.6121636492110663, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 5.1, \"brdr_sym_diff_area_index_perc\": 0.8}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161631.668506, 196038.32667], [161633.552001, 196038.117012], [161632.577345, 196036.496484], [161631.905182, 196035.378901], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.130889], [161620.512483, 196039.568487], [161631.668506, 196038.32667]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 671.6787441628674, \"brdr_diff_area_index\": 5.0, \"brdr_diff_area_index_perc\": 0.7, \"brdr_diff_length_index\": 0.1, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.42267392895153, \"brdr_relevant_distance\": 1.6, \"brdr_remark\": [], \"brdr_shape_index\": 0.6121636492114351, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 5.1, \"brdr_sym_diff_area_index_perc\": 0.8}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161633.552001, 196038.117012], [161631.905182, 196035.378901], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.130891], [161620.512483, 196039.568487], [161633.552001, 196038.117012]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 671.6787441624355, \"brdr_diff_area_index\": 5.0, \"brdr_diff_area_index_perc\": 0.7, \"brdr_diff_length_index\": 0.1, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.42267392890123, \"brdr_relevant_distance\": 1.7, \"brdr_remark\": [], \"brdr_shape_index\": 0.6121636492115659, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 5.1, \"brdr_sym_diff_area_index_perc\": 0.8}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161633.552001, 196038.117012], [161631.905182, 196035.378901], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.130889], [161620.512483, 196039.568487], [161633.552001, 196038.117012]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 671.6787441626475, \"brdr_diff_area_index\": 5.0, \"brdr_diff_area_index_perc\": 0.7, \"brdr_diff_length_index\": 0.1, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.42267392902495, \"brdr_relevant_distance\": 1.8, \"brdr_remark\": [], \"brdr_shape_index\": 0.6121636492104691, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 5.1, \"brdr_sym_diff_area_index_perc\": 0.8}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161633.552001, 196038.117012], [161633.056069, 196037.292442], [161631.926488, 196035.414327], [161631.905182, 196035.378901], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.13089], [161620.512483, 196039.568487], [161633.552001, 196038.117012]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 671.6787441627295, \"brdr_diff_area_index\": 5.0, \"brdr_diff_area_index_perc\": 0.7, \"brdr_diff_length_index\": 0.1, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.4226739288716, \"brdr_relevant_distance\": 1.9, \"brdr_remark\": [], \"brdr_shape_index\": 0.6121636492121426, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 5.1, \"brdr_sym_diff_area_index_perc\": 0.8}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161633.552001, 196038.117012], [161631.905182, 196035.378901], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.130889], [161620.512483, 196039.568487], [161633.552001, 196038.117012]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 671.6787441628455, \"brdr_diff_area_index\": 5.0, \"brdr_diff_area_index_perc\": 0.7, \"brdr_diff_length_index\": 0.1, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.42267392896277, \"brdr_relevant_distance\": 2.0, \"brdr_remark\": [], \"brdr_shape_index\": 0.612163649211298, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 5.1, \"brdr_sym_diff_area_index_perc\": 0.8}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161632.781856, 196038.202739], [161633.552001, 196038.117012], [161632.990482, 196037.183394], [161631.93206, 196035.423591], [161631.905182, 196035.378901], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.13089], [161620.512483, 196039.568487], [161632.781856, 196038.202739]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 671.6787441634527, \"brdr_diff_area_index\": 5.0, \"brdr_diff_area_index_perc\": 0.7, \"brdr_diff_length_index\": 0.1, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.42267392867467, \"brdr_relevant_distance\": 2.1, \"brdr_remark\": [], \"brdr_shape_index\": 0.6121636492148552, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 5.1, \"brdr_sym_diff_area_index_perc\": 0.8}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161633.552001, 196038.117012], [161631.926488, 196035.414327], [161631.905182, 196035.378901], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.13089], [161620.512483, 196039.568487], [161633.552001, 196038.117012]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 671.6787441625575, \"brdr_diff_area_index\": 5.0, \"brdr_diff_area_index_perc\": 0.7, \"brdr_diff_length_index\": 0.1, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.42267392915691, \"brdr_relevant_distance\": 2.2, \"brdr_remark\": [], \"brdr_shape_index\": 0.6121636492090111, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 5.1, \"brdr_sym_diff_area_index_perc\": 0.8}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161628.440717, 196038.685967], [161633.552001, 196038.117012], [161631.935603, 196035.429481], [161631.905182, 196035.378901], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.130891], [161620.512483, 196039.568487], [161628.440717, 196038.685967]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 671.6787441627018, \"brdr_diff_area_index\": 5.0, \"brdr_diff_area_index_perc\": 0.7, \"brdr_diff_length_index\": 0.1, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.42267392890525, \"brdr_relevant_distance\": 2.3, \"brdr_remark\": [], \"brdr_shape_index\": 0.6121636492117667, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 5.1, \"brdr_sym_diff_area_index_perc\": 0.8}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161632.578795, 196038.225343], [161633.552001, 196038.117012], [161632.420867, 196036.236314], [161631.926488, 196035.414327], [161631.905182, 196035.378901], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.130889], [161620.512483, 196039.568487], [161632.578795, 196038.225343]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 671.6787441625667, \"brdr_diff_area_index\": 5.0, \"brdr_diff_area_index_perc\": 0.7, \"brdr_diff_length_index\": 0.1, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.42267392877473, \"brdr_relevant_distance\": 2.4, \"brdr_remark\": [], \"brdr_shape_index\": 0.6121636492130044, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 5.1, \"brdr_sym_diff_area_index_perc\": 0.8}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161633.552001, 196038.117012], [161632.066629, 196035.647335], [161631.926488, 196035.414327], [161631.905182, 196035.378901], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.13089], [161620.512483, 196039.568487], [161633.552001, 196038.117012]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 671.6787441626699, \"brdr_diff_area_index\": 5.0, \"brdr_diff_area_index_perc\": 0.7, \"brdr_diff_length_index\": 0.1, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.42267392879212, \"brdr_relevant_distance\": 2.5, \"brdr_remark\": [], \"brdr_shape_index\": 0.6121636492129171, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 5.1, \"brdr_sym_diff_area_index_perc\": 0.8}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161633.552001, 196038.117012], [161631.926488, 196035.414327], [161631.905182, 196035.378901], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.13089], [161620.512483, 196039.568487], [161633.552001, 196038.117012]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 671.6787441596514, \"brdr_diff_area_index\": 5.0, \"brdr_diff_area_index_perc\": 0.7, \"brdr_diff_length_index\": 0.1, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.42267392917161, \"brdr_relevant_distance\": 2.6, \"brdr_remark\": [], \"brdr_shape_index\": 0.6121636492062092, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 5.1, \"brdr_sym_diff_area_index_perc\": 0.8}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161631.164204, 196038.382806], [161633.552001, 196038.117012], [161632.474036, 196036.324716], [161631.93297, 196035.425105], [161631.905182, 196035.378901], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.130891], [161620.512483, 196039.568487], [161631.164204, 196038.382806]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 671.6787441607843, \"brdr_diff_area_index\": 5.0, \"brdr_diff_area_index_perc\": 0.7, \"brdr_diff_length_index\": 0.1, \"brdr_diff_length_index_perc\": 0.1, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 117.42267392294991, \"brdr_relevant_distance\": 2.7, \"brdr_remark\": [], \"brdr_shape_index\": 0.6121636492721134, \"brdr_stability\": false, \"brdr_sym_diff_area_index\": 5.1, \"brdr_sym_diff_area_index_perc\": 0.8}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.13089], [161620.470925, 196039.095884], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 649.8264059351809, \"brdr_diff_area_index\": 26.8, \"brdr_diff_area_index_perc\": 4.0, \"brdr_diff_length_index\": 4.8, \"brdr_diff_length_index_perc\": 4.0, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 112.78160008840608, \"brdr_prediction_count\": 2, \"brdr_prediction_score\": 30.0, \"brdr_relevant_distance\": 2.8, \"brdr_remark\": [], \"brdr_shape_index\": 0.6419936248050387, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 27.0, \"brdr_sym_diff_area_index_perc\": 4.0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.13089], [161620.470925, 196039.095884], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 649.8264059351809, \"brdr_diff_area_index\": 26.8, \"brdr_diff_area_index_perc\": 4.0, \"brdr_diff_length_index\": 4.8, \"brdr_diff_length_index_perc\": 4.0, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 112.78160008840608, \"brdr_relevant_distance\": 2.9, \"brdr_remark\": [], \"brdr_shape_index\": 0.6419936248050387, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 27.0, \"brdr_sym_diff_area_index_perc\": 4.0}, \"type\": \"Feature\"}, {\"geometry\": {\"coordinates\": [[[161615.146387, 196023.84353], [161616.975955, 196029.205066], [161619.898451, 196037.769162], [161620.363155, 196039.13089], [161620.470925, 196039.095884], [161658.784979, 196026.64097], [161653.278356, 196011.534732], [161653.250003, 196011.45697], [161653.230035, 196011.463434], [161615.146387, 196023.84353]]], \"type\": \"Polygon\"}, \"id\": \"1\", \"properties\": {\"brdr_area\": 649.8264059351809, \"brdr_diff_area_index\": 26.8, \"brdr_diff_area_index_perc\": 4.0, \"brdr_diff_length_index\": 4.8, \"brdr_diff_length_index_perc\": 4.0, \"brdr_id\": \"1\", \"brdr_nr_calculations\": 31, \"brdr_perimeter\": 112.78160008840608, \"brdr_relevant_distance\": 3.0, \"brdr_remark\": [], \"brdr_shape_index\": 0.6419936248050387, \"brdr_stability\": true, \"brdr_sym_diff_area_index\": 27.0, \"brdr_sym_diff_area_index_perc\": 4.0}, \"type\": \"Feature\"}], \"type\": \"FeatureCollection\"}\n\n\n\n\n\n\n\n\nFigure 1: Graphic\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Visual predictions"
  },
  {
    "objectID": "examples/example_readme.html",
    "href": "examples/example_readme.html",
    "title": "Get Started",
    "section": "",
    "text": "Get Started\nThis example shows a basic example to ‘Get Started’.\n\n\nCode\nfrom brdr.aligner import Aligner\nfrom brdr.geometry_utils import geom_from_wkt\nfrom brdr.loader import DictLoader\n\n# CREATE AN ALIGNER\naligner = Aligner(\n    crs=\"EPSG:31370\",\n)\n# ADD A THEMATIC POLYGON TO THEMATIC DICTIONARY and LOAD into Aligner\nthematic_dict = {\"theme_id_1\": geom_from_wkt(\"POLYGON ((0 0, 0 9, 5 10, 10 0, 0 0))\")}\nloader = DictLoader(thematic_dict)\naligner.load_thematic_data(loader)\n# ADD A REFERENCE POLYGON TO REFERENCE DICTIONARY and LOAD into Aligner\nreference_dict = {\"ref_id_1\": geom_from_wkt(\"POLYGON ((0 1, 0 10,8 10,10 1,0 1))\")}\nloader = DictLoader(reference_dict)\naligner.load_reference_data(loader)\n# EXECUTE THE ALIGNMENT\nrelevant_distance = 1\naligner_result = aligner.process(\n    relevant_distances=[relevant_distance],\n)\nprocess_results = aligner_result.get_results(aligner=aligner)\n# PRINT RESULTS IN WKT\nprint(\"result: \" + process_results[\"theme_id_1\"][relevant_distance][\"result\"].wkt)\nprint(\n    \"added area: \"\n    + process_results[\"theme_id_1\"][relevant_distance][\"result_diff_plus\"].wkt\n)\nprint(\n    \"removed area: \"\n    + process_results[\"theme_id_1\"][relevant_distance][\"result_diff_min\"].wkt\n)\n\n\nresult: POLYGON ((0.1685303876974549 0.4444297669803975, 0.0761204674887134 0.6173165676349098, 0.0192147195967695 0.8049096779838716, 0 1, 0 10, 4.999999999999999 10, 9.500000000000004 1, 9.381966011250102 1, 9.36275129165333 0.8049096779838723, 9.305845543761384 0.6173165676348947, 9.213435623552671 0.4444297669804294, 9.089072792436635 0.2928932188134386, 8.937536244269706 0.1685303876974548, 8.76464944361519 0.0761204674887132, 8.577056333266233 0.0192147195967696, 8.3819660112501 -1.734723475976807e-18, 0.9999999999999997 -1.734723475976807e-18, 0.8049096779838718 0.0192147195967696, 0.6173165676349087 0.0761204674887139, 0.4444297669803966 0.1685303876974555, 0.2928932188134523 0.2928932188134525, 0.1685303876974549 0.4444297669803975))\nadded area: POLYGON ((0 10, 4.99850865709512 10, 4.9985376179666465 9.99970752359333, 0 9, 0 10))\nremoved area: MULTIPOLYGON (((0.0761204674887134 0.6173165676349098, 0.1685303876974549 0.4444297669803975, 0.2928932188134523 0.2928932188134525, 0.4444297669803966 0.1685303876974556, 0.6173165676349087 0.0761204674887139, 0.8682521196030504 0, 1.734723475976807e-18 0, 1.734723475976807e-18 0.86825211960305, 0.0761204674887134 0.6173165676349098)), ((8.76464944361519 0.0761204674887132, 8.937536244269706 0.1685303876974548, 9.089072792436633 0.2928932188134385, 9.213435623552671 0.4444297669804296, 9.305845543761384 0.6173165676348947, 9.36275129165333 0.8049096779838723, 9.381966011250102 1, 9.5 1, 10 0, 8.513713891647056 0, 8.76464944361519 0.0761204674887132)))"
  },
  {
    "objectID": "examples/example_evaluate.html",
    "href": "examples/example_evaluate.html",
    "title": "Evaluation",
    "section": "",
    "text": "Evaluation\nThis example shows a simple Evaluation by using brdr\n\n\n\nimport numpy as np\n\nfrom brdr.aligner import Aligner\nfrom brdr.be.grb.enums import GRBType\nfrom brdr.be.grb.loader import GRBActualLoader\nfrom brdr.constants import (\n    EVALUATION_FIELD_NAME,\n    RELEVANT_DISTANCE_FIELD_NAME,\n    PREDICTION_SCORE,\n)\nfrom brdr.enums import AlignerResultType, FullReferenceStrategy\nfrom brdr.geometry_utils import geom_from_wkt\nfrom brdr.loader import DictLoader\n\n# Press the green button in the gutter to run the script.\nif __name__ == \"__main__\":\n    \"\"\"\n    EXAMPLE of the 'evaluate()-function of 'brdr': This function evaluates thematic objects with a former brdr_observation and compares them with an actual observation; and adds evaluation-properties to the result\n    \"\"\"\n\n    # Start an aligner to align thematic objects on the actual parcels\n    aligner = Aligner(crs=\"EPSG:31370\")\n    # Define the range of relevant distances to search for predictions\n    relevant_distances = np.arange(0, 400, 10, dtype=int) / 100\n    # Define the input geometry\n    input_geometry_wkt = \"POLYGON ((174099.53572337731020525 179375.43192003236617893, 174116.23475504826637916 179372.81056040961993858, 174109.5357249012158718 179324.16977629828033969, 174094.68135370552772656 179324.75230065890355036, 174099.53572337731020525 179375.43192003236617893))\"\n    thematic_dict = {\"id_1\": geom_from_wkt(input_geometry_wkt)}\n    loader = DictLoader(data_dict=thematic_dict)\n\n    # Load the input geometry into the Aligner\n    aligner.load_thematic_data(loader)\n\n    # Load reference data (in this case we use a on-the-fly reference loader to load the actual parcels of Flanders (GRB)\n    aligner.load_reference_data(\n        GRBActualLoader(grb_type=GRBType.ADP, partition=1000, aligner=aligner)\n    )\n\n    # Use the EVALUATE-function\n    aligner_result = aligner.evaluate(\n        relevant_distances=relevant_distances,\n        thematic_ids=None,\n        metadata_field=None,\n        full_reference_strategy=FullReferenceStrategy.PREFER_FULL_REFERENCE,\n    )\n\n    # Get the EVALUATED results as GEOJSON\n    fc = aligner_result.get_results_as_geojson(\n        result_type=AlignerResultType.EVALUATED_PREDICTIONS,\n        add_metadata=True,\n        add_original_attributes=True,\n        aligner=aligner,\n    )\n    # Loop these results to print the results\n    for feature in fc[\"result\"][\"features\"]:\n        print(\n            feature[\"properties\"][aligner.thematic_data.id_fieldname]\n            + \": \"\n            + feature[\"properties\"][EVALUATION_FIELD_NAME]\n            + \" - score \"\n            + str(feature[\"properties\"][PREDICTION_SCORE])\n            + \" - distance \"\n            + str(feature[\"properties\"][RELEVANT_DISTANCE_FIELD_NAME])\n        )\n\nid_1: prediction_unique_full - score 100 - distance 1.4\n\n\n\nFigure 1"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "brdr",
    "section": "",
    "text": "a Python library to assist in realigning geometries (OGC Simple Features) to reference borders\n\n\n\n\nPyPI - Version\n\n\n\n\n\nDOI\n\n\n\n\n\n\nAPI reference documentation\nExamples\n\n\n\n\n\n\nbrdr is a Python package that assists in aligning geometric boundaries to reference boundaries. This is an important task in geographic data management to enhance data quality.\n\nIn the context of geographic data management, it is important to have accurate and consistent boundaries for a variety of applications such as calculating areas, analyzing spatial relationships, and visualizing and querying geographic information.\nbrdr can be used to align boundaries from new data to reference data, ensuring that the boundaries are accurate and consistent.\n\n\n\n\nThe animated gif below shows the main principle of ‘brdr’: * The visualizatuion on the left: * the original thematic geometry (blue), * A reference layer (yellow-black). * The resulting geometry after alignment with brdr (green)** * The graphic on the right: * X-as: Relevant distance (~distance that change is allowed), that increases * Y-as: Change (%) of the resulting geometry\nbrdr will ‘detect’ stable situations that result in one or more predictions. \n\n\n\n\nGeodata-management:\n\nImplementation of brdr in business-processes and tooling\nBulk geodata-alignment\nAlignment after reprojection of data\nCleaning data: In a postprocessing-phase, the algorithm executes sliver-cleanup and validity-cleaning on the resulting geometries\n…\n\nData-Analysis: Investigate the pattern in deviation and change between thematic and reference boundaries\nUpdate-detection: Investigate the descriptive formula before and after alignment to check for (automatic) alignment of geodata\n…\n\n\n\n\n\nYou can install the latest release of brdr from GitHub or PyPi:\npip install brdr\n\n\n\nSee API Reference\n\n\n\nSee Examples\n\n\n\n\n\n\n\n\nclassDiagram\n    class Aligner {\n        +CRS crs\n        +Processor processor\n        +load_thematic_data(data)\n        +load_reference_data(data)\n        +process()\n        +predict()\n        +evaluate()\n    }\n\n    class Processor {\n        +process(geometry)\n    }\n\n    class AlignerResult {\n        +get_results()\n    }\n\n    Aligner \"1\" --* \"1\" Processor : uses\n    Aligner \"1\" --&gt; \"*\" AlignerResult : generates\n\n\n\n\n\n\n\n\n\nTo use brdr, These are the minimal steps to execute:\n\nCreate a Aligner-class\n\nLoad thematic data\nLoad reference data\n\nProcess (or predict or evaluate) the thematic data\nProcessResults are returned:\n\nResulting geometry\nDifferences: parts that are ‘different’ from the original geometry (positive or negative)\nPositive differences: parts that are added to the original geometry\nNegative differences: parts that are removed form the original geometry\n\n\n\n\n\nWhen using brdr to make predictions, every original geometry is processed using the brdr-algorithm:\nThis algorithm is based on 2 main principles:\n\nPrinciple of intentionality: Thematic boundaries can consciously or unconsciously deviate from the reference borders. The algorithm should keep notice of that.\nSelective spatial conservation of shape: The resulting geometry should re-use the shape of the reference borders where aligned is of relevance.\n\nThe figure below shows a schematic overview of the algorithm: \nThe algorithm can be split into 3 main phases:\n\nInitialisation:\n\nDeciding which reference polygons are candidate-polygons to re-use its shape. The reference candidate polygons are selected based on spatial intersection with the thematic geometry.\n\nProcessing:\n\nProcess all candidate-reference polygons one-by-one\nCalculate relevant zones for each candidate-reference-polygon\n\nrelevant intersections: zones that must be present in the final result\nrelevant differences: zones that must be excluded from the final result \n\nEvaluate each candidate based on their relative zones: which parts must be kept and which parts must be excluded \nUnion all kept parts to recompose a resulting geometry\n\nPost-processing:\n\nValidation/correction of differences between the original input geometry and the composed intermediate resulting geometry after processing the algorithm\nTechnical validation of inner holes and multipolygons that are created by processing the algorithm\nClean-up slivers\nMake the resulting geometry valid\n\nRESULT:\n\nA new resulting output geometry, aligned to the reference-polygons\n\n\nA more in-depth description of the algorithm can be found in the following article (in dutch):\n\nDieussaert, K., Vanvinckenroye, M., Vermeyen, M., & Van Daele, K. (2024). Grenzen verleggen. Automatische correcties van geografische afbakeningen op verschuivende onderlagen Onderzoeksrapporten Agentschap Onroerend Erfgoed, https://doi.org/10.55465/SXCW6218.\n\n\n\n\n\n\nPIP_COMPILE_ARGS=\"-v --strip-extras --no-header --resolver=backtracking --no-emit-options --no-emit-find-links\"\npip-compile $PIP_COMPILE_ARGS\npip-compile $PIP_COMPILE_ARGS -o requirements-dev.txt --all-extras\n\n\n\npython - m\npytest - -cov = brdr\ntests / --cov - report\nterm - missing\n\n\n\nAs an example-usage (proof-of-concept), a Dockerfile is created to set up a GRB-specific webservice that ‘predicts’ one or multiple actual geometries for a input-geometry based on the reference source GRB. This webservice is based on ‘brdr’.\nThis POC can be found at brdr-webservice (GRB-actualisator).\ndocker build -f Dockerfile . -t grb_webservice\ndocker run --rm -p 80:80 --name grb_webservice grb_webservice\n\n\nexample can be found at: http://localhost:80/docs#/default/actualiser_actualiser_post\n\n\n\n\nAn implementation of brdr for QGIS can be found at GitHub-brdrQ. This QGIS-plugin provides a User Interface to align thematic data to a reference layer, showing the results in the QGIS Table of Contents.\n\n\n\nA more in-depth description of the algorithm can be found in the following article (in dutch):\n\nDieussaert, K., Vanvinckenroye, M., Vermeyen, M., & Van Daele, K. (2024). Grenzen verleggen. Automatische correcties van geografische afbakeningen op verschuivende onderlagen Onderzoeksrapporten Agentschap Onroerend Erfgoed, https://doi.org/10.55465/SXCW6218.\n\n\n\n\nWe would love to hear from you and your experiences with brdr or its sister project brdrQ. The discussions forum is the place to be when:\n\nYou have any questions on using brdr or brdrQ or their applicability to your use cases\nWant to share your experiences with the library\nHave any suggestions for improvements or feature requests\n\nIf you have discovered a bug in the brdr library you can report it here:\nhttps://github.com/OnroerendErfgoed/brdr/issues\nWe try to keep the list of issues as clean as possible. If you’re unsure whether something is a bug, or whether the bug is in brdr or brdrQ, we encourage you to go through the discussions forum first.\n\n\n\nThis software was created by Athumi, the Flemish data utility company, and Flanders Heritage Agency."
  },
  {
    "objectID": "index.html#quick-links",
    "href": "index.html#quick-links",
    "title": "brdr",
    "section": "",
    "text": "API reference documentation\nExamples"
  },
  {
    "objectID": "index.html#description",
    "href": "index.html#description",
    "title": "brdr",
    "section": "",
    "text": "brdr is a Python package that assists in aligning geometric boundaries to reference boundaries. This is an important task in geographic data management to enhance data quality.\n\nIn the context of geographic data management, it is important to have accurate and consistent boundaries for a variety of applications such as calculating areas, analyzing spatial relationships, and visualizing and querying geographic information.\nbrdr can be used to align boundaries from new data to reference data, ensuring that the boundaries are accurate and consistent.\n\n\n\n\nThe animated gif below shows the main principle of ‘brdr’: * The visualizatuion on the left: * the original thematic geometry (blue), * A reference layer (yellow-black). * The resulting geometry after alignment with brdr (green)** * The graphic on the right: * X-as: Relevant distance (~distance that change is allowed), that increases * Y-as: Change (%) of the resulting geometry\nbrdr will ‘detect’ stable situations that result in one or more predictions. \n\n\n\n\nGeodata-management:\n\nImplementation of brdr in business-processes and tooling\nBulk geodata-alignment\nAlignment after reprojection of data\nCleaning data: In a postprocessing-phase, the algorithm executes sliver-cleanup and validity-cleaning on the resulting geometries\n…\n\nData-Analysis: Investigate the pattern in deviation and change between thematic and reference boundaries\nUpdate-detection: Investigate the descriptive formula before and after alignment to check for (automatic) alignment of geodata\n…"
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "brdr",
    "section": "",
    "text": "You can install the latest release of brdr from GitHub or PyPi:\npip install brdr"
  },
  {
    "objectID": "index.html#api-reference",
    "href": "index.html#api-reference",
    "title": "brdr",
    "section": "",
    "text": "See API Reference"
  },
  {
    "objectID": "index.html#code-examples",
    "href": "index.html#code-examples",
    "title": "brdr",
    "section": "",
    "text": "See Examples"
  },
  {
    "objectID": "index.html#scheme",
    "href": "index.html#scheme",
    "title": "brdr",
    "section": "",
    "text": "classDiagram\n    class Aligner {\n        +CRS crs\n        +Processor processor\n        +load_thematic_data(data)\n        +load_reference_data(data)\n        +process()\n        +predict()\n        +evaluate()\n    }\n\n    class Processor {\n        +process(geometry)\n    }\n\n    class AlignerResult {\n        +get_results()\n    }\n\n    Aligner \"1\" --* \"1\" Processor : uses\n    Aligner \"1\" --&gt; \"*\" AlignerResult : generates"
  },
  {
    "objectID": "index.html#workflow",
    "href": "index.html#workflow",
    "title": "brdr",
    "section": "",
    "text": "To use brdr, These are the minimal steps to execute:\n\nCreate a Aligner-class\n\nLoad thematic data\nLoad reference data\n\nProcess (or predict or evaluate) the thematic data\nProcessResults are returned:\n\nResulting geometry\nDifferences: parts that are ‘different’ from the original geometry (positive or negative)\nPositive differences: parts that are added to the original geometry\nNegative differences: parts that are removed form the original geometry"
  },
  {
    "objectID": "index.html#the-brdr--processing-algorithm",
    "href": "index.html#the-brdr--processing-algorithm",
    "title": "brdr",
    "section": "",
    "text": "When using brdr to make predictions, every original geometry is processed using the brdr-algorithm:\nThis algorithm is based on 2 main principles:\n\nPrinciple of intentionality: Thematic boundaries can consciously or unconsciously deviate from the reference borders. The algorithm should keep notice of that.\nSelective spatial conservation of shape: The resulting geometry should re-use the shape of the reference borders where aligned is of relevance.\n\nThe figure below shows a schematic overview of the algorithm: \nThe algorithm can be split into 3 main phases:\n\nInitialisation:\n\nDeciding which reference polygons are candidate-polygons to re-use its shape. The reference candidate polygons are selected based on spatial intersection with the thematic geometry.\n\nProcessing:\n\nProcess all candidate-reference polygons one-by-one\nCalculate relevant zones for each candidate-reference-polygon\n\nrelevant intersections: zones that must be present in the final result\nrelevant differences: zones that must be excluded from the final result \n\nEvaluate each candidate based on their relative zones: which parts must be kept and which parts must be excluded \nUnion all kept parts to recompose a resulting geometry\n\nPost-processing:\n\nValidation/correction of differences between the original input geometry and the composed intermediate resulting geometry after processing the algorithm\nTechnical validation of inner holes and multipolygons that are created by processing the algorithm\nClean-up slivers\nMake the resulting geometry valid\n\nRESULT:\n\nA new resulting output geometry, aligned to the reference-polygons\n\n\nA more in-depth description of the algorithm can be found in the following article (in dutch):\n\nDieussaert, K., Vanvinckenroye, M., Vermeyen, M., & Van Daele, K. (2024). Grenzen verleggen. Automatische correcties van geografische afbakeningen op verschuivende onderlagen Onderzoeksrapporten Agentschap Onroerend Erfgoed, https://doi.org/10.55465/SXCW6218."
  },
  {
    "objectID": "index.html#development",
    "href": "index.html#development",
    "title": "brdr",
    "section": "",
    "text": "PIP_COMPILE_ARGS=\"-v --strip-extras --no-header --resolver=backtracking --no-emit-options --no-emit-find-links\"\npip-compile $PIP_COMPILE_ARGS\npip-compile $PIP_COMPILE_ARGS -o requirements-dev.txt --all-extras\n\n\n\npython - m\npytest - -cov = brdr\ntests / --cov - report\nterm - missing\n\n\n\nAs an example-usage (proof-of-concept), a Dockerfile is created to set up a GRB-specific webservice that ‘predicts’ one or multiple actual geometries for a input-geometry based on the reference source GRB. This webservice is based on ‘brdr’.\nThis POC can be found at brdr-webservice (GRB-actualisator).\ndocker build -f Dockerfile . -t grb_webservice\ndocker run --rm -p 80:80 --name grb_webservice grb_webservice\n\n\nexample can be found at: http://localhost:80/docs#/default/actualiser_actualiser_post"
  },
  {
    "objectID": "index.html#brdr-for-qgis-brdrq-plugin",
    "href": "index.html#brdr-for-qgis-brdrq-plugin",
    "title": "brdr",
    "section": "",
    "text": "An implementation of brdr for QGIS can be found at GitHub-brdrQ. This QGIS-plugin provides a User Interface to align thematic data to a reference layer, showing the results in the QGIS Table of Contents."
  },
  {
    "objectID": "index.html#motivation-citation",
    "href": "index.html#motivation-citation",
    "title": "brdr",
    "section": "",
    "text": "A more in-depth description of the algorithm can be found in the following article (in dutch):\n\nDieussaert, K., Vanvinckenroye, M., Vermeyen, M., & Van Daele, K. (2024). Grenzen verleggen. Automatische correcties van geografische afbakeningen op verschuivende onderlagen Onderzoeksrapporten Agentschap Onroerend Erfgoed, https://doi.org/10.55465/SXCW6218."
  },
  {
    "objectID": "index.html#comments-and-contributions",
    "href": "index.html#comments-and-contributions",
    "title": "brdr",
    "section": "",
    "text": "We would love to hear from you and your experiences with brdr or its sister project brdrQ. The discussions forum is the place to be when:\n\nYou have any questions on using brdr or brdrQ or their applicability to your use cases\nWant to share your experiences with the library\nHave any suggestions for improvements or feature requests\n\nIf you have discovered a bug in the brdr library you can report it here:\nhttps://github.com/OnroerendErfgoed/brdr/issues\nWe try to keep the list of issues as clean as possible. If you’re unsure whether something is a bug, or whether the bug is in brdr or brdrQ, we encourage you to go through the discussions forum first."
  },
  {
    "objectID": "index.html#acknowledgement",
    "href": "index.html#acknowledgement",
    "title": "brdr",
    "section": "",
    "text": "This software was created by Athumi, the Flemish data utility company, and Flanders Heritage Agency."
  },
  {
    "objectID": "reference/grb.update_featurecollection_to_actual_grb.html",
    "href": "reference/grb.update_featurecollection_to_actual_grb.html",
    "title": "grb.update_featurecollection_to_actual_grb",
    "section": "",
    "text": "be.grb.grb.update_featurecollection_to_actual_grb(\n    featurecollection,\n    id_theme_fieldname=None,\n    base_metadata_field=METADATA_FIELD_NAME,\n    grb_type=GRBType.ADP,\n    max_distance_for_actualisation=2.0,\n    max_predictions=-1,\n    full_reference_strategy=FullReferenceStrategy.NO_FULL_REFERENCE,\n    multi_to_best_prediction=True,\n    feedback=None,\n    crs=DEFAULT_CRS,\n    attributes=True,\n    max_workers=None,\n)\nUpdate a thematic feature collection to the most recent version of the GRB.\nThis function automates the alignment process by first identifying which features are ‘affected’ by changes in the GRB reference layer within a specific timeframe. It then calculates and evaluates new alignment predictions for those affected features.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfeaturecollection\nDict[str, Any]\nThe thematic data as a GeoJSON-like dictionary.\nrequired\n\n\nid_theme_fieldname\nstr\nThe property field name containing the unique ID for each feature.\nNone\n\n\nbase_metadata_field\nstr\nName of the attribute field that stores the existing alignment observation (JSON string). This is used to determine the last version date.\nOBSERVATION_FIELD_NAME\n\n\ngrb_type\nGRBType\nThe type of GRB reference data to align against.\nGRBType.ADP\n\n\nmax_distance_for_actualisation\nfloat\nMaximum distance (in meters) to search for potential alignments. The function checks intervals of 0.1m up to this value.\n2.0\n\n\nmax_predictions\nint\nMaximum number of alignment predictions to return. -1 returns all.\n-1\n\n\nfull_reference_strategy\nFullReferenceStrategy\nDetermines the prediction score when evaluating predictions, so predictions that are based on full-reference-geometries can be preferred.\nNO_FULL_REFERENCE\n\n\nmulti_to_best_prediction\nbool\nIf True, the prediction with the best prediction score is returned when multiple predictions are found If False, the original geometry is returned when multiple predictions are found\nTrue. Only useful when max_predictions=1\n\n\nfeedback\nAny\nFeedback object (e.g., QgsFeedback) for progress reporting and logging (in QGIS).\nNone\n\n\ncrs\nstr\nThe Coordinate Reference System for processing.\nDEFAULT_CRS\n\n\nattributes\nbool\nWhether to include the original thematic attributes in the result.\nTrue\n\n\nmax_workers\nint\nThe number of parallel threads to use for processing.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[str, Any]\nA GeoJSON-like dictionary containing the evaluated predictions and updated alignment observations.\n\n\n\n\n\n\nThe function follows a specific lifecycle to optimize performance:\n\nInitialization: Loads thematic data and the actual GRB reference data.\nTemporal Analysis: Extracts the last_version_date from the features’ observations to determine the relevant GRB change-window.\nSpatial Filtering: Uses get_affected_by_grb_change to isolate only those geometries where the underlying GRB has actually changed.\nAlignment: Executes the Aligner.evaluate logic only on ‘affected’ features.\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf the CRS is unsupported or if the input feature collection is malformed.",
    "crumbs": [
      "Reference",
      "GRB (Flanders-specific)",
      "grb.update_featurecollection_to_actual_grb"
    ]
  },
  {
    "objectID": "reference/grb.update_featurecollection_to_actual_grb.html#parameters",
    "href": "reference/grb.update_featurecollection_to_actual_grb.html#parameters",
    "title": "grb.update_featurecollection_to_actual_grb",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nfeaturecollection\nDict[str, Any]\nThe thematic data as a GeoJSON-like dictionary.\nrequired\n\n\nid_theme_fieldname\nstr\nThe property field name containing the unique ID for each feature.\nNone\n\n\nbase_metadata_field\nstr\nName of the attribute field that stores the existing alignment observation (JSON string). This is used to determine the last version date.\nOBSERVATION_FIELD_NAME\n\n\ngrb_type\nGRBType\nThe type of GRB reference data to align against.\nGRBType.ADP\n\n\nmax_distance_for_actualisation\nfloat\nMaximum distance (in meters) to search for potential alignments. The function checks intervals of 0.1m up to this value.\n2.0\n\n\nmax_predictions\nint\nMaximum number of alignment predictions to return. -1 returns all.\n-1\n\n\nfull_reference_strategy\nFullReferenceStrategy\nDetermines the prediction score when evaluating predictions, so predictions that are based on full-reference-geometries can be preferred.\nNO_FULL_REFERENCE\n\n\nmulti_to_best_prediction\nbool\nIf True, the prediction with the best prediction score is returned when multiple predictions are found If False, the original geometry is returned when multiple predictions are found\nTrue. Only useful when max_predictions=1\n\n\nfeedback\nAny\nFeedback object (e.g., QgsFeedback) for progress reporting and logging (in QGIS).\nNone\n\n\ncrs\nstr\nThe Coordinate Reference System for processing.\nDEFAULT_CRS\n\n\nattributes\nbool\nWhether to include the original thematic attributes in the result.\nTrue\n\n\nmax_workers\nint\nThe number of parallel threads to use for processing.\nNone",
    "crumbs": [
      "Reference",
      "GRB (Flanders-specific)",
      "grb.update_featurecollection_to_actual_grb"
    ]
  },
  {
    "objectID": "reference/grb.update_featurecollection_to_actual_grb.html#returns",
    "href": "reference/grb.update_featurecollection_to_actual_grb.html#returns",
    "title": "grb.update_featurecollection_to_actual_grb",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nDict[str, Any]\nA GeoJSON-like dictionary containing the evaluated predictions and updated alignment observations.",
    "crumbs": [
      "Reference",
      "GRB (Flanders-specific)",
      "grb.update_featurecollection_to_actual_grb"
    ]
  },
  {
    "objectID": "reference/grb.update_featurecollection_to_actual_grb.html#notes",
    "href": "reference/grb.update_featurecollection_to_actual_grb.html#notes",
    "title": "grb.update_featurecollection_to_actual_grb",
    "section": "",
    "text": "The function follows a specific lifecycle to optimize performance:\n\nInitialization: Loads thematic data and the actual GRB reference data.\nTemporal Analysis: Extracts the last_version_date from the features’ observations to determine the relevant GRB change-window.\nSpatial Filtering: Uses get_affected_by_grb_change to isolate only those geometries where the underlying GRB has actually changed.\nAlignment: Executes the Aligner.evaluate logic only on ‘affected’ features.",
    "crumbs": [
      "Reference",
      "GRB (Flanders-specific)",
      "grb.update_featurecollection_to_actual_grb"
    ]
  },
  {
    "objectID": "reference/grb.update_featurecollection_to_actual_grb.html#raises",
    "href": "reference/grb.update_featurecollection_to_actual_grb.html#raises",
    "title": "grb.update_featurecollection_to_actual_grb",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nValueError\nIf the CRS is unsupported or if the input feature collection is malformed.",
    "crumbs": [
      "Reference",
      "GRB (Flanders-specific)",
      "grb.update_featurecollection_to_actual_grb"
    ]
  },
  {
    "objectID": "reference/AlignerConfig.html",
    "href": "reference/AlignerConfig.html",
    "title": "AlignerConfig",
    "section": "",
    "text": "configs.AlignerConfig(\n    correction_distance=0.01,\n    diff_metric=DiffMetric.SYMMETRICAL_AREA_CHANGE,\n    mitre_limit=10,\n    max_workers=None,\n    log_metadata=True,\n    add_observations=True,\n)\nConfiguration for the alignment and correction of spatial boundaries.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncorrection_distance\nfloat\nThe maximum distance allowed for moving vertices during the alignment/correction phase.\n0.01\n\n\ndiff_metric\nDiffMetric\nThe metric used to calculate the difference or distance between the input geometry and the reference.\nDiffMetric.SYMMETRICAL_AREA_CHANGE\n\n\nmitre_limit\nfloat\nThe miter ratio limit for buffering. Controls the maximum length of join corners to prevent spikes in sharp angles. Corners exceeding this ratio are beveled.\n10\n\n\nmax_workers\nint\nThe maximum number of parallel worker threads/processes to use. If None, the system determines the optimal count.\nNone\n\n\nlog_metadata\nbool\nIf True, detailed metadata about the alignment process will be recorded in the logs.\nTrue",
    "crumbs": [
      "Reference",
      "Configs",
      "AlignerConfig"
    ]
  },
  {
    "objectID": "reference/AlignerConfig.html#parameters",
    "href": "reference/AlignerConfig.html#parameters",
    "title": "AlignerConfig",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ncorrection_distance\nfloat\nThe maximum distance allowed for moving vertices during the alignment/correction phase.\n0.01\n\n\ndiff_metric\nDiffMetric\nThe metric used to calculate the difference or distance between the input geometry and the reference.\nDiffMetric.SYMMETRICAL_AREA_CHANGE\n\n\nmitre_limit\nfloat\nThe miter ratio limit for buffering. Controls the maximum length of join corners to prevent spikes in sharp angles. Corners exceeding this ratio are beveled.\n10\n\n\nmax_workers\nint\nThe maximum number of parallel worker threads/processes to use. If None, the system determines the optimal count.\nNone\n\n\nlog_metadata\nbool\nIf True, detailed metadata about the alignment process will be recorded in the logs.\nTrue",
    "crumbs": [
      "Reference",
      "Configs",
      "AlignerConfig"
    ]
  },
  {
    "objectID": "reference/Evaluation.html",
    "href": "reference/Evaluation.html",
    "title": "Evaluation",
    "section": "",
    "text": "enums.Evaluation()\nClassification of the alignment quality and reliability.\nThese values help in deciding whether a change can be accepted automatically or requires manual review.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nEQUALITY_BY_ID_AND_FULL_REFERENCE\nstr\nMatch confirmed by both unique identifier and complete reference data.\n\n\nEQUALITY_BY_ID\nstr\nMatch confirmed via unique identifier only.\n\n\nEQUALITY_BY_FULL_REFERENCE\nstr\nMatch confirmed via complete reference data comparison.\n\n\nPREDICTION_UNIQUE\nstr\nA single high-confidence prediction was found.\n\n\nPREDICTION_UNIQUE_AND_FULL_REFERENCE\nstr\nA unique prediction that also matches the full reference.\n\n\nTO_CHECK_PREDICTION_FULL\nstr\nRequires review; prediction exists with full reference but lacks certainty.\n\n\nTO_CHECK_PREDICTION_MULTI\nstr\nRequires review; multiple conflicting predictions were found.\n\n\nTO_CHECK_PREDICTION_MULTI_FULL\nstr\nRequires review; multiple predictions found alongside full reference data.\n\n\nTO_CHECK_ORIGINAL\nstr\nRequires review against the original source data.\n\n\nTO_CHECK_NO_PREDICTION\nstr\nRequires review because no valid prediction could be generated.\n\n\nNOT_EVALUATED\nstr\nThe alignment has not yet been processed or evaluated.\n\n\nNO_CHANGE\nstr\nEvaluation complete; no changes were detected or required.",
    "crumbs": [
      "Reference",
      "Enumerators",
      "Evaluation"
    ]
  },
  {
    "objectID": "reference/Evaluation.html#attributes",
    "href": "reference/Evaluation.html#attributes",
    "title": "Evaluation",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nEQUALITY_BY_ID_AND_FULL_REFERENCE\nstr\nMatch confirmed by both unique identifier and complete reference data.\n\n\nEQUALITY_BY_ID\nstr\nMatch confirmed via unique identifier only.\n\n\nEQUALITY_BY_FULL_REFERENCE\nstr\nMatch confirmed via complete reference data comparison.\n\n\nPREDICTION_UNIQUE\nstr\nA single high-confidence prediction was found.\n\n\nPREDICTION_UNIQUE_AND_FULL_REFERENCE\nstr\nA unique prediction that also matches the full reference.\n\n\nTO_CHECK_PREDICTION_FULL\nstr\nRequires review; prediction exists with full reference but lacks certainty.\n\n\nTO_CHECK_PREDICTION_MULTI\nstr\nRequires review; multiple conflicting predictions were found.\n\n\nTO_CHECK_PREDICTION_MULTI_FULL\nstr\nRequires review; multiple predictions found alongside full reference data.\n\n\nTO_CHECK_ORIGINAL\nstr\nRequires review against the original source data.\n\n\nTO_CHECK_NO_PREDICTION\nstr\nRequires review because no valid prediction could be generated.\n\n\nNOT_EVALUATED\nstr\nThe alignment has not yet been processed or evaluated.\n\n\nNO_CHANGE\nstr\nEvaluation complete; no changes were detected or required.",
    "crumbs": [
      "Reference",
      "Enumerators",
      "Evaluation"
    ]
  },
  {
    "objectID": "reference/Loader.html",
    "href": "reference/Loader.html",
    "title": "Loader",
    "section": "",
    "text": "loader.Loader(is_reference)\nAbstract base class for all data loaders.\nThe Loader handles the conversion of raw spatial data into an AlignerFeatureCollection, ensuring geometries are valid and 2D.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ndata_dict\nDict[ThematicId, BaseGeometry]\nMapping of unique IDs to their corresponding Shapely geometries.\n\n\ndata_dict_properties\nDict[ThematicId, dict]\nMapping of IDs to attribute dictionaries.\n\n\ndata_dict_source\nDict[Any, str]\nMetadata regarding the data source (e.g., URL or file path).\n\n\nversiondate_info\n(dict, optional)\nConfiguration for parsing version dates, containing ‘name’ (field) and ‘format’ (strptime pattern).\n\n\nis_reference\nbool\nWhether the loaded data serves as a reference (target) layer.\n\n\n\n\n\n\nAll subclasses must implement load_data or populate the internal data dictionaries before calling the base load_data method.\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nload_data\nProcesses raw data into a validated AlignerFeatureCollection.\n\n\n\n\n\nloader.Loader.load_data()\nProcesses raw data into a validated AlignerFeatureCollection.\nThis method performs geometric validation, version date extraction, and wraps the data into AlignerFeature objects.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nAlignerFeatureCollection\nA collection of processed and validated features.\n\n\n\n\n\n\nThe processing pipeline follows these steps:\n\nGeometry Fix: Forces 2D and applies make_valid.\nMetadata Enrichment: Parses version dates if versiondate_info is set.\nFeature Creation: Generates unique UUIDs and wraps features.",
    "crumbs": [
      "Reference",
      "Loaders",
      "Loader"
    ]
  },
  {
    "objectID": "reference/Loader.html#attributes",
    "href": "reference/Loader.html#attributes",
    "title": "Loader",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\ndata_dict\nDict[ThematicId, BaseGeometry]\nMapping of unique IDs to their corresponding Shapely geometries.\n\n\ndata_dict_properties\nDict[ThematicId, dict]\nMapping of IDs to attribute dictionaries.\n\n\ndata_dict_source\nDict[Any, str]\nMetadata regarding the data source (e.g., URL or file path).\n\n\nversiondate_info\n(dict, optional)\nConfiguration for parsing version dates, containing ‘name’ (field) and ‘format’ (strptime pattern).\n\n\nis_reference\nbool\nWhether the loaded data serves as a reference (target) layer.",
    "crumbs": [
      "Reference",
      "Loaders",
      "Loader"
    ]
  },
  {
    "objectID": "reference/Loader.html#notes",
    "href": "reference/Loader.html#notes",
    "title": "Loader",
    "section": "",
    "text": "All subclasses must implement load_data or populate the internal data dictionaries before calling the base load_data method.",
    "crumbs": [
      "Reference",
      "Loaders",
      "Loader"
    ]
  },
  {
    "objectID": "reference/Loader.html#methods",
    "href": "reference/Loader.html#methods",
    "title": "Loader",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nload_data\nProcesses raw data into a validated AlignerFeatureCollection.\n\n\n\n\n\nloader.Loader.load_data()\nProcesses raw data into a validated AlignerFeatureCollection.\nThis method performs geometric validation, version date extraction, and wraps the data into AlignerFeature objects.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nAlignerFeatureCollection\nA collection of processed and validated features.\n\n\n\n\n\n\nThe processing pipeline follows these steps:\n\nGeometry Fix: Forces 2D and applies make_valid.\nMetadata Enrichment: Parses version dates if versiondate_info is set.\nFeature Creation: Generates unique UUIDs and wraps features.",
    "crumbs": [
      "Reference",
      "Loaders",
      "Loader"
    ]
  },
  {
    "objectID": "reference/FullReferenceStrategy.html",
    "href": "reference/FullReferenceStrategy.html",
    "title": "FullReferenceStrategy",
    "section": "",
    "text": "FullReferenceStrategy\nenums.FullReferenceStrategy()\nStrategy for handling reference data coverage.",
    "crumbs": [
      "Reference",
      "Enumerators",
      "FullReferenceStrategy"
    ]
  },
  {
    "objectID": "reference/loader.OSMLoader.html",
    "href": "reference/loader.OSMLoader.html",
    "title": "loader.OSMLoader",
    "section": "",
    "text": "osm.loader.OSMLoader(osm_tags, aligner)\nLoader for OpenStreetMap (OSM) features based on specific tags.\nThis loader uses the osmnx library to fetch geographical features from OpenStreetMap within a buffered bounding box of the thematic data. It automatically handles Coordinate Reference System (CRS) transformations between the project CRS and the WGS84 system required by OSM.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nosm_tags\ndict\nA dictionary of OSM tags used to filter features (e.g., {‘highway’: True} of {‘building’: ‘industrial’}).\nrequired\n\n\naligner\nAligner\nThe aligner object providing the spatial context, target CRS, and logger.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\naligner\nAligner\nReference to the parent aligner object.\n\n\nosm_tags\ndict\nThe tags used for filtering OSM data.\n\n\ndata_dict_source\ndict\nMetadata dictionary tracking the data source (“OSM”) and version date.\n\n\nversiondate_info\ndict\nDictionary specifying the version date field name and format.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nload_data\nDownload and process OSM features.\n\n\n\n\n\nosm.loader.OSMLoader.load_data()\nDownload and process OSM features.\nThe process involves: 1. Buffering the thematic union to define the search area. 2. Transforming the search area to WGS84 (EPSG:4326). 3. Fetching features via osmnx based on the provided tags. 4. Re-projecting the downloaded features back to the Aligner’s CRS.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nAny\nThe result of the parent DictLoader’s load_data method, containing the downloaded geometries and metadata.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf thematic data has not been loaded into the aligner prior to calling this method.\n\n\n\n\n\n\nThe search area is expanded using OSM_MAX_REFERENCE_BUFFER to ensure that reference features partially outside the thematic area are fully captured for alignment.",
    "crumbs": [
      "Reference",
      "OSM",
      "loader.OSMLoader"
    ]
  },
  {
    "objectID": "reference/loader.OSMLoader.html#parameters",
    "href": "reference/loader.OSMLoader.html#parameters",
    "title": "loader.OSMLoader",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nosm_tags\ndict\nA dictionary of OSM tags used to filter features (e.g., {‘highway’: True} of {‘building’: ‘industrial’}).\nrequired\n\n\naligner\nAligner\nThe aligner object providing the spatial context, target CRS, and logger.\nrequired",
    "crumbs": [
      "Reference",
      "OSM",
      "loader.OSMLoader"
    ]
  },
  {
    "objectID": "reference/loader.OSMLoader.html#attributes",
    "href": "reference/loader.OSMLoader.html#attributes",
    "title": "loader.OSMLoader",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\naligner\nAligner\nReference to the parent aligner object.\n\n\nosm_tags\ndict\nThe tags used for filtering OSM data.\n\n\ndata_dict_source\ndict\nMetadata dictionary tracking the data source (“OSM”) and version date.\n\n\nversiondate_info\ndict\nDictionary specifying the version date field name and format.",
    "crumbs": [
      "Reference",
      "OSM",
      "loader.OSMLoader"
    ]
  },
  {
    "objectID": "reference/loader.OSMLoader.html#methods",
    "href": "reference/loader.OSMLoader.html#methods",
    "title": "loader.OSMLoader",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nload_data\nDownload and process OSM features.\n\n\n\n\n\nosm.loader.OSMLoader.load_data()\nDownload and process OSM features.\nThe process involves: 1. Buffering the thematic union to define the search area. 2. Transforming the search area to WGS84 (EPSG:4326). 3. Fetching features via osmnx based on the provided tags. 4. Re-projecting the downloaded features back to the Aligner’s CRS.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nAny\nThe result of the parent DictLoader’s load_data method, containing the downloaded geometries and metadata.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf thematic data has not been loaded into the aligner prior to calling this method.\n\n\n\n\n\n\nThe search area is expanded using OSM_MAX_REFERENCE_BUFFER to ensure that reference features partially outside the thematic area are fully captured for alignment.",
    "crumbs": [
      "Reference",
      "OSM",
      "loader.OSMLoader"
    ]
  },
  {
    "objectID": "reference/utils.get_affected_ids_by_grb_change.html",
    "href": "reference/utils.get_affected_ids_by_grb_change.html",
    "title": "utils.get_affected_ids_by_grb_change",
    "section": "",
    "text": "utils.get_affected_ids_by_grb_change\nbe.grb.utils.get_affected_ids_by_grb_change(\n    thematic_geometries,\n    *,\n    grb_type=GRBType.ADP,\n    date_start=date.today(),\n    date_end=date.today(),\n    one_by_one=False,\n    border_distance=0,\n    geometry_thematic_union=None,\n    crs=DEFAULT_CRS,\n)\nGet a list of affected IDs by GRB-changes in a specific timespan\nArgs: thematic_geometries: dictionary if thematicID & Geometry grb_type: Type of GRB: parcels, buildings,… date_start: start-date to check changes in GRB date_end: end-date to check changes in GRB one_by_one: parameter to choose the methodology to check changes: * True: Every thematic geometry is checked individually (loop) * False: All GRB-parcels intersecting the thematic dictionary are checked at once (Default: False) border_distance: Distance that can be used to only check the ‘border’ of the geometry, so ‘big’ geometries with internal parcel-updates are not affected (Default:0, indicating that the full geometry is checked for GRB-changes) Returns: list of affected IDs",
    "crumbs": [
      "Reference",
      "GRB (Flanders-specific)",
      "utils.get_affected_ids_by_grb_change"
    ]
  },
  {
    "objectID": "reference/SnapStrategy.html",
    "href": "reference/SnapStrategy.html",
    "title": "SnapStrategy",
    "section": "",
    "text": "SnapStrategy\nenums.SnapStrategy()\nGeometric priority during snapping.",
    "crumbs": [
      "Reference",
      "Enumerators",
      "SnapStrategy"
    ]
  },
  {
    "objectID": "reference/Aligner.html",
    "href": "reference/Aligner.html",
    "title": "Aligner",
    "section": "",
    "text": "aligner.Aligner(processor=None, crs=DEFAULT_CRS, config=None, feedback=None)\nCompares and aligns thematic geospatial data against a set of reference data.\nThe Aligner manages the loading of both thematic and reference data, configures the geometric processing rules, and executes the alignment, prediction, and evaluation logic across a series of relevant distances.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlogger\nLogger\nInstance for logging feedback and information.\n\n\nlog_metadata\nbool\nIf True, metadata about the actuation is logged in the results.\n\n\nadd_observations\nbool\nIf True, process result observations will be computed by default.\n\n\nprocessor\nBaseProcessor or AlignerGeometryProcessor\nThe geometric processor used for alignment calculations.\n\n\ncorrection_distance\nfloat\nDistance used in buffer operations to remove slivers (technical correction).\n\n\nmitre_limit\nint\nParameter for the buffer operation to control the maximum length of join corners.\n\n\nmax_workers\n(int, optional)\nThe maximum number of workers for parallel execution (ThreadPoolExecutor).\n\n\ncrs\nstr\nThe Coordinate Reference System (CRS) being used (bv. ‘EPSG:31370’).\n\n\nname_thematic_id\nstr\nName of the identifier field for thematic data.\n\n\ndiff_metric\nDiffMetric\nThe metric used to measure differences between geometries (bv. area change).\n\n\nreference_data\n(AlignerFeatureCollection, optional)\nLoaded collection of reference features.\n\n\nthematic_data\n(AlignerFeatureCollection, optional)\nLoaded collection of thematic features.\n\n\n\n\n\n\nThe Aligner acts as the central orchestrator of the brdr package. It connects data loaders with geometric processors.\n\n\n\n\n\ngraph LR\n    T[Thematic Data] --&gt; Aligner\n    R[Reference Data] --&gt; Aligner\n    Aligner --&gt; P{Processor}\n    P --&gt; Res[AlignerResult]\n\n\n\n\n\n\n\n\n\n&gt;&gt;&gt; from brdr.aligner import Aligner\n&gt;&gt;&gt; aligner = Aligner(crs=\"EPSG:31370\")\n&gt;&gt;&gt; aligner.load_thematic_data(my_features)\n&gt;&gt;&gt; results = aligner.align(relevant_distances=[0.5, 1.0])\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompare_to_reference\nCalculates observation-related information based on the input geometry.\n\n\nevaluate\nEvaluates input geometries against predictions using observation matching\n\n\nget_difference_metrics_for_thematic_data\nCalculates difference metrics for thematic elements across a series of distances.\n\n\nload_reference_data\nLoads the reference features into the aligner and prepares them for processing.\n\n\nload_thematic_data\nLoads the thematic features into the aligner using a specific loader.\n\n\npredict\nPredicts the ‘most interesting’ relevant distances for changes in thematic\n\n\nprocess\nExecutes the alignment process across multiple relevant distances.\n\n\n\n\n\naligner.Aligner.compare_to_reference(geometry, with_geom=False)\nCalculates observation-related information based on the input geometry.\nThis method performs a spatial analysis to determine how much of the input geometry is covered by reference features and identifies which specific reference elements are involved. It also detects “OD” (Onbekend Terrein/Open Space) areas that are not covered by any reference data.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ngeometry\nBaseGeometry\nThe input geometry to be analyzed against the reference dataset.\nrequired\n\n\nwith_geom\nbool\nIf True, includes the GeoJSON representation of each intersection and the OD-area in the output. Defaults to False.\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[str, Any]\nA dictionary containing the alignment analysis: - alignment_date (str): Timestamp of the calculation. - brdr_version (str): Version of the package used. - full (bool): True if the geometry is entirely composed of complete reference features. - area (float): Total area of the input geometry. - last_version_date (str, optional): The most recent version date found among the intersected reference features. - reference_features (dict): A mapping of reference IDs to: - full (bool): True if the reference feature is fully contained. - area (float): Area of the intersection. - percentage (float): Coverage percentage relative to the reference. - geometry (str, optional): GeoJSON string (if with_geom is True). - reference_od (dict, optional): Description of areas not covered by reference features, containing ‘area’ and optionally ‘geometry’.\n\n\n\n\n\n\nThe method uses a spatial index (R-tree) to efficiently find intersecting reference features. A correction distance is applied to the “OD” calculation to filter out insignificant slivers.\n\n\n\n\n\ngraph TD\n    In[Input Geometry] --&gt; Query[Spatial Index Query]\n    Query --&gt; Intersect[Calculate Intersections]\n    Intersect --&gt; Stats[Compute Area & %]\n    In --&gt; Diff[Difference with Union of Refs]\n    Diff --&gt; OD[Identify Unknown Area / OD]\n    Stats --&gt; Dict[Final observation Dictionary]\n    OD --&gt; Dict\n\n\n\n\n\n\n\n\n\n&gt;&gt;&gt; info = aligner.compare_to_reference(my_geom, with_geom=True)\n&gt;&gt;&gt; print(info[\"full\"])\n&gt;&gt;&gt; print(info[\"reference_features\"].keys())  # IDs of intersected refs\n\n\n\n\naligner.Aligner.evaluate(\n    relevant_distances=None,\n    *,\n    thematic_ids=None,\n    metadata_field=METADATA_FIELD_NAME,\n    full_reference_strategy=FullReferenceStrategy.NO_FULL_REFERENCE,\n    max_predictions=-1,\n    multi_to_best_prediction=True,\n)\nEvaluates input geometries against predictions using observation matching and selection strategies.\nThis method identifies the best candidate geometries for alignment by comparing predicted geometries against the original attributes and reference data. It tags results with evaluation labels (e.g., PREDICTION_UNIQUE) to facilitate decision-making.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrelevant_distances\nIterable[float]\nDistances to evaluate. Defaults to 0.0m to 3.0m (step 0.1m).\nNone\n\n\nthematic_ids\nList[ThematicId]\nList of IDs to evaluate. If None, all loaded thematic features are processed. Features not in this list are marked as NOT_EVALUATED.\nNone\n\n\nmetadata_field\nstr\nThe field name containing the metadata of the input geometry. Defaults to METADATA_FIELD_NAME.\nMETADATA_FIELD_NAME\n\n\nfull_reference_strategy\nFullReferenceStrategy\nStrategy to prioritize predictions based on their ‘fullness’ relative to reference data. Defaults to NO_FULL_REFERENCE.\nFullReferenceStrategy.NO_FULL_REFERENCE\n\n\nmax_predictions\nint\nMaximum number of predictions to return per feature. -1 returns all candidates. Defaults to -1.\n-1\n\n\nmulti_to_best_prediction\nbool\nIf True and max_predictions=1, returns the candidate with the highest score. If False, returns the original geometry when multiple candidates exist. Defaults to True.\nTrue\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nAlignerResult\nAn object containing evaluated results with detailed metadata and evaluation status tags.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf provided thematic_ids are not present in the thematic data.\n\n\n\n\n\n\nThe evaluation logic follows a specific priority tree: 1. observation Match: If a prediction matches the base observation exactly, it is prioritized (score 100). 2. Fullness: If a strategy is set, ‘full’ predictions get a score boost. 3. Scoring: Candidates are ranked by their prediction score. 4. Selection: Based on max_predictions, the best candidates are selected.\n\n\n\n\n\ngraph TD\n    Start[Start Evaluation] --&gt; Pred[Generate Predictions]\n    Pred --&gt; Match{observation Match?}\n    Match -- Yes --&gt; HighScore[Prioritize & Score 100]\n    Match -- No --&gt; Full{Full Reference?}\n    Full -- Yes --&gt; Strategy[Apply Fullness Strategy]\n    Full -- No --&gt; Rank[Rank by Prediction Score]\n    Strategy --&gt; Rank\n    HighScore --&gt; Rank\n    Rank --&gt; Select{Max Predictions?}\n    Select --&gt; Final[Return AlignerResult]\n\n\n\n\n\n\n\n\n\n&gt;&gt;&gt; aligner = Aligner()\n&gt;&gt;&gt; # Evaluate with a limit of 1 best prediction per feature\n&gt;&gt;&gt; results = aligner.evaluate(thematic_ids=[\"id_01\"],full_reference_strategy=FullReferenceStrategy.ONLY_FULL_REFERENCE,max_predictions=1)\n\n\n\n\naligner.Aligner.get_difference_metrics_for_thematic_data(\n    dict_processresults=None,\n    thematic_data=None,\n    diff_metric=DiffMetric.SYMMETRICAL_AREA_CHANGE,\n)\nCalculates difference metrics for thematic elements across a series of distances.\nThis method iterates through the processed results and compares the resulting geometries against their original thematic counterparts. It uses the spatial context of the reference data to calculate metrics like area change or symmetrical difference.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndict_processresults\nDict[ThematicId, Dict[float, Optional[ProcessResult]]]\nA nested dictionary where keys are thematic IDs and values are dictionaries mapping relevant distances to ProcessResult[] objects. Required if not provided via internal state.\nNone\n\n\nthematic_data\nAlignerFeatureCollection\nThe collection containing the original thematic geometries. Defaults to self.thematic_data.\nNone\n\n\ndiff_metric\nDiffMetric\nThe metric used to quantify the geometric change. Defaults to DiffMetric.SYMMETRICAL_AREA_CHANGE.\nDiffMetric.SYMMETRICAL_AREA_CHANGE\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[ThematicId, Dict[float, float]]\nA nested dictionary where each thematic ID maps to a dictionary of distances and their corresponding calculated metric values.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf dict_processresults is not provided and cannot be resolved.\n\n\n\n\n\n\nThe calculation involves three primary geometric components: 1. Original Geometry: The thematic feature before alignment. 2. Result Geometry: The feature after alignment at a specific distance. 3. Reference Union: The combined geometry of all reference data, used to contextualize the change.\n\n\n\n\n\ngraph LR\n    PR[Process Results] --&gt; Calc[Metric Calculator]\n    Orig[Original Geometries] --&gt; Calc\n    Ref[Reference Union] --&gt; Calc\n    Calc --&gt; Output[Distance-Metric Map]\n\n\n\n\n\n\n\n\n\n&gt;&gt;&gt; metrics = aligner.get_difference_metrics_for_thematic_data(\n...     dict_processresults=my_results,\n...     diff_metric=DiffMetric.AREA_CHANGE\n... )\n&gt;&gt;&gt; # Get area change for feature 'A' at distance 0.5\n&gt;&gt;&gt; print(metrics['A'][0.5])\n\n### load_reference_data { #brdr.aligner.Aligner.load_reference_data }\n\n```python\naligner.Aligner.load_reference_data(loader)\nLoads the reference features into the aligner and prepares them for processing.\nThis method retrieves data via the provided loader, synchronizes the CRS, and marks the feature collection as a reference dataset to enable spatial indexing and comparison logic.\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nloader\nLoader\nAn instance of a Loader class (e.g., WFSReferenceLoader) that implements the load_data interface.\nrequired\n\n\n\n\n\n\nSetting is_reference = True on the resulting dataset is essential for the internal alignment logic, as it distinguishes the ‘anchor’ geometries from the thematic geometries that need to be shifted.\n\n\n\n&gt;&gt;&gt; from brdr.loader import WFSReferenceLoader\n&gt;&gt;&gt; ref_loader = WFSReferenceLoader(url=\"https://geoserver.com/wfs\")\n&gt;&gt;&gt; aligner.load_reference_data(ref_loader)\n&gt;&gt;&gt; print(aligner.reference_data.is_reference)\nTrue\n\n\n\n\naligner.Aligner.load_thematic_data(loader)\nLoads the thematic features into the aligner using a specific loader.\nThis method executes the loader’s data retrieval logic and ensures that the resulting feature collection is tagged with the Aligner’s CRS.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nloader\nLoader\nAn instance of a Loader class (e.g., GeoJsonLoader or WFSReferenceLoader) that implements the load_data interface.\nrequired\n\n\n\n\n\n\nThe method automatically synchronizes the CRS of the loaded data with the self.crs attribute of the Aligner instance.\n\n\n\n&gt;&gt;&gt; from brdr.loader import GeoJsonLoader\n&gt;&gt;&gt; loader = GeoJsonLoader(path=\"data/themes.json\")\n&gt;&gt;&gt; aligner.load_thematic_data(loader)\n\n\n\n\naligner.Aligner.predict(\n    relevant_distances=None,\n    *,\n    thematic_ids=None,\n    diff_metric=None,\n)\nPredicts the ‘most interesting’ relevant distances for changes in thematic elements.\nThis method analyzes the stability of geometric differences across a range of distances. It identifies “breakpoints” where changes occur and “zero-streaks” where the geometry remains stable. Based on this, a prediction score is assigned to specific results.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrelevant_distances\nList[float] or np.ndarray\nA series of distances (in meters) to be analyzed. Defaults to a range from 0.0 to 3.0 meters with steps of 0.1m.\nNone\n\n\nthematic_ids\nList[ThematicId]\nSpecific thematic IDs to process. If None, all loaded thematic geometries are used.\nNone\n\n\ndiff_metric\nDiffMetric\nThe metric used to determine differences (e.g., area change). If None, the Aligner’s default diff_metric is used.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nAlignerResult\nA result object containing the process results enriched with stability properties and prediction scores.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf provided thematic_ids are not found in the loaded data.\n\n\n\n\n\n\nThe prediction logic follows a four-step process: 1. Series Processing: Calculates results for all specified distances. 2. Metric Calculation: Computes the difference between original and result for each step. 3. Stability Analysis: Identifies streaks where the change is minimal (zero-streaks) or where the metric flips sign (breakpoints). 4. Scoring: Assigns a PREDICTION_SCORE to results that fall within a significant stability window.\n\n\n\n\n\ngraph TD\n    A[Input Distances] --&gt; B[Process Series]\n    B --&gt; C[Calculate Diffs]\n    C --&gt; D[Stability Analysis]\n    D --&gt; E{Stable?}\n    E -- Yes --&gt; F[Assign Prediction Score]\n    E -- No --&gt; G[Mark unstable]\n    F --&gt; H[AlignerResult]\n    G --&gt; H\n\n\n\n\n\n\n\n\n\n&gt;&gt;&gt; aligner = Aligner(crs=\"EPSG:31370\")\n&gt;&gt;&gt; # Predict using default distance range\n&gt;&gt;&gt; prediction_results = aligner.predict(thematic_ids=[\"id_1\", \"id_2\"])\n\n\n\n\naligner.Aligner.process(\n    relevant_distances=None,\n    *,\n    thematic_ids=None,\n    max_workers=None,\n)\nExecutes the alignment process across multiple relevant distances.\nThis method iterates through the specified thematic features and calculates the alignment for each provided ‘relevant distance’. It can utilize parallel processing via a ThreadPoolExecutor to speed up calculations.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrelevant_distances\nIterable[float]\nA series of distances (in meters) to use for the alignment logic. This parameter is mandatory.\nNone\n\n\nthematic_ids\nList[ThematicId]\nA specific list of IDs to process. If None, all thematic features currently loaded in the aligner will be processed.\nNone\n\n\nmax_workers\nint\nThe number of threads for parallel execution. If -1, execution is serial. If None, the Aligner’s default max_workers is used.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n[AlignerResult][]\nAn object containing the structured results, accessible by thematic ID and relevant distance.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf relevant_distances is None or empty. If any provided thematic_ids are not found in the loaded thematic data.\n\n\n\n\n\n\nThe processing flow involves distributing geometry-distance pairs across available worker threads:\n\n\n\n\n\ngraph TD\n    Start[Process Call] --&gt; Check{Valid IDs?}\n    Check -- Yes --&gt; Parallel{max_workers &gt; 0?}\n    Parallel -- Yes --&gt; Workers[ThreadPoolExecutor]\n    Parallel -- No --&gt; Serial[Single Thread]\n    Workers --&gt; Proc[Geometry Processor]\n    Serial --&gt; Proc\n    Proc --&gt; Result[AlignerResult]\n\n\n\n\n\n\n\n\n\n&gt;&gt;&gt; aligner.process(relevant_distances=[0, 0.5, 1.0], max_workers=4)\n&lt;brdr.aligner.AlignerResult object at ...&gt;",
    "crumbs": [
      "Reference",
      "Aligner",
      "Aligner"
    ]
  },
  {
    "objectID": "reference/Aligner.html#attributes",
    "href": "reference/Aligner.html#attributes",
    "title": "Aligner",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nlogger\nLogger\nInstance for logging feedback and information.\n\n\nlog_metadata\nbool\nIf True, metadata about the actuation is logged in the results.\n\n\nadd_observations\nbool\nIf True, process result observations will be computed by default.\n\n\nprocessor\nBaseProcessor or AlignerGeometryProcessor\nThe geometric processor used for alignment calculations.\n\n\ncorrection_distance\nfloat\nDistance used in buffer operations to remove slivers (technical correction).\n\n\nmitre_limit\nint\nParameter for the buffer operation to control the maximum length of join corners.\n\n\nmax_workers\n(int, optional)\nThe maximum number of workers for parallel execution (ThreadPoolExecutor).\n\n\ncrs\nstr\nThe Coordinate Reference System (CRS) being used (bv. ‘EPSG:31370’).\n\n\nname_thematic_id\nstr\nName of the identifier field for thematic data.\n\n\ndiff_metric\nDiffMetric\nThe metric used to measure differences between geometries (bv. area change).\n\n\nreference_data\n(AlignerFeatureCollection, optional)\nLoaded collection of reference features.\n\n\nthematic_data\n(AlignerFeatureCollection, optional)\nLoaded collection of thematic features.",
    "crumbs": [
      "Reference",
      "Aligner",
      "Aligner"
    ]
  },
  {
    "objectID": "reference/Aligner.html#notes",
    "href": "reference/Aligner.html#notes",
    "title": "Aligner",
    "section": "",
    "text": "The Aligner acts as the central orchestrator of the brdr package. It connects data loaders with geometric processors.\n\n\n\n\n\ngraph LR\n    T[Thematic Data] --&gt; Aligner\n    R[Reference Data] --&gt; Aligner\n    Aligner --&gt; P{Processor}\n    P --&gt; Res[AlignerResult]",
    "crumbs": [
      "Reference",
      "Aligner",
      "Aligner"
    ]
  },
  {
    "objectID": "reference/Aligner.html#examples",
    "href": "reference/Aligner.html#examples",
    "title": "Aligner",
    "section": "",
    "text": "&gt;&gt;&gt; from brdr.aligner import Aligner\n&gt;&gt;&gt; aligner = Aligner(crs=\"EPSG:31370\")\n&gt;&gt;&gt; aligner.load_thematic_data(my_features)\n&gt;&gt;&gt; results = aligner.align(relevant_distances=[0.5, 1.0])",
    "crumbs": [
      "Reference",
      "Aligner",
      "Aligner"
    ]
  },
  {
    "objectID": "reference/Aligner.html#methods",
    "href": "reference/Aligner.html#methods",
    "title": "Aligner",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncompare_to_reference\nCalculates observation-related information based on the input geometry.\n\n\nevaluate\nEvaluates input geometries against predictions using observation matching\n\n\nget_difference_metrics_for_thematic_data\nCalculates difference metrics for thematic elements across a series of distances.\n\n\nload_reference_data\nLoads the reference features into the aligner and prepares them for processing.\n\n\nload_thematic_data\nLoads the thematic features into the aligner using a specific loader.\n\n\npredict\nPredicts the ‘most interesting’ relevant distances for changes in thematic\n\n\nprocess\nExecutes the alignment process across multiple relevant distances.\n\n\n\n\n\naligner.Aligner.compare_to_reference(geometry, with_geom=False)\nCalculates observation-related information based on the input geometry.\nThis method performs a spatial analysis to determine how much of the input geometry is covered by reference features and identifies which specific reference elements are involved. It also detects “OD” (Onbekend Terrein/Open Space) areas that are not covered by any reference data.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ngeometry\nBaseGeometry\nThe input geometry to be analyzed against the reference dataset.\nrequired\n\n\nwith_geom\nbool\nIf True, includes the GeoJSON representation of each intersection and the OD-area in the output. Defaults to False.\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[str, Any]\nA dictionary containing the alignment analysis: - alignment_date (str): Timestamp of the calculation. - brdr_version (str): Version of the package used. - full (bool): True if the geometry is entirely composed of complete reference features. - area (float): Total area of the input geometry. - last_version_date (str, optional): The most recent version date found among the intersected reference features. - reference_features (dict): A mapping of reference IDs to: - full (bool): True if the reference feature is fully contained. - area (float): Area of the intersection. - percentage (float): Coverage percentage relative to the reference. - geometry (str, optional): GeoJSON string (if with_geom is True). - reference_od (dict, optional): Description of areas not covered by reference features, containing ‘area’ and optionally ‘geometry’.\n\n\n\n\n\n\nThe method uses a spatial index (R-tree) to efficiently find intersecting reference features. A correction distance is applied to the “OD” calculation to filter out insignificant slivers.\n\n\n\n\n\ngraph TD\n    In[Input Geometry] --&gt; Query[Spatial Index Query]\n    Query --&gt; Intersect[Calculate Intersections]\n    Intersect --&gt; Stats[Compute Area & %]\n    In --&gt; Diff[Difference with Union of Refs]\n    Diff --&gt; OD[Identify Unknown Area / OD]\n    Stats --&gt; Dict[Final observation Dictionary]\n    OD --&gt; Dict\n\n\n\n\n\n\n\n\n\n&gt;&gt;&gt; info = aligner.compare_to_reference(my_geom, with_geom=True)\n&gt;&gt;&gt; print(info[\"full\"])\n&gt;&gt;&gt; print(info[\"reference_features\"].keys())  # IDs of intersected refs\n\n\n\n\naligner.Aligner.evaluate(\n    relevant_distances=None,\n    *,\n    thematic_ids=None,\n    metadata_field=METADATA_FIELD_NAME,\n    full_reference_strategy=FullReferenceStrategy.NO_FULL_REFERENCE,\n    max_predictions=-1,\n    multi_to_best_prediction=True,\n)\nEvaluates input geometries against predictions using observation matching and selection strategies.\nThis method identifies the best candidate geometries for alignment by comparing predicted geometries against the original attributes and reference data. It tags results with evaluation labels (e.g., PREDICTION_UNIQUE) to facilitate decision-making.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrelevant_distances\nIterable[float]\nDistances to evaluate. Defaults to 0.0m to 3.0m (step 0.1m).\nNone\n\n\nthematic_ids\nList[ThematicId]\nList of IDs to evaluate. If None, all loaded thematic features are processed. Features not in this list are marked as NOT_EVALUATED.\nNone\n\n\nmetadata_field\nstr\nThe field name containing the metadata of the input geometry. Defaults to METADATA_FIELD_NAME.\nMETADATA_FIELD_NAME\n\n\nfull_reference_strategy\nFullReferenceStrategy\nStrategy to prioritize predictions based on their ‘fullness’ relative to reference data. Defaults to NO_FULL_REFERENCE.\nFullReferenceStrategy.NO_FULL_REFERENCE\n\n\nmax_predictions\nint\nMaximum number of predictions to return per feature. -1 returns all candidates. Defaults to -1.\n-1\n\n\nmulti_to_best_prediction\nbool\nIf True and max_predictions=1, returns the candidate with the highest score. If False, returns the original geometry when multiple candidates exist. Defaults to True.\nTrue\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nAlignerResult\nAn object containing evaluated results with detailed metadata and evaluation status tags.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf provided thematic_ids are not present in the thematic data.\n\n\n\n\n\n\nThe evaluation logic follows a specific priority tree: 1. observation Match: If a prediction matches the base observation exactly, it is prioritized (score 100). 2. Fullness: If a strategy is set, ‘full’ predictions get a score boost. 3. Scoring: Candidates are ranked by their prediction score. 4. Selection: Based on max_predictions, the best candidates are selected.\n\n\n\n\n\ngraph TD\n    Start[Start Evaluation] --&gt; Pred[Generate Predictions]\n    Pred --&gt; Match{observation Match?}\n    Match -- Yes --&gt; HighScore[Prioritize & Score 100]\n    Match -- No --&gt; Full{Full Reference?}\n    Full -- Yes --&gt; Strategy[Apply Fullness Strategy]\n    Full -- No --&gt; Rank[Rank by Prediction Score]\n    Strategy --&gt; Rank\n    HighScore --&gt; Rank\n    Rank --&gt; Select{Max Predictions?}\n    Select --&gt; Final[Return AlignerResult]\n\n\n\n\n\n\n\n\n\n&gt;&gt;&gt; aligner = Aligner()\n&gt;&gt;&gt; # Evaluate with a limit of 1 best prediction per feature\n&gt;&gt;&gt; results = aligner.evaluate(thematic_ids=[\"id_01\"],full_reference_strategy=FullReferenceStrategy.ONLY_FULL_REFERENCE,max_predictions=1)\n\n\n\n\naligner.Aligner.get_difference_metrics_for_thematic_data(\n    dict_processresults=None,\n    thematic_data=None,\n    diff_metric=DiffMetric.SYMMETRICAL_AREA_CHANGE,\n)\nCalculates difference metrics for thematic elements across a series of distances.\nThis method iterates through the processed results and compares the resulting geometries against their original thematic counterparts. It uses the spatial context of the reference data to calculate metrics like area change or symmetrical difference.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndict_processresults\nDict[ThematicId, Dict[float, Optional[ProcessResult]]]\nA nested dictionary where keys are thematic IDs and values are dictionaries mapping relevant distances to ProcessResult[] objects. Required if not provided via internal state.\nNone\n\n\nthematic_data\nAlignerFeatureCollection\nThe collection containing the original thematic geometries. Defaults to self.thematic_data.\nNone\n\n\ndiff_metric\nDiffMetric\nThe metric used to quantify the geometric change. Defaults to DiffMetric.SYMMETRICAL_AREA_CHANGE.\nDiffMetric.SYMMETRICAL_AREA_CHANGE\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[ThematicId, Dict[float, float]]\nA nested dictionary where each thematic ID maps to a dictionary of distances and their corresponding calculated metric values.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf dict_processresults is not provided and cannot be resolved.\n\n\n\n\n\n\nThe calculation involves three primary geometric components: 1. Original Geometry: The thematic feature before alignment. 2. Result Geometry: The feature after alignment at a specific distance. 3. Reference Union: The combined geometry of all reference data, used to contextualize the change.\n\n\n\n\n\ngraph LR\n    PR[Process Results] --&gt; Calc[Metric Calculator]\n    Orig[Original Geometries] --&gt; Calc\n    Ref[Reference Union] --&gt; Calc\n    Calc --&gt; Output[Distance-Metric Map]\n\n\n\n\n\n\n\n\n\n&gt;&gt;&gt; metrics = aligner.get_difference_metrics_for_thematic_data(\n...     dict_processresults=my_results,\n...     diff_metric=DiffMetric.AREA_CHANGE\n... )\n&gt;&gt;&gt; # Get area change for feature 'A' at distance 0.5\n&gt;&gt;&gt; print(metrics['A'][0.5])\n\n### load_reference_data { #brdr.aligner.Aligner.load_reference_data }\n\n```python\naligner.Aligner.load_reference_data(loader)\nLoads the reference features into the aligner and prepares them for processing.\nThis method retrieves data via the provided loader, synchronizes the CRS, and marks the feature collection as a reference dataset to enable spatial indexing and comparison logic.\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nloader\nLoader\nAn instance of a Loader class (e.g., WFSReferenceLoader) that implements the load_data interface.\nrequired\n\n\n\n\n\n\nSetting is_reference = True on the resulting dataset is essential for the internal alignment logic, as it distinguishes the ‘anchor’ geometries from the thematic geometries that need to be shifted.\n\n\n\n&gt;&gt;&gt; from brdr.loader import WFSReferenceLoader\n&gt;&gt;&gt; ref_loader = WFSReferenceLoader(url=\"https://geoserver.com/wfs\")\n&gt;&gt;&gt; aligner.load_reference_data(ref_loader)\n&gt;&gt;&gt; print(aligner.reference_data.is_reference)\nTrue\n\n\n\n\naligner.Aligner.load_thematic_data(loader)\nLoads the thematic features into the aligner using a specific loader.\nThis method executes the loader’s data retrieval logic and ensures that the resulting feature collection is tagged with the Aligner’s CRS.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nloader\nLoader\nAn instance of a Loader class (e.g., GeoJsonLoader or WFSReferenceLoader) that implements the load_data interface.\nrequired\n\n\n\n\n\n\nThe method automatically synchronizes the CRS of the loaded data with the self.crs attribute of the Aligner instance.\n\n\n\n&gt;&gt;&gt; from brdr.loader import GeoJsonLoader\n&gt;&gt;&gt; loader = GeoJsonLoader(path=\"data/themes.json\")\n&gt;&gt;&gt; aligner.load_thematic_data(loader)\n\n\n\n\naligner.Aligner.predict(\n    relevant_distances=None,\n    *,\n    thematic_ids=None,\n    diff_metric=None,\n)\nPredicts the ‘most interesting’ relevant distances for changes in thematic elements.\nThis method analyzes the stability of geometric differences across a range of distances. It identifies “breakpoints” where changes occur and “zero-streaks” where the geometry remains stable. Based on this, a prediction score is assigned to specific results.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrelevant_distances\nList[float] or np.ndarray\nA series of distances (in meters) to be analyzed. Defaults to a range from 0.0 to 3.0 meters with steps of 0.1m.\nNone\n\n\nthematic_ids\nList[ThematicId]\nSpecific thematic IDs to process. If None, all loaded thematic geometries are used.\nNone\n\n\ndiff_metric\nDiffMetric\nThe metric used to determine differences (e.g., area change). If None, the Aligner’s default diff_metric is used.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nAlignerResult\nA result object containing the process results enriched with stability properties and prediction scores.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf provided thematic_ids are not found in the loaded data.\n\n\n\n\n\n\nThe prediction logic follows a four-step process: 1. Series Processing: Calculates results for all specified distances. 2. Metric Calculation: Computes the difference between original and result for each step. 3. Stability Analysis: Identifies streaks where the change is minimal (zero-streaks) or where the metric flips sign (breakpoints). 4. Scoring: Assigns a PREDICTION_SCORE to results that fall within a significant stability window.\n\n\n\n\n\ngraph TD\n    A[Input Distances] --&gt; B[Process Series]\n    B --&gt; C[Calculate Diffs]\n    C --&gt; D[Stability Analysis]\n    D --&gt; E{Stable?}\n    E -- Yes --&gt; F[Assign Prediction Score]\n    E -- No --&gt; G[Mark unstable]\n    F --&gt; H[AlignerResult]\n    G --&gt; H\n\n\n\n\n\n\n\n\n\n&gt;&gt;&gt; aligner = Aligner(crs=\"EPSG:31370\")\n&gt;&gt;&gt; # Predict using default distance range\n&gt;&gt;&gt; prediction_results = aligner.predict(thematic_ids=[\"id_1\", \"id_2\"])\n\n\n\n\naligner.Aligner.process(\n    relevant_distances=None,\n    *,\n    thematic_ids=None,\n    max_workers=None,\n)\nExecutes the alignment process across multiple relevant distances.\nThis method iterates through the specified thematic features and calculates the alignment for each provided ‘relevant distance’. It can utilize parallel processing via a ThreadPoolExecutor to speed up calculations.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrelevant_distances\nIterable[float]\nA series of distances (in meters) to use for the alignment logic. This parameter is mandatory.\nNone\n\n\nthematic_ids\nList[ThematicId]\nA specific list of IDs to process. If None, all thematic features currently loaded in the aligner will be processed.\nNone\n\n\nmax_workers\nint\nThe number of threads for parallel execution. If -1, execution is serial. If None, the Aligner’s default max_workers is used.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n[AlignerResult][]\nAn object containing the structured results, accessible by thematic ID and relevant distance.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf relevant_distances is None or empty. If any provided thematic_ids are not found in the loaded thematic data.\n\n\n\n\n\n\nThe processing flow involves distributing geometry-distance pairs across available worker threads:\n\n\n\n\n\ngraph TD\n    Start[Process Call] --&gt; Check{Valid IDs?}\n    Check -- Yes --&gt; Parallel{max_workers &gt; 0?}\n    Parallel -- Yes --&gt; Workers[ThreadPoolExecutor]\n    Parallel -- No --&gt; Serial[Single Thread]\n    Workers --&gt; Proc[Geometry Processor]\n    Serial --&gt; Proc\n    Proc --&gt; Result[AlignerResult]\n\n\n\n\n\n\n\n\n\n&gt;&gt;&gt; aligner.process(relevant_distances=[0, 0.5, 1.0], max_workers=4)\n&lt;brdr.aligner.AlignerResult object at ...&gt;",
    "crumbs": [
      "Reference",
      "Aligner",
      "Aligner"
    ]
  },
  {
    "objectID": "reference/GeoJsonUrlLoader.html",
    "href": "reference/GeoJsonUrlLoader.html",
    "title": "GeoJsonUrlLoader",
    "section": "",
    "text": "GeoJsonUrlLoader\nloader.GeoJsonUrlLoader(url, id_property, is_reference=False)\nLoads GeoJSON data from a remote URL via HTTP GET.",
    "crumbs": [
      "Reference",
      "Loaders",
      "GeoJsonUrlLoader"
    ]
  },
  {
    "objectID": "reference/DieussaertGeometryProcessor.html",
    "href": "reference/DieussaertGeometryProcessor.html",
    "title": "DieussaertGeometryProcessor",
    "section": "",
    "text": "processor.DieussaertGeometryProcessor(config, feedback=None)\nProcessor implementing the Dieussaert area-based alignment algorithm.\nUnlike vertex snapping, this processor evaluates the overlap between thematic geometries and reference polygons. It decides per reference feature whether to include it fully, partially, or exclude it based on area-based thresholds.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nprocessor_id\nProcessorID\nThe unique identifier for this processor (ProcessorID.DIEUSSAERT).\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nprocess\nCoordinates the alignment process for single or multi-geometries.\n\n\n\n\n\nprocessor.DieussaertGeometryProcessor.process(\n    input_geometry,\n    reference_data,\n    relevant_distance,\n    mitre_limit,\n    correction_distance,\n    **kwargs,\n)\nCoordinates the alignment process for single or multi-geometries.\nIf multi_as_single_modus is disabled, MultiPolygons are processed piecewise and merged afterward to ensure stability.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput_geometry\nBaseGeometry\nThe thematic geometry to align.\nrequired\n\n\nreference_data\nAlignerFeatureCollection\nThe reference (target) dataset.\nrequired\n\n\nrelevant_distance\nfloat\nThe distance threshold for alignment decisions.\nrequired\n\n\nmitre_limit\nfloat\nMitre limit for buffering operations.\nrequired\n\n\ncorrection_distance\nfloat\nDistance used for noise and sliver removal.\nrequired\n\n\n**kwargs\nAny\nAdditional processor arguments.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nProcessResult\nThe merged or single result of the alignment process.\n\n\n\n\n\n\nThe algorithm optimizes performance by splitting the input into an ‘inner’ and ‘outer’ zone. Only the ‘outer’ zone (near the boundaries) is evaluated against reference data.\n\n\n\n\n\ngraph TD\n    Start[Input Geometry] --&gt; Split[Split: Inner vs Outer]\n    Split --&gt; Query[Spatial Query Reference Data]\n    Query --&gt; OD[Process Open Domain]\n    Query --&gt; Ref[Process Intersecting Refs]\n    OD --&gt; Combine[Combine Results]\n    Ref --&gt; Combine\n    Combine --&gt; Post[Post-processing]\n    Post --&gt; End[ProcessResult]",
    "crumbs": [
      "Reference",
      "Processors",
      "DieussaertGeometryProcessor"
    ]
  },
  {
    "objectID": "reference/DieussaertGeometryProcessor.html#attributes",
    "href": "reference/DieussaertGeometryProcessor.html#attributes",
    "title": "DieussaertGeometryProcessor",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nprocessor_id\nProcessorID\nThe unique identifier for this processor (ProcessorID.DIEUSSAERT).",
    "crumbs": [
      "Reference",
      "Processors",
      "DieussaertGeometryProcessor"
    ]
  },
  {
    "objectID": "reference/DieussaertGeometryProcessor.html#methods",
    "href": "reference/DieussaertGeometryProcessor.html#methods",
    "title": "DieussaertGeometryProcessor",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nprocess\nCoordinates the alignment process for single or multi-geometries.\n\n\n\n\n\nprocessor.DieussaertGeometryProcessor.process(\n    input_geometry,\n    reference_data,\n    relevant_distance,\n    mitre_limit,\n    correction_distance,\n    **kwargs,\n)\nCoordinates the alignment process for single or multi-geometries.\nIf multi_as_single_modus is disabled, MultiPolygons are processed piecewise and merged afterward to ensure stability.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput_geometry\nBaseGeometry\nThe thematic geometry to align.\nrequired\n\n\nreference_data\nAlignerFeatureCollection\nThe reference (target) dataset.\nrequired\n\n\nrelevant_distance\nfloat\nThe distance threshold for alignment decisions.\nrequired\n\n\nmitre_limit\nfloat\nMitre limit for buffering operations.\nrequired\n\n\ncorrection_distance\nfloat\nDistance used for noise and sliver removal.\nrequired\n\n\n**kwargs\nAny\nAdditional processor arguments.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nProcessResult\nThe merged or single result of the alignment process.\n\n\n\n\n\n\nThe algorithm optimizes performance by splitting the input into an ‘inner’ and ‘outer’ zone. Only the ‘outer’ zone (near the boundaries) is evaluated against reference data.\n\n\n\n\n\ngraph TD\n    Start[Input Geometry] --&gt; Split[Split: Inner vs Outer]\n    Split --&gt; Query[Spatial Query Reference Data]\n    Query --&gt; OD[Process Open Domain]\n    Query --&gt; Ref[Process Intersecting Refs]\n    OD --&gt; Combine[Combine Results]\n    Ref --&gt; Combine\n    Combine --&gt; Post[Post-processing]\n    Post --&gt; End[ProcessResult]",
    "crumbs": [
      "Reference",
      "Processors",
      "DieussaertGeometryProcessor"
    ]
  },
  {
    "objectID": "reference/plot_difference_by_relevant_distance.html",
    "href": "reference/plot_difference_by_relevant_distance.html",
    "title": "plot_difference_by_relevant_distance",
    "section": "",
    "text": "viz.plot_difference_by_relevant_distance(\n    dict_differences,\n    xlabel='relevant distance',\n    ylabel='difference',\n    title='Relevant distance vs difference',\n    save_path=None,\n)\nPlot geometric differences across multiple features as a line graph.\nThis function iterates through a nested dictionary where each key represents a feature (or scenario) and its value is a dictionary mapping X-values (typically ‘relevant distance’) to Y-values (geometric difference).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndict_differences\ndict of dict\nA nested dictionary structure: {label: {x_value: y_value}}. Example: {'feature_1': {0.1: 0.5, 0.2: 0.3}}.\nrequired\n\n\nxlabel\nstr\nLabel for the X-axis.\n\"relevant distance\"\n\n\nylabel\nstr\nLabel for the Y-axis.\n\"difference\"\n\n\ntitle\nstr\nThe main title of the plot.\n\"Relevant distance vs difference\"\n\n\nsave_path\nstr or Path\nIf provided, the plot will be saved to this directory or file path. If a directory is provided, a timestamped filename is generated.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\nThe function displays the plot using plt.show() and optionally saves the figure.\n\n\n\n\n\n\nThis function is particularly useful for sensitivity analysis—showing how adjusting the relevant_distance parameter impacts the final geometric outcome.",
    "crumbs": [
      "Reference",
      "Visualization-functions (optional by pip install brdr[viz])",
      "plot_difference_by_relevant_distance"
    ]
  },
  {
    "objectID": "reference/plot_difference_by_relevant_distance.html#parameters",
    "href": "reference/plot_difference_by_relevant_distance.html#parameters",
    "title": "plot_difference_by_relevant_distance",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndict_differences\ndict of dict\nA nested dictionary structure: {label: {x_value: y_value}}. Example: {'feature_1': {0.1: 0.5, 0.2: 0.3}}.\nrequired\n\n\nxlabel\nstr\nLabel for the X-axis.\n\"relevant distance\"\n\n\nylabel\nstr\nLabel for the Y-axis.\n\"difference\"\n\n\ntitle\nstr\nThe main title of the plot.\n\"Relevant distance vs difference\"\n\n\nsave_path\nstr or Path\nIf provided, the plot will be saved to this directory or file path. If a directory is provided, a timestamped filename is generated.\nNone",
    "crumbs": [
      "Reference",
      "Visualization-functions (optional by pip install brdr[viz])",
      "plot_difference_by_relevant_distance"
    ]
  },
  {
    "objectID": "reference/plot_difference_by_relevant_distance.html#returns",
    "href": "reference/plot_difference_by_relevant_distance.html#returns",
    "title": "plot_difference_by_relevant_distance",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nNone\nThe function displays the plot using plt.show() and optionally saves the figure.",
    "crumbs": [
      "Reference",
      "Visualization-functions (optional by pip install brdr[viz])",
      "plot_difference_by_relevant_distance"
    ]
  },
  {
    "objectID": "reference/plot_difference_by_relevant_distance.html#notes",
    "href": "reference/plot_difference_by_relevant_distance.html#notes",
    "title": "plot_difference_by_relevant_distance",
    "section": "",
    "text": "This function is particularly useful for sensitivity analysis—showing how adjusting the relevant_distance parameter impacts the final geometric outcome.",
    "crumbs": [
      "Reference",
      "Visualization-functions (optional by pip install brdr[viz])",
      "plot_difference_by_relevant_distance"
    ]
  },
  {
    "objectID": "reference/GeoJsonLoader.html",
    "href": "reference/GeoJsonLoader.html",
    "title": "GeoJsonLoader",
    "section": "",
    "text": "loader.GeoJsonLoader(\n    id_property=None,\n    _input=None,\n    source=None,\n    source_url=None,\n    is_reference=False,\n)\nBase class for loaders dealing with GeoJSON-formatted data.\nProcesses a GeoJSON FeatureCollection into the internal dictionary format.\n\n\n\n\n\nName\nDescription\n\n\n\n\nload_data\nParses the GeoJSON input and returns the feature collection.\n\n\n\n\n\nloader.GeoJsonLoader.load_data()\nParses the GeoJSON input and returns the feature collection.",
    "crumbs": [
      "Reference",
      "Loaders",
      "GeoJsonLoader"
    ]
  },
  {
    "objectID": "reference/GeoJsonLoader.html#methods",
    "href": "reference/GeoJsonLoader.html#methods",
    "title": "GeoJsonLoader",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nload_data\nParses the GeoJSON input and returns the feature collection.\n\n\n\n\n\nloader.GeoJsonLoader.load_data()\nParses the GeoJSON input and returns the feature collection.",
    "crumbs": [
      "Reference",
      "Loaders",
      "GeoJsonLoader"
    ]
  },
  {
    "objectID": "reference/PredictionStrategy.html",
    "href": "reference/PredictionStrategy.html",
    "title": "PredictionStrategy",
    "section": "",
    "text": "PredictionStrategy\nenums.PredictionStrategy()\nDetermines which prediction is selected as the primary result.",
    "crumbs": [
      "Reference",
      "Enumerators",
      "PredictionStrategy"
    ]
  },
  {
    "objectID": "reference/ProcessRemark.html",
    "href": "reference/ProcessRemark.html",
    "title": "ProcessRemark",
    "section": "",
    "text": "enums.ProcessRemark()\nStatus remarks added to processed features for auditing and debugging.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nRESULT_UNCHANGED\nstr\nThe alignment did not change the geometry (within tolerance).\n\n\nINPUT_CIRCLE\nstr\nA circle was detected; input returned to prevent geometric distortion.\n\n\nRESULT_EMPTY_RETURNED\nstr\nThe processing resulted in an empty geometry.\n\n\nCHANGED_GEOMETRYTYPE_EMPTY_RETURNED\nstr\nProcessing changed the geometry type (e.g. Polygon to Line), which is treated as invalid.\n\n\nCHANGED_AMOUNT_GEOMETRIES\nstr\nThe number of parts in a Multi-geometry has changed.\n\n\nNO_PREDICTION_ORIGINAL_RETURNED\nstr\nNo suitable prediction found; falling back to original.\n\n\nMULTIPLE_PREDICTIONS_ORIGINAL_RETURNED\nstr\nAmbiguous result due to multiple predictions.\n\n\nNOT_EVALUATED_ORIGINAL_RETURNED\nstr\nEvaluation criteria not met.",
    "crumbs": [
      "Reference",
      "Enumerators",
      "ProcessRemark"
    ]
  },
  {
    "objectID": "reference/ProcessRemark.html#attributes",
    "href": "reference/ProcessRemark.html#attributes",
    "title": "ProcessRemark",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nRESULT_UNCHANGED\nstr\nThe alignment did not change the geometry (within tolerance).\n\n\nINPUT_CIRCLE\nstr\nA circle was detected; input returned to prevent geometric distortion.\n\n\nRESULT_EMPTY_RETURNED\nstr\nThe processing resulted in an empty geometry.\n\n\nCHANGED_GEOMETRYTYPE_EMPTY_RETURNED\nstr\nProcessing changed the geometry type (e.g. Polygon to Line), which is treated as invalid.\n\n\nCHANGED_AMOUNT_GEOMETRIES\nstr\nThe number of parts in a Multi-geometry has changed.\n\n\nNO_PREDICTION_ORIGINAL_RETURNED\nstr\nNo suitable prediction found; falling back to original.\n\n\nMULTIPLE_PREDICTIONS_ORIGINAL_RETURNED\nstr\nAmbiguous result due to multiple predictions.\n\n\nNOT_EVALUATED_ORIGINAL_RETURNED\nstr\nEvaluation criteria not met.",
    "crumbs": [
      "Reference",
      "Enumerators",
      "ProcessRemark"
    ]
  },
  {
    "objectID": "reference/SnapGeometryProcessor.html",
    "href": "reference/SnapGeometryProcessor.html",
    "title": "SnapGeometryProcessor",
    "section": "",
    "text": "processor.SnapGeometryProcessor(config, feedback=None)\nProcessor that aligns geometries by snapping them to the reference data.\nThis processor uses the snapping algorithm to pull the vertices of the thematic geometry towards the nearest components of the reference data within a specified distance.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nprocessor_id\nProcessorID\nThe unique identifier for this processor (ProcessorID.SNAP).\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nprocess\nAligns the input geometry by snapping its vertices to the reference geometries.\n\n\n\n\n\nprocessor.SnapGeometryProcessor.process(\n    correction_distance,\n    reference_data,\n    input_geometry,\n    mitre_limit,\n    relevant_distance,\n    **kwargs,\n)\nAligns the input geometry by snapping its vertices to the reference geometries.\nThe process considers the Open Domain (OD) strategy to determine how areas not covered by reference features should be handled (e.g., ignored, kept as-is, or used as a virtual snapping target).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncorrection_distance\nfloat\nDistance used for cleaning geometric noise.\nrequired\n\n\nreference_data\nAlignerFeatureCollection\nThe collection of reference geometries.\nrequired\n\n\ninput_geometry\nBaseGeometry\nThe thematic geometry to be snapped.\nrequired\n\n\nmitre_limit\nfloat\nMitre limit for buffering operations.\nrequired\n\n\nrelevant_distance\nfloat\nThe maximum distance within which snapping occurs.\nrequired\n\n\n**kwargs\nAny\nAdditional arguments passed to the processor.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nProcessResult\nA dictionary containing the snapped result and difference metrics.\n\n\n\n\n\n\nThe snapping logic is influenced by the od_strategy (Open Domain):\n\n\n\n\n\ngraph TD\n    In[Input Geometry] --&gt; OD{OD Strategy?}\n    OD -- EXCLUDE --&gt; Snap[Snap to Real Refs]\n    OD -- AS_IS --&gt; Keep[Keep OD part as-is]\n    OD -- OTHER --&gt; Virtual[Create Virtual Ref]\n    Virtual --&gt; SnapAll[Snap to Real + Virtual Refs]\n    Keep --&gt; Merge[Merge snapped & as-is parts]\n    Snap --&gt; Post[Post-process Result]\n    SnapAll --&gt; Post\n    Merge --&gt; Post",
    "crumbs": [
      "Reference",
      "Processors",
      "SnapGeometryProcessor"
    ]
  },
  {
    "objectID": "reference/SnapGeometryProcessor.html#attributes",
    "href": "reference/SnapGeometryProcessor.html#attributes",
    "title": "SnapGeometryProcessor",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nprocessor_id\nProcessorID\nThe unique identifier for this processor (ProcessorID.SNAP).",
    "crumbs": [
      "Reference",
      "Processors",
      "SnapGeometryProcessor"
    ]
  },
  {
    "objectID": "reference/SnapGeometryProcessor.html#methods",
    "href": "reference/SnapGeometryProcessor.html#methods",
    "title": "SnapGeometryProcessor",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nprocess\nAligns the input geometry by snapping its vertices to the reference geometries.\n\n\n\n\n\nprocessor.SnapGeometryProcessor.process(\n    correction_distance,\n    reference_data,\n    input_geometry,\n    mitre_limit,\n    relevant_distance,\n    **kwargs,\n)\nAligns the input geometry by snapping its vertices to the reference geometries.\nThe process considers the Open Domain (OD) strategy to determine how areas not covered by reference features should be handled (e.g., ignored, kept as-is, or used as a virtual snapping target).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncorrection_distance\nfloat\nDistance used for cleaning geometric noise.\nrequired\n\n\nreference_data\nAlignerFeatureCollection\nThe collection of reference geometries.\nrequired\n\n\ninput_geometry\nBaseGeometry\nThe thematic geometry to be snapped.\nrequired\n\n\nmitre_limit\nfloat\nMitre limit for buffering operations.\nrequired\n\n\nrelevant_distance\nfloat\nThe maximum distance within which snapping occurs.\nrequired\n\n\n**kwargs\nAny\nAdditional arguments passed to the processor.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nProcessResult\nA dictionary containing the snapped result and difference metrics.\n\n\n\n\n\n\nThe snapping logic is influenced by the od_strategy (Open Domain):\n\n\n\n\n\ngraph TD\n    In[Input Geometry] --&gt; OD{OD Strategy?}\n    OD -- EXCLUDE --&gt; Snap[Snap to Real Refs]\n    OD -- AS_IS --&gt; Keep[Keep OD part as-is]\n    OD -- OTHER --&gt; Virtual[Create Virtual Ref]\n    Virtual --&gt; SnapAll[Snap to Real + Virtual Refs]\n    Keep --&gt; Merge[Merge snapped & as-is parts]\n    Snap --&gt; Post[Post-process Result]\n    SnapAll --&gt; Post\n    Merge --&gt; Post",
    "crumbs": [
      "Reference",
      "Processors",
      "SnapGeometryProcessor"
    ]
  },
  {
    "objectID": "reference/AlignerFeature.html",
    "href": "reference/AlignerFeature.html",
    "title": "AlignerFeature",
    "section": "",
    "text": "feature_data.AlignerFeature(data_id, brdr_id, geometry, properties)\nA container for a single thematic or reference feature within the aligner.\nThis class wraps a geometry and its associated metadata, providing a standardized structure for the alignment process.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ndata_id\nThematicId\nSource id for the feature.\n\n\nbrdr_id\nstr\nThe unique identifier for this feature (ThematicId).\n\n\ngeometry\nBaseGeometry\nThe shapely geometry object representing the spatial component.\n\n\nproperties\ndict[str, Any]\nA dictionary containing the original attributes of the feature.\n\n\n\n\n\n\nThe AlignerFeature is typically stored within an AlignerFeatureCollection. It serves as the atomic unit that the BaseProcessor acts upon.\n\n\n\n&gt;&gt;&gt; from shapely.geometry import Point\n&gt;&gt;&gt; feature = AlignerFeature(\n...     brdr_id=\"feat_01\",\n...     geometry=Point(0, 0),\n...     properties={\"type\": \"boundary\"}\n... )",
    "crumbs": [
      "Reference",
      "AlignerFeatures",
      "AlignerFeature"
    ]
  },
  {
    "objectID": "reference/AlignerFeature.html#attributes",
    "href": "reference/AlignerFeature.html#attributes",
    "title": "AlignerFeature",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\ndata_id\nThematicId\nSource id for the feature.\n\n\nbrdr_id\nstr\nThe unique identifier for this feature (ThematicId).\n\n\ngeometry\nBaseGeometry\nThe shapely geometry object representing the spatial component.\n\n\nproperties\ndict[str, Any]\nA dictionary containing the original attributes of the feature.",
    "crumbs": [
      "Reference",
      "AlignerFeatures",
      "AlignerFeature"
    ]
  },
  {
    "objectID": "reference/AlignerFeature.html#notes",
    "href": "reference/AlignerFeature.html#notes",
    "title": "AlignerFeature",
    "section": "",
    "text": "The AlignerFeature is typically stored within an AlignerFeatureCollection. It serves as the atomic unit that the BaseProcessor acts upon.",
    "crumbs": [
      "Reference",
      "AlignerFeatures",
      "AlignerFeature"
    ]
  },
  {
    "objectID": "reference/AlignerFeature.html#examples",
    "href": "reference/AlignerFeature.html#examples",
    "title": "AlignerFeature",
    "section": "",
    "text": "&gt;&gt;&gt; from shapely.geometry import Point\n&gt;&gt;&gt; feature = AlignerFeature(\n...     brdr_id=\"feat_01\",\n...     geometry=Point(0, 0),\n...     properties={\"type\": \"boundary\"}\n... )",
    "crumbs": [
      "Reference",
      "AlignerFeatures",
      "AlignerFeature"
    ]
  },
  {
    "objectID": "reference/NetworkGeometryProcessor.html",
    "href": "reference/NetworkGeometryProcessor.html",
    "title": "NetworkGeometryProcessor",
    "section": "",
    "text": "processor.NetworkGeometryProcessor(config, feedback=None)\nProcessor that aligns geometries based on a linear network.\nThis processor decomposes polygons into their exterior and interior linear rings and aligns these boundaries to the linear elements (lines and points) found in the reference dataset.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nprocessor_id\nProcessorID\nThe unique identifier for this processor (ProcessorID.NETWORK).\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nprocess\nAligns the boundaries of the input geometry to a reference network.\n\n\n\n\n\nprocessor.NetworkGeometryProcessor.process(\n    input_geometry,\n    reference_data,\n    mitre_limit,\n    correction_distance,\n    relevant_distance,\n    **kwargs,\n)\nAligns the boundaries of the input geometry to a reference network.\nThe process buffers the input to find relevant network elements, processes exterior and interior rings separately, and reconstructs the polygon after alignment.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput_geometry\nBaseGeometry\nThe thematic geometry (Polygon or MultiPolygon) to align.\nrequired\n\n\nreference_data\nAlignerFeatureCollection\nThe reference dataset, specifically using its elements property.\nrequired\n\n\nmitre_limit\nfloat\nMitre limit for buffering operations.\nrequired\n\n\ncorrection_distance\nfloat\nDistance used for cleaning and noise reduction.\nrequired\n\n\nrelevant_distance\nfloat\nThe maximum distance to search for network elements.\nrequired\n\n\n**kwargs\nAny\nAdditional arguments passed to the processor.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nProcessResult\nA dictionary containing the reconstructed and cleaned polygon.\n\n\n\n\n\n\nThe network processing follows a “deconstruct-align-reconstruct” flow:\n\n\n\n\n\ngraph TD\n    In[Input Polygon] --&gt; Decon[Deconstruct: Exterior & Interiors]\n    Decon --&gt; Buff[Buffer Input to Find Network]\n    Buff --&gt; Align[Align Segments to Network Elements]\n    Align --&gt; Recon[Reconstruct Polygon Rings]\n    Recon --&gt; Post[Post-processing & Sliver Removal]\n    Post --&gt; End[Final ProcessResult]",
    "crumbs": [
      "Reference",
      "Processors",
      "NetworkGeometryProcessor"
    ]
  },
  {
    "objectID": "reference/NetworkGeometryProcessor.html#attributes",
    "href": "reference/NetworkGeometryProcessor.html#attributes",
    "title": "NetworkGeometryProcessor",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nprocessor_id\nProcessorID\nThe unique identifier for this processor (ProcessorID.NETWORK).",
    "crumbs": [
      "Reference",
      "Processors",
      "NetworkGeometryProcessor"
    ]
  },
  {
    "objectID": "reference/NetworkGeometryProcessor.html#methods",
    "href": "reference/NetworkGeometryProcessor.html#methods",
    "title": "NetworkGeometryProcessor",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nprocess\nAligns the boundaries of the input geometry to a reference network.\n\n\n\n\n\nprocessor.NetworkGeometryProcessor.process(\n    input_geometry,\n    reference_data,\n    mitre_limit,\n    correction_distance,\n    relevant_distance,\n    **kwargs,\n)\nAligns the boundaries of the input geometry to a reference network.\nThe process buffers the input to find relevant network elements, processes exterior and interior rings separately, and reconstructs the polygon after alignment.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput_geometry\nBaseGeometry\nThe thematic geometry (Polygon or MultiPolygon) to align.\nrequired\n\n\nreference_data\nAlignerFeatureCollection\nThe reference dataset, specifically using its elements property.\nrequired\n\n\nmitre_limit\nfloat\nMitre limit for buffering operations.\nrequired\n\n\ncorrection_distance\nfloat\nDistance used for cleaning and noise reduction.\nrequired\n\n\nrelevant_distance\nfloat\nThe maximum distance to search for network elements.\nrequired\n\n\n**kwargs\nAny\nAdditional arguments passed to the processor.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nProcessResult\nA dictionary containing the reconstructed and cleaned polygon.\n\n\n\n\n\n\nThe network processing follows a “deconstruct-align-reconstruct” flow:\n\n\n\n\n\ngraph TD\n    In[Input Polygon] --&gt; Decon[Deconstruct: Exterior & Interiors]\n    Decon --&gt; Buff[Buffer Input to Find Network]\n    Buff --&gt; Align[Align Segments to Network Elements]\n    Align --&gt; Recon[Reconstruct Polygon Rings]\n    Recon --&gt; Post[Post-processing & Sliver Removal]\n    Post --&gt; End[Final ProcessResult]",
    "crumbs": [
      "Reference",
      "Processors",
      "NetworkGeometryProcessor"
    ]
  },
  {
    "objectID": "reference/OpenDomainStrategy.html",
    "href": "reference/OpenDomainStrategy.html",
    "title": "OpenDomainStrategy",
    "section": "",
    "text": "enums.OpenDomainStrategy()\nStrategies for processing thematic areas not covered by reference data.\nIn GIS terms, this defines how the algorithm handles the ‘Public Domain’ when the reference layer (e.g., land parcels) does not provide a target.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nEXCLUDE\nstr\nCompletely remove parts of the thematic geometry not on the reference layer.\n\n\nAS_IS\nstr\nKeep parts not covered by reference data unchanged in the result.\n\n\nSNAP_INNER_SIDE\nstr\nSnap everything within the relevant distance to the interior parcel boundary.\n\n\nSNAP_ALL_SIDE\nstr\nSnap to both inner and outer boundaries where possible.\n\n\nSNAP_PREFER_VERTICES\nstr\nSnap to reference polygons, prioritizing vertices over edges.\n\n\nSNAP_NO_PREFERENCE\nstr\nSnap to the closest reference component (edge or vertex) without bias.\n\n\nSNAP_ONLY_VERTICES\nstr\nOnly allow snapping to existing vertices of the reference polygons.",
    "crumbs": [
      "Reference",
      "Enumerators",
      "OpenDomainStrategy"
    ]
  },
  {
    "objectID": "reference/OpenDomainStrategy.html#attributes",
    "href": "reference/OpenDomainStrategy.html#attributes",
    "title": "OpenDomainStrategy",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nEXCLUDE\nstr\nCompletely remove parts of the thematic geometry not on the reference layer.\n\n\nAS_IS\nstr\nKeep parts not covered by reference data unchanged in the result.\n\n\nSNAP_INNER_SIDE\nstr\nSnap everything within the relevant distance to the interior parcel boundary.\n\n\nSNAP_ALL_SIDE\nstr\nSnap to both inner and outer boundaries where possible.\n\n\nSNAP_PREFER_VERTICES\nstr\nSnap to reference polygons, prioritizing vertices over edges.\n\n\nSNAP_NO_PREFERENCE\nstr\nSnap to the closest reference component (edge or vertex) without bias.\n\n\nSNAP_ONLY_VERTICES\nstr\nOnly allow snapping to existing vertices of the reference polygons.",
    "crumbs": [
      "Reference",
      "Enumerators",
      "OpenDomainStrategy"
    ]
  },
  {
    "objectID": "reference/ProcessorID.html",
    "href": "reference/ProcessorID.html",
    "title": "ProcessorID",
    "section": "",
    "text": "ProcessorID\nenums.ProcessorID()\nUnique identifiers for the available alignment algorithms.\nReferences correspond to the internal Aligner documentation and methodology.",
    "crumbs": [
      "Reference",
      "Enumerators",
      "ProcessorID"
    ]
  },
  {
    "objectID": "reference/DictLoader.html",
    "href": "reference/DictLoader.html",
    "title": "DictLoader",
    "section": "",
    "text": "loader.DictLoader(\n    data_dict,\n    data_dict_properties={},\n    data_dict_source={'source_url': None},\n    is_reference=False,\n)\nLoader that accepts data directly from Python dictionaries.\nUseful for integrating with existing in-memory data structures.\n\n\n\n\n\nName\nDescription\n\n\n\n\nload_data\nExecutes the standard loading process.\n\n\n\n\n\nloader.DictLoader.load_data()\nExecutes the standard loading process.",
    "crumbs": [
      "Reference",
      "Loaders",
      "DictLoader"
    ]
  },
  {
    "objectID": "reference/DictLoader.html#methods",
    "href": "reference/DictLoader.html#methods",
    "title": "DictLoader",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nload_data\nExecutes the standard loading process.\n\n\n\n\n\nloader.DictLoader.load_data()\nExecutes the standard loading process.",
    "crumbs": [
      "Reference",
      "Loaders",
      "DictLoader"
    ]
  }
]