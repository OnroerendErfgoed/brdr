[
  {
    "objectID": "reference/DictLoader.html",
    "href": "reference/DictLoader.html",
    "title": "DictLoader",
    "section": "",
    "text": "DictLoader\nloader.DictLoader(data_dict, data_dict_properties={}, data_dict_source={})",
    "crumbs": [
      "Reference",
      "Loaders",
      "DictLoader"
    ]
  },
  {
    "objectID": "reference/GeoJsonLoader.html",
    "href": "reference/GeoJsonLoader.html",
    "title": "GeoJsonLoader",
    "section": "",
    "text": "GeoJsonLoader\nloader.GeoJsonLoader(id_property=None, _input=None)",
    "crumbs": [
      "Reference",
      "Loaders",
      "GeoJsonLoader"
    ]
  },
  {
    "objectID": "reference/GeoJsonFileLoader.html",
    "href": "reference/GeoJsonFileLoader.html",
    "title": "GeoJsonFileLoader",
    "section": "",
    "text": "GeoJsonFileLoader\nloader.GeoJsonFileLoader(path_to_file, id_property)",
    "crumbs": [
      "Reference",
      "Loaders",
      "GeoJsonFileLoader"
    ]
  },
  {
    "objectID": "reference/Aligner.html",
    "href": "reference/Aligner.html",
    "title": "Aligner",
    "section": "",
    "text": "aligner.Aligner(\n    feedback=None,\n    relevant_distance=1,\n    relevant_distances=[(round(k, RELEVANT_DISTANCE_DECIMALS)) for k in (np.arange(0, 310, 10, dtype=int) / 100)],\n    threshold_overlap_percentage=50,\n    od_strategy=OpenDomainStrategy.SNAP_ALL_SIDE,\n    crs=DEFAULT_CRS,\n    multi_as_single_modus=True,\n    preserve_topology=False,\n    snap_strategy=SNAP_STRATEGY,\n    snap_max_segment_length=SNAP_MAX_SEGMENT_LENGTH,\n    partial_snapping=PARTIAL_SNAPPING,\n    partial_snap_strategy=PARTIAL_SNAP_STRATEGY,\n    partial_snap_max_segment_length=PARTIAL_SNAP_MAX_SEGMENT_LENGTH,\n    threshold_exclusion_area=0,\n    threshold_exclusion_percentage=0,\n    threshold_inclusion_percentage=100,\n    buffer_multiplication_factor=BUFFER_MULTIPLICATION_FACTOR,\n    threshold_circle_ratio=0.98,\n    correction_distance=0.01,\n    diff_metric=DIFF_METRIC,\n    mitre_limit=10,\n    area_limit=None,\n    max_workers=None,\n)\nThis class is used to compare and align the thematic data with the reference data. The reference data can be loaded in different ways, for example by using the GRB data. The thematic data can be loaded by using different Loaders: DictLoader, GeojsonLoader,… The class can be used to compare and aligne the thematic data with the reference data.\n\n\n\n\n\nName\nDescription\n\n\n\n\nevaluate\nCompares and evaluate input-geometries (with formula). Attributes are added to evaluate and decide if new\n\n\nget_brdr_formula\nCalculates formula-related information based on the input geometry.\n\n\nget_diff_metrics\nCalculates a dictionary containing difference metrics for thematic elements based on a distance series.\n\n\nget_input_as_geojson\nget a geojson of the input polygons (thematic or reference-polygons)\n\n\nget_results_as_geojson\nget a geojson of a dictionary containing the resulting geometries for all\n\n\nget_thematic_union\nreturns a unary_unioned geometry from all the thematic geometries\n\n\nload_reference_data\nLoads the reference features into the aligner, and prepares the reference-data for processing\n\n\nload_thematic_data\nLoads the thematic features into the aligner\n\n\npredictor\nPredicts the ‘most interesting’ relevant distances for changes in thematic\n\n\nprocess\nCalculates the resulting dictionaries for thematic data based on a series of\n\n\nprocess_geometry\nmethod to align a geometry to the reference layer\n\n\nsave_results\nExports analysis results (as geojson) to path.\n\n\n\n\n\naligner.Aligner.evaluate(\n    ids_to_evaluate=None,\n    base_formula_field=FORMULA_FIELD_NAME,\n    relevant_distances=[(round(k, RELEVANT_DISTANCE_DECIMALS)) for k in (np.arange(0, 310, 10, dtype=int) / 100)],\n    full_strategy=FullStrategy.NO_FULL,\n    max_predictions=-1,\n    multi_to_best_prediction=True,\n)\nCompares and evaluate input-geometries (with formula). Attributes are added to evaluate and decide if new proposals can be used ids_to_evaluate: list with all IDs to evaluate. all other IDs will be unchanged. If None (default), all self.dict_thematic will be evaluated. base_formula_field: name of the field where the base_formula is found in the data max_predictions: integer that indicates how many predictions are maximally returned. (-1 indicates all predictions are returned) relevant_distances: relevant distances to evaluate full_strategy: enum, decided which predictions are kept or prefered based on full-ness of the prediction multi_to_best_prediction (default True): Only usable in combination with max_predictions=1. If True (and max_predictions=1), the prediction with highest score will be taken.If False, the original geometry is returned.\n\n\n\naligner.Aligner.get_brdr_formula(geometry, with_geom=False)\nCalculates formula-related information based on the input geometry.\nArgs: geometry (shapely.geometry object): The input geometry. with_geom (bool, optional): Whether to include geometry information in the output. Defaults to False.\nReturns: dict: A dictionary containing formula-related data:\n- \"alignment_date\": datetime.now().strftime(DATE_FORMAT),\n- \"brdr_version\": str(__version__),\n- \"reference_source\": self.dict_reference_source,\n- \"full\": True if the geometry exists out of all full reference-polygons, else False.\n- \"area\": Area of the geometry.\n- \"reference_features\": {\n    array of all the reference features the geometry is composed of:\n        -   'full': True if the intersection is the same as the reference\n            geometry, else False.\n        -   'area': Area of the intersection or reference geometry.\n        -   'percentage': Percentage of intersection area relative to the\n            reference geometry.\n        -   'geometry': GeoJSON representation of the intersection (if\n            with_geom is True).},\n- \"reference_od\": Discription of the OD-part of the geometry (= not covered by reference-features),\n\n\n\naligner.Aligner.get_diff_metrics(\n    dict_processresults=None,\n    dict_thematic=None,\n    diff_metric=DiffMetric.CHANGES_AREA,\n)\nCalculates a dictionary containing difference metrics for thematic elements based on a distance series.\nParameters: dict_series (dict): A dictionary where keys are thematic IDs and values are dictionaries mapping relevant distances to ProcessResult objects. dict_thematic (dict): A dictionary where keys are thematic IDs and values are BaseGeometry objects representing the original geometries. diff_metric (DiffMetric, optional): The metric to use for calculating differences. Default is DiffMetric.CHANGES_AREA.\nReturns: dict: A dictionary where keys are thematic IDs and values are dictionaries mapping relevant distances to calculated difference metrics.\n\n\n\naligner.Aligner.get_input_as_geojson(inputtype=AlignerInputType.REFERENCE)\nget a geojson of the input polygons (thematic or reference-polygons)\n\n\n\naligner.Aligner.get_results_as_geojson(\n    resulttype=AlignerResultType.PROCESSRESULTS,\n    formula=False,\n    attributes=False,\n)\nget a geojson of a dictionary containing the resulting geometries for all ‘serial’ relevant distances. The resulttype can be chosen. formula (boolean, Optional): The descriptive formula is added as an attribute to the result attributes (boolean, Optional): The original attributes/properties are added to the result\n\n\n\naligner.Aligner.get_thematic_union()\nreturns a unary_unioned geometry from all the thematic geometries :return:\n\n\n\naligner.Aligner.load_reference_data(loader)\nLoads the reference features into the aligner, and prepares the reference-data for processing :param loader: :return:\n\n\n\naligner.Aligner.load_thematic_data(loader)\nLoads the thematic features into the aligner :param loader: :return:\n\n\n\naligner.Aligner.predictor(\n    dict_thematic=None,\n    relevant_distances=[(round(k, RELEVANT_DISTANCE_DECIMALS)) for k in (np.arange(0, 310, 10, dtype=int) / 100)],\n    od_strategy=OpenDomainStrategy.SNAP_ALL_SIDE,\n    threshold_overlap_percentage=50,\n    diff_metric=None,\n)\nPredicts the ‘most interesting’ relevant distances for changes in thematic elements based on a distance series.\nThis function analyzes a set of thematic geometries (self.dict_thematic) to identify potentially interesting distances where changes occur. It performs the following steps:\n\nProcess Distance Series:\n\nCalculates a series of results for different distances specified by relevant_distances.\nThis calculation might involve functions like self.process_series (implementation details likely depend on your specific code).\n\nCalculate Difference Metrics:\n\nAnalyzes the results from the distance series to compute difference metrics between thematic elements at each distance (using diffs_from_dict_series).\n\nIdentify Breakpoints and Zero-Streaks:\n\nFor each thematic geometry, it identifies potential “breakpoints” where the difference metric changes sign (from positive to negative or vice versa).\nIt also identifies “zero-streaks” which are consecutive distances with a difference metric close to zero (potentially indicating minimal change).\n\nPredict Interesting Distances:\n\nThe function considers distances corresponding to breakpoints and zero-streaks as potentially interesting for further analysis.\nThese distances are stored in a dictionary (dict_predictions) with the thematic element key as the outer key.\nAdditionally, the corresponding results from the distance series for those distances are included.\n\n\nArgs: dict_thematic: the dictionary with the thematic geometries to ‘predict’. Default is None, so all thematic geometries inside the aligner will be processed. relevant_distances (np.ndarray, optional): A series of relevant distances (in meters) to process. : A NumPy array of distances to be analyzed. od_strategy (int, optional): The strategy to determine how to handle information outside the reference polygons (Open Domain) (default: SNAP_FULL_AREA_ALL_SIDE) threshold_overlap_percentage (int, optional): Threshold (%) to determine from which overlapping-percentage a reference-polygon has to be included when there aren’t relevant intersections or relevant differences (default 50%). When setting this parameter to ‘-1’ the original border for will be returned for cases where nor relevant intersections and relevant differences are found\nrelevant_distances (np.ndarray, optional): A NumPy array of distances to\n  be analyzed. Defaults to np.arange(0.1, 5.05, 0.1).\nod_strategy (OpenDomainStrategy, optional): A strategy for handling\n  open data in the processing (implementation specific). Defaults to\n OpenDomainStrategy.SNAP_ALL_SIDE.\nthreshold_overlap_percentage (int, optional): A percentage threshold for\n  considering full overlap in the processing (implementation specific).\n Defaults to 50.\ndiff_metric (enum, optional): A enum thjat determines the method how differences are measured to determine the 'predictions'\nReturns: dict_series: A dictionary containing the resultset for all relevant distances for each thematic element. dict_predictions: A dictionary containing predicted interesting distances for each thematic element. - Keys: Thematic element identifiers from self.dict_thematic. - Values: Dictionaries with the following structure for each thematic element: - Keys: Distances identified as interesting (breakpoints or zero-streaks). - Values: dicts containing results (likely specific to your implementation) from the distance series for the corresponding distance. diffs_dict: a dictionary with the differences for each relevant distance\n\n\n\naligner.Aligner.process(\n    dict_thematic=None,\n    relevant_distances=None,\n    relevant_distance=1,\n    od_strategy=OpenDomainStrategy.SNAP_ALL_SIDE,\n    threshold_overlap_percentage=50,\n)\nCalculates the resulting dictionaries for thematic data based on a series of relevant distances.\nArgs: relevant_distances (Iterable[float]): A series of relevant distances (in meters) to process od_strategy (int, optional): The strategy to determine how to handle information outside the reference polygons (Open Domain) (default: SNAP_FULL_AREA_ALL_SIDE) threshold_overlap_percentage (int, optional): Threshold (%) to determine from which overlapping-percentage a reference-polygon has to be included when there aren’t relevant intersections or relevant differences (default 50%). When setting this parameter to ‘-1’ the original border for will be returned for cases where nor relevant intersections and relevant differences are found\nReturns: dict: A dictionary, for every thematic ID a dictionary with the results for all distances\n    {\n        'theme_id_1': {0: (ProcessResult), 0.1:\n            (ProcessResult), ...},\n        'theme_id_2': {0: (ProcessResult), 0.1:\n            (ProcessResult), ...},\n        ...\n    }\n\n\n\naligner.Aligner.process_geometry(\n    input_geometry,\n    relevant_distance=1,\n    od_strategy=OpenDomainStrategy.SNAP_ALL_SIDE,\n    threshold_overlap_percentage=50,\n)\nmethod to align a geometry to the reference layer\nArgs: input_geometry (BaseGeometry): The input geometric object. relevant_distance: The relevant distance (in meters) for processing od_strategy (int, optional): The strategy to determine how to handle information outside the reference polygons (Open Domain) (default: SNAP_FULL_AREA_ALL_SIDE) threshold_overlap_percentage (int, optional): Threshold (%) to determine from which overlapping-percentage a reference-polygon has to be included when there aren’t relevant intersections or relevant differences (default 50%). When setting this parameter to ‘-1’ the original border for will be returned for cases where nor relevant intersections and relevant differences are found\nReturns: ProcessResult : A dict containing the resulting geometries:\n*   result (BaseGeometry): The resulting output geometry\n*   result_diff (BaseGeometry): The resulting difference output geometry\n*   result_diff_plus (BaseGeometry): The resulting positive difference\n    output geometry\n*   result_diff_min (BaseGeometry): The resulting negative difference output\n    geometry\n*   relevant_intersection (BaseGeometry): The relevant_intersection\n*   relevant_difference (BaseGeometry): The relevant_difference\n*   remark (str): remarks collected when processing the geometry\n\n\n\naligner.Aligner.save_results(\n    path,\n    resulttype=AlignerResultType.PROCESSRESULTS,\n    formula=True,\n)\nExports analysis results (as geojson) to path.\nThis function exports 6 GeoJSON files containing the analysis results to the specified path.\nArgs: path (str): The path to the directory where the GeoJSON files will be saved. formula (bool, optional): Whether to include formula-related information in the output. Defaults to True.\nDetails of exported files: - result.geojson: Contains the original thematic data from self.dict_result. - result_diff.geojson: Contains the difference between the original and predicted data from self.dict_result_diff. - result_diff_plus.geojson: Contains results for areas that are added (increased area). - result_diff_min.geojson: Contains results for areas that are removed (decreased area). - result_relevant_intersection.geojson: Contains the areas with relevant intersection that has to be included in the result. - result_relevant_difference.geojson: Contains the areas with relevant difference that has to be excluded from the result.",
    "crumbs": [
      "Reference",
      "Aligner",
      "Aligner"
    ]
  },
  {
    "objectID": "reference/Aligner.html#methods",
    "href": "reference/Aligner.html#methods",
    "title": "Aligner",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nevaluate\nCompares and evaluate input-geometries (with formula). Attributes are added to evaluate and decide if new\n\n\nget_brdr_formula\nCalculates formula-related information based on the input geometry.\n\n\nget_diff_metrics\nCalculates a dictionary containing difference metrics for thematic elements based on a distance series.\n\n\nget_input_as_geojson\nget a geojson of the input polygons (thematic or reference-polygons)\n\n\nget_results_as_geojson\nget a geojson of a dictionary containing the resulting geometries for all\n\n\nget_thematic_union\nreturns a unary_unioned geometry from all the thematic geometries\n\n\nload_reference_data\nLoads the reference features into the aligner, and prepares the reference-data for processing\n\n\nload_thematic_data\nLoads the thematic features into the aligner\n\n\npredictor\nPredicts the ‘most interesting’ relevant distances for changes in thematic\n\n\nprocess\nCalculates the resulting dictionaries for thematic data based on a series of\n\n\nprocess_geometry\nmethod to align a geometry to the reference layer\n\n\nsave_results\nExports analysis results (as geojson) to path.\n\n\n\n\n\naligner.Aligner.evaluate(\n    ids_to_evaluate=None,\n    base_formula_field=FORMULA_FIELD_NAME,\n    relevant_distances=[(round(k, RELEVANT_DISTANCE_DECIMALS)) for k in (np.arange(0, 310, 10, dtype=int) / 100)],\n    full_strategy=FullStrategy.NO_FULL,\n    max_predictions=-1,\n    multi_to_best_prediction=True,\n)\nCompares and evaluate input-geometries (with formula). Attributes are added to evaluate and decide if new proposals can be used ids_to_evaluate: list with all IDs to evaluate. all other IDs will be unchanged. If None (default), all self.dict_thematic will be evaluated. base_formula_field: name of the field where the base_formula is found in the data max_predictions: integer that indicates how many predictions are maximally returned. (-1 indicates all predictions are returned) relevant_distances: relevant distances to evaluate full_strategy: enum, decided which predictions are kept or prefered based on full-ness of the prediction multi_to_best_prediction (default True): Only usable in combination with max_predictions=1. If True (and max_predictions=1), the prediction with highest score will be taken.If False, the original geometry is returned.\n\n\n\naligner.Aligner.get_brdr_formula(geometry, with_geom=False)\nCalculates formula-related information based on the input geometry.\nArgs: geometry (shapely.geometry object): The input geometry. with_geom (bool, optional): Whether to include geometry information in the output. Defaults to False.\nReturns: dict: A dictionary containing formula-related data:\n- \"alignment_date\": datetime.now().strftime(DATE_FORMAT),\n- \"brdr_version\": str(__version__),\n- \"reference_source\": self.dict_reference_source,\n- \"full\": True if the geometry exists out of all full reference-polygons, else False.\n- \"area\": Area of the geometry.\n- \"reference_features\": {\n    array of all the reference features the geometry is composed of:\n        -   'full': True if the intersection is the same as the reference\n            geometry, else False.\n        -   'area': Area of the intersection or reference geometry.\n        -   'percentage': Percentage of intersection area relative to the\n            reference geometry.\n        -   'geometry': GeoJSON representation of the intersection (if\n            with_geom is True).},\n- \"reference_od\": Discription of the OD-part of the geometry (= not covered by reference-features),\n\n\n\naligner.Aligner.get_diff_metrics(\n    dict_processresults=None,\n    dict_thematic=None,\n    diff_metric=DiffMetric.CHANGES_AREA,\n)\nCalculates a dictionary containing difference metrics for thematic elements based on a distance series.\nParameters: dict_series (dict): A dictionary where keys are thematic IDs and values are dictionaries mapping relevant distances to ProcessResult objects. dict_thematic (dict): A dictionary where keys are thematic IDs and values are BaseGeometry objects representing the original geometries. diff_metric (DiffMetric, optional): The metric to use for calculating differences. Default is DiffMetric.CHANGES_AREA.\nReturns: dict: A dictionary where keys are thematic IDs and values are dictionaries mapping relevant distances to calculated difference metrics.\n\n\n\naligner.Aligner.get_input_as_geojson(inputtype=AlignerInputType.REFERENCE)\nget a geojson of the input polygons (thematic or reference-polygons)\n\n\n\naligner.Aligner.get_results_as_geojson(\n    resulttype=AlignerResultType.PROCESSRESULTS,\n    formula=False,\n    attributes=False,\n)\nget a geojson of a dictionary containing the resulting geometries for all ‘serial’ relevant distances. The resulttype can be chosen. formula (boolean, Optional): The descriptive formula is added as an attribute to the result attributes (boolean, Optional): The original attributes/properties are added to the result\n\n\n\naligner.Aligner.get_thematic_union()\nreturns a unary_unioned geometry from all the thematic geometries :return:\n\n\n\naligner.Aligner.load_reference_data(loader)\nLoads the reference features into the aligner, and prepares the reference-data for processing :param loader: :return:\n\n\n\naligner.Aligner.load_thematic_data(loader)\nLoads the thematic features into the aligner :param loader: :return:\n\n\n\naligner.Aligner.predictor(\n    dict_thematic=None,\n    relevant_distances=[(round(k, RELEVANT_DISTANCE_DECIMALS)) for k in (np.arange(0, 310, 10, dtype=int) / 100)],\n    od_strategy=OpenDomainStrategy.SNAP_ALL_SIDE,\n    threshold_overlap_percentage=50,\n    diff_metric=None,\n)\nPredicts the ‘most interesting’ relevant distances for changes in thematic elements based on a distance series.\nThis function analyzes a set of thematic geometries (self.dict_thematic) to identify potentially interesting distances where changes occur. It performs the following steps:\n\nProcess Distance Series:\n\nCalculates a series of results for different distances specified by relevant_distances.\nThis calculation might involve functions like self.process_series (implementation details likely depend on your specific code).\n\nCalculate Difference Metrics:\n\nAnalyzes the results from the distance series to compute difference metrics between thematic elements at each distance (using diffs_from_dict_series).\n\nIdentify Breakpoints and Zero-Streaks:\n\nFor each thematic geometry, it identifies potential “breakpoints” where the difference metric changes sign (from positive to negative or vice versa).\nIt also identifies “zero-streaks” which are consecutive distances with a difference metric close to zero (potentially indicating minimal change).\n\nPredict Interesting Distances:\n\nThe function considers distances corresponding to breakpoints and zero-streaks as potentially interesting for further analysis.\nThese distances are stored in a dictionary (dict_predictions) with the thematic element key as the outer key.\nAdditionally, the corresponding results from the distance series for those distances are included.\n\n\nArgs: dict_thematic: the dictionary with the thematic geometries to ‘predict’. Default is None, so all thematic geometries inside the aligner will be processed. relevant_distances (np.ndarray, optional): A series of relevant distances (in meters) to process. : A NumPy array of distances to be analyzed. od_strategy (int, optional): The strategy to determine how to handle information outside the reference polygons (Open Domain) (default: SNAP_FULL_AREA_ALL_SIDE) threshold_overlap_percentage (int, optional): Threshold (%) to determine from which overlapping-percentage a reference-polygon has to be included when there aren’t relevant intersections or relevant differences (default 50%). When setting this parameter to ‘-1’ the original border for will be returned for cases where nor relevant intersections and relevant differences are found\nrelevant_distances (np.ndarray, optional): A NumPy array of distances to\n  be analyzed. Defaults to np.arange(0.1, 5.05, 0.1).\nod_strategy (OpenDomainStrategy, optional): A strategy for handling\n  open data in the processing (implementation specific). Defaults to\n OpenDomainStrategy.SNAP_ALL_SIDE.\nthreshold_overlap_percentage (int, optional): A percentage threshold for\n  considering full overlap in the processing (implementation specific).\n Defaults to 50.\ndiff_metric (enum, optional): A enum thjat determines the method how differences are measured to determine the 'predictions'\nReturns: dict_series: A dictionary containing the resultset for all relevant distances for each thematic element. dict_predictions: A dictionary containing predicted interesting distances for each thematic element. - Keys: Thematic element identifiers from self.dict_thematic. - Values: Dictionaries with the following structure for each thematic element: - Keys: Distances identified as interesting (breakpoints or zero-streaks). - Values: dicts containing results (likely specific to your implementation) from the distance series for the corresponding distance. diffs_dict: a dictionary with the differences for each relevant distance\n\n\n\naligner.Aligner.process(\n    dict_thematic=None,\n    relevant_distances=None,\n    relevant_distance=1,\n    od_strategy=OpenDomainStrategy.SNAP_ALL_SIDE,\n    threshold_overlap_percentage=50,\n)\nCalculates the resulting dictionaries for thematic data based on a series of relevant distances.\nArgs: relevant_distances (Iterable[float]): A series of relevant distances (in meters) to process od_strategy (int, optional): The strategy to determine how to handle information outside the reference polygons (Open Domain) (default: SNAP_FULL_AREA_ALL_SIDE) threshold_overlap_percentage (int, optional): Threshold (%) to determine from which overlapping-percentage a reference-polygon has to be included when there aren’t relevant intersections or relevant differences (default 50%). When setting this parameter to ‘-1’ the original border for will be returned for cases where nor relevant intersections and relevant differences are found\nReturns: dict: A dictionary, for every thematic ID a dictionary with the results for all distances\n    {\n        'theme_id_1': {0: (ProcessResult), 0.1:\n            (ProcessResult), ...},\n        'theme_id_2': {0: (ProcessResult), 0.1:\n            (ProcessResult), ...},\n        ...\n    }\n\n\n\naligner.Aligner.process_geometry(\n    input_geometry,\n    relevant_distance=1,\n    od_strategy=OpenDomainStrategy.SNAP_ALL_SIDE,\n    threshold_overlap_percentage=50,\n)\nmethod to align a geometry to the reference layer\nArgs: input_geometry (BaseGeometry): The input geometric object. relevant_distance: The relevant distance (in meters) for processing od_strategy (int, optional): The strategy to determine how to handle information outside the reference polygons (Open Domain) (default: SNAP_FULL_AREA_ALL_SIDE) threshold_overlap_percentage (int, optional): Threshold (%) to determine from which overlapping-percentage a reference-polygon has to be included when there aren’t relevant intersections or relevant differences (default 50%). When setting this parameter to ‘-1’ the original border for will be returned for cases where nor relevant intersections and relevant differences are found\nReturns: ProcessResult : A dict containing the resulting geometries:\n*   result (BaseGeometry): The resulting output geometry\n*   result_diff (BaseGeometry): The resulting difference output geometry\n*   result_diff_plus (BaseGeometry): The resulting positive difference\n    output geometry\n*   result_diff_min (BaseGeometry): The resulting negative difference output\n    geometry\n*   relevant_intersection (BaseGeometry): The relevant_intersection\n*   relevant_difference (BaseGeometry): The relevant_difference\n*   remark (str): remarks collected when processing the geometry\n\n\n\naligner.Aligner.save_results(\n    path,\n    resulttype=AlignerResultType.PROCESSRESULTS,\n    formula=True,\n)\nExports analysis results (as geojson) to path.\nThis function exports 6 GeoJSON files containing the analysis results to the specified path.\nArgs: path (str): The path to the directory where the GeoJSON files will be saved. formula (bool, optional): Whether to include formula-related information in the output. Defaults to True.\nDetails of exported files: - result.geojson: Contains the original thematic data from self.dict_result. - result_diff.geojson: Contains the difference between the original and predicted data from self.dict_result_diff. - result_diff_plus.geojson: Contains results for areas that are added (increased area). - result_diff_min.geojson: Contains results for areas that are removed (decreased area). - result_relevant_intersection.geojson: Contains the areas with relevant intersection that has to be included in the result. - result_relevant_difference.geojson: Contains the areas with relevant difference that has to be excluded from the result.",
    "crumbs": [
      "Reference",
      "Aligner",
      "Aligner"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "brdr",
    "section": "",
    "text": "a Python library to assist in realigning (multi-)polygons (OGC Simple Features) to reference borders\n\n\n\n\nPyPI - Version\n\n\n\n\n\nDOI\n\n\n\nQuick links:\n\nInstallation\nDevelopment\nIssues, questions, comments and contributions\n\n\n\n\n\nbrdr is a Python package that assists in aligning geometric boundaries to reference boundaries. This is an important task in geographic data management to enhance data quality.\n\nIn the context of geographic data management, it is important to have accurate and consistent boundaries for a variety of applications such as calculating areas, analyzing spatial relationships, and visualizing and querying geographic information.\nWhen creating geographic data, it is often more efficient to derive boundaries from existing reference data rather than collecting new data in the field.\nbrdr can be used to align boundaries from new data to reference data, ensuring that the boundaries are accurate and consistent.\n\n\n\n\nThe figure below shows:\n\nthe original thematic geometry (blue),\nA reference layer (yellow-black).\nThe resulting geometry after alignment with brdr (green)\n\n\n\n\n\nbrdr provides a variety of functionalities in the Aligner-class to assist in aligning boundaries, including:\n\nLoaders:\n\naligner.load_thematic_data():Loading thematic data ((Multi-)Polygons) as a dictionary (DictLoader) or geojson ( GeoJsonFileLoader,GeoJsonUrlLoader)\naligner.load_reference_data():Loading reference data ((Multi-)Polygons) as a dictionary (DictLoader) or geojson ( GeoJsonFileLoader,GeoJsonUrlLoader)\n\nProcessors:\n\naligner.process(): Align thematic boundaries to reference boundaries with a specific relevant distance or a range of relevant distances\naligner.predictor(): Searches all ‘stable’ (=predicted) processresults in a range of relevant distances\naligner.get_brdr_formula(): Calculating a descriptive formula of a thematic boundary based on a reference layer\nevaluate(): Compares & evaluates input geometries with another version and adds a EVALUATION_FIELD_NAME\n\nExporters:\n\naligner.get_results_as_geojson(): Returns a collection of geojson-dictionaries with the processresults (resulting geometry, differences,…): This can be used for all processresults or only the ‘predicted’ results\naligner.get_input_as_geojson(): Returns a geojson-featurecollection from input-dictionaries (thematic or reference)\naligner.save_results(): Exports the resuling geojson-files to a specified path:This can be used for all processresults or only the ‘predicted’ results\n\n\nBesides the generic functionalities, a range of Flanders-specific functionalities are provided:\n\nLoaders:\n\nGRBActualLoader: Loading actual GRB (parcels, buildings)\nGRBFiscalParcelLoader: Loading fiscal GRB-parcels of a specific year\n\nProcessors:\n\ngrb.get_geoms_affected_by_grb_change(): get thematic geometries that are possibly affected by GRB-changes during a specific timespan\ngrb.update_to_actual_grb(): aligns the boundaries of thematic features to the actual GRB-boundaries\n\n\n\n\n\n\nGeodata-management:\n\nImplementation of brdr in business-processes and tooling\nBulk geodata-alignment\nAlignment after reprojection of data\nCleaning data: In a postprocessing-phase, the algorithm executes sliver-cleanup and validity-cleaning on the resulting geometries\n…\n\nData-Analysis: Investigate the pattern in deviation and change between thematic and reference boundaries\nUpdate-detection: Investigate the descriptive formula before and after alignment to check for (automatic) alignment of geodata\n…\n\n\n\n\nAn implementation of brdr for QGIS can be found at GitHub-brdrQ. This QGIS- script provides a User Interface to align thematic data to a reference layer, showing the results in the QGIS Table of Contents.\n\n\n\n\nYou can install the latest release of brdr from GitHub or PyPi:\npip install brdr\n\n\n\nfrom brdr.aligner import Aligner\nfrom brdr.enums import OpenbaarDomeinStrategy\nfrom brdr.geometry_utils import geom_from_wkt\nfrom brdr.loader import DictLoader\n\n# CREATE AN ALIGNER\naligner = Aligner(\n    crs=\"EPSG:31370\",\n)\n# ADD A THEMATIC POLYGON TO THEMATIC DICTIONARY and LOAD into Aligner\nthematic_dict = {\"theme_id_1\": geom_from_wkt(\"POLYGON ((0 0, 0 9, 5 10, 10 0, 0 0))\")}\nloader = DictLoader(thematic_dict)\naligner.load_thematic_data(loader)\n# ADD A REFERENCE POLYGON TO REFERENCE DICTIONARY and LOAD into Aligner\nreference_dict = {\"ref_id_1\": geom_from_wkt(\"POLYGON ((0 1, 0 10,8 10,10 1,0 1))\")}\nloader = DictLoader(reference_dict)\naligner.load_reference_data(loader)\n# EXECUTE THE ALIGNMENT\nrelevant_distance = 1\nprocess_result = aligner.process(\n    relevant_distance=relevant_distance,\n    od_strategy=OpenbaarDomeinStrategy.SNAP_SINGLE_SIDE,\n    threshold_overlap_percentage=50,\n)\n# PRINT RESULTS IN WKT\nprint(\"result: \" + process_result[\"theme_id_1\"][relevant_distance][\"result\"].wkt)\nprint(\n    \"added area: \"\n    + process_result[\"theme_id_1\"][relevant_distance][\"result_diff_plus\"].wkt\n)\nprint(\n    \"removed area: \"\n    + process_result[\"theme_id_1\"][relevant_distance][\"result_diff_min\"].wkt\n)\nThe resulting figure shows:\n\nthe reference polygon (yellow-black)\nthe original geometry (blue)\nthe resulting geometry (green line)\nthe added zone (green squares)\nthe removed zone (red squares) \n\nMore examples can be found in Examples\n\n\n\n(see also Basic example)\nTo use brdr, follow these steps:\n\nCreate a Aligner-class with specific parameters:\n\nrelevant_distance (m) (default: 1): Distance-parameter used to decide which parts will be aligned, and which parts remain unchanged.\nod_strategy (enum) (default: SNAP_SINGLE_SIDE): Strategy to align geodata that is not covered by reference-data\nthreshold_overlap_percentage (%)(0-100) (default 50)\ncrs: The Coordinate Reference System (CRS) (default: EPSG:31370 - Belgian Lambert72)\n\nLoad thematic data\nLoad reference data\nProcess (align) the thematic data\nResults are returned:\n\nResulting geometry\nDifferences: parts that are ‘different’ from the original geometry (positive or negative)\nPositive differences: parts that are added to the original geometry\nNegative differences: parts that are removed form the original geometry\nRelevant intersections: relevant intersecting parts of the reference geometries\nRelevant differences: relevant differences of the reference geometries\n\n\n\n\n\nThe algorithm for alignment is based on 2 main principles:\n\nPrinciple of intentionality: Thematic boundaries can consciously or unconsciously deviate from the reference borders. The algorithm should keep notice of that.\nSelective spatial conservation of shape: The resulting geometry should re-use the shape of the reference borders where aligned is of relevance.\n\nThe figure below shows a schematic overview of the algorithm: \nThe algorithm can be split into 3 main phases:\n\nInitialisation:\n\nDeciding which reference polygons are candidate-polygons to re-use its shape. The reference candidate polygons are selected based on spatial intersection with the thematic geometry.\n\nProcessing:\n\nProcess all candidate-reference polygons one-by-one\nCalculate relevant zones for each candidate-reference-polygon\n\nrelevant intersections: zones that must be present in the final result\nrelevant differences: zones that must be excluded from the final result \n\nEvaluate each candidate based on their relative zones: which parts must be kept and which parts must be excluded \nUnion all kept parts to recompose a resulting geometry\n\nPost-processing:\n\nValidation/correction of differences between the original input geometry and the composed intermediate resulting geometry after processing the algorithm\nTechnical validation of inner holes and multipolygons that are created by processing the algorithm\nClean-up slivers\nMake the resulting geometry valid\n\n\nRESULT:\nA new resulting output geometry, aligned to the reference-polygons\n\n\n\n\n\nPIP_COMPILE_ARGS=\"-v --strip-extras --no-header --resolver=backtracking --no-emit-options --no-emit-find-links\"\npip-compile $PIP_COMPILE_ARGS\npip-compile $PIP_COMPILE_ARGS -o requirements-dev.txt --all-extras\n\n\n\npython - m\npytest - -cov = brdr\ntests / --cov - report\nterm - missing\n\n\n\nAs an example-usage (proof-of-concept), a Dockerfile is created to set up a GRB-specific webservice that ‘predicts’ one or multiple actual geometries for a input-geometry based on the reference source GRB. This webservice is based on ‘brdr’.\nThis POC can be found at brdr-webservice (GRB-actualisator).\ndocker build -f Dockerfile . -t grb_webservice\ndocker run --rm -p 80:80 --name grb_webservice grb_webservice\n\n\nexample can be found at: http://localhost:80/docs#/default/actualiser_actualiser_post\n\n\n\n\nA more in-depth description of the algorithm can be found in the following article (in dutch):\n\nDieussaert, K., Vanvinckenroye, M., Vermeyen, M., & Van Daele, K. (2024). Grenzen verleggen. Automatische correcties van geografische afbakeningen op verschuivende onderlagen Onderzoeksrapporten Agentschap Onroerend Erfgoed,\n\nhttps://doi.org/10.55465/SXCW6218.\n\n\n\n\n\nWe would love to hear from you and your experiences with brdr or its sister project brdrQ. The discussions forum is the place to be when:\n\nYou have any questions on using brdr or brdrQ or their applicability to your use cases\nWant to share your experiences with the library\nHave any suggestions for improvements or feature requests\n\nIf you have discovered a bug in the brdr library you can report it here:\nhttps://github.com/OnroerendErfgoed/brdr/issues\nWe try to keep the list of issues as clean as possible. If you’re unsure whether something is a bug, or whether the bug is in brdr or brdrQ, we encourage you to go through the discussions forum first.\n\n\n\nThis software was created by Athumi, the Flemish data utility company, and Flanders Heritage Agency."
  },
  {
    "objectID": "index.html#description",
    "href": "index.html#description",
    "title": "brdr",
    "section": "",
    "text": "brdr is a Python package that assists in aligning geometric boundaries to reference boundaries. This is an important task in geographic data management to enhance data quality.\n\nIn the context of geographic data management, it is important to have accurate and consistent boundaries for a variety of applications such as calculating areas, analyzing spatial relationships, and visualizing and querying geographic information.\nWhen creating geographic data, it is often more efficient to derive boundaries from existing reference data rather than collecting new data in the field.\nbrdr can be used to align boundaries from new data to reference data, ensuring that the boundaries are accurate and consistent.\n\n\n\n\nThe figure below shows:\n\nthe original thematic geometry (blue),\nA reference layer (yellow-black).\nThe resulting geometry after alignment with brdr (green)\n\n\n\n\n\nbrdr provides a variety of functionalities in the Aligner-class to assist in aligning boundaries, including:\n\nLoaders:\n\naligner.load_thematic_data():Loading thematic data ((Multi-)Polygons) as a dictionary (DictLoader) or geojson ( GeoJsonFileLoader,GeoJsonUrlLoader)\naligner.load_reference_data():Loading reference data ((Multi-)Polygons) as a dictionary (DictLoader) or geojson ( GeoJsonFileLoader,GeoJsonUrlLoader)\n\nProcessors:\n\naligner.process(): Align thematic boundaries to reference boundaries with a specific relevant distance or a range of relevant distances\naligner.predictor(): Searches all ‘stable’ (=predicted) processresults in a range of relevant distances\naligner.get_brdr_formula(): Calculating a descriptive formula of a thematic boundary based on a reference layer\nevaluate(): Compares & evaluates input geometries with another version and adds a EVALUATION_FIELD_NAME\n\nExporters:\n\naligner.get_results_as_geojson(): Returns a collection of geojson-dictionaries with the processresults (resulting geometry, differences,…): This can be used for all processresults or only the ‘predicted’ results\naligner.get_input_as_geojson(): Returns a geojson-featurecollection from input-dictionaries (thematic or reference)\naligner.save_results(): Exports the resuling geojson-files to a specified path:This can be used for all processresults or only the ‘predicted’ results\n\n\nBesides the generic functionalities, a range of Flanders-specific functionalities are provided:\n\nLoaders:\n\nGRBActualLoader: Loading actual GRB (parcels, buildings)\nGRBFiscalParcelLoader: Loading fiscal GRB-parcels of a specific year\n\nProcessors:\n\ngrb.get_geoms_affected_by_grb_change(): get thematic geometries that are possibly affected by GRB-changes during a specific timespan\ngrb.update_to_actual_grb(): aligns the boundaries of thematic features to the actual GRB-boundaries\n\n\n\n\n\n\nGeodata-management:\n\nImplementation of brdr in business-processes and tooling\nBulk geodata-alignment\nAlignment after reprojection of data\nCleaning data: In a postprocessing-phase, the algorithm executes sliver-cleanup and validity-cleaning on the resulting geometries\n…\n\nData-Analysis: Investigate the pattern in deviation and change between thematic and reference boundaries\nUpdate-detection: Investigate the descriptive formula before and after alignment to check for (automatic) alignment of geodata\n…\n\n\n\n\nAn implementation of brdr for QGIS can be found at GitHub-brdrQ. This QGIS- script provides a User Interface to align thematic data to a reference layer, showing the results in the QGIS Table of Contents."
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "brdr",
    "section": "",
    "text": "You can install the latest release of brdr from GitHub or PyPi:\npip install brdr"
  },
  {
    "objectID": "index.html#basic-example",
    "href": "index.html#basic-example",
    "title": "brdr",
    "section": "",
    "text": "from brdr.aligner import Aligner\nfrom brdr.enums import OpenbaarDomeinStrategy\nfrom brdr.geometry_utils import geom_from_wkt\nfrom brdr.loader import DictLoader\n\n# CREATE AN ALIGNER\naligner = Aligner(\n    crs=\"EPSG:31370\",\n)\n# ADD A THEMATIC POLYGON TO THEMATIC DICTIONARY and LOAD into Aligner\nthematic_dict = {\"theme_id_1\": geom_from_wkt(\"POLYGON ((0 0, 0 9, 5 10, 10 0, 0 0))\")}\nloader = DictLoader(thematic_dict)\naligner.load_thematic_data(loader)\n# ADD A REFERENCE POLYGON TO REFERENCE DICTIONARY and LOAD into Aligner\nreference_dict = {\"ref_id_1\": geom_from_wkt(\"POLYGON ((0 1, 0 10,8 10,10 1,0 1))\")}\nloader = DictLoader(reference_dict)\naligner.load_reference_data(loader)\n# EXECUTE THE ALIGNMENT\nrelevant_distance = 1\nprocess_result = aligner.process(\n    relevant_distance=relevant_distance,\n    od_strategy=OpenbaarDomeinStrategy.SNAP_SINGLE_SIDE,\n    threshold_overlap_percentage=50,\n)\n# PRINT RESULTS IN WKT\nprint(\"result: \" + process_result[\"theme_id_1\"][relevant_distance][\"result\"].wkt)\nprint(\n    \"added area: \"\n    + process_result[\"theme_id_1\"][relevant_distance][\"result_diff_plus\"].wkt\n)\nprint(\n    \"removed area: \"\n    + process_result[\"theme_id_1\"][relevant_distance][\"result_diff_min\"].wkt\n)\nThe resulting figure shows:\n\nthe reference polygon (yellow-black)\nthe original geometry (blue)\nthe resulting geometry (green line)\nthe added zone (green squares)\nthe removed zone (red squares) \n\nMore examples can be found in Examples"
  },
  {
    "objectID": "index.html#workflow",
    "href": "index.html#workflow",
    "title": "brdr",
    "section": "",
    "text": "(see also Basic example)\nTo use brdr, follow these steps:\n\nCreate a Aligner-class with specific parameters:\n\nrelevant_distance (m) (default: 1): Distance-parameter used to decide which parts will be aligned, and which parts remain unchanged.\nod_strategy (enum) (default: SNAP_SINGLE_SIDE): Strategy to align geodata that is not covered by reference-data\nthreshold_overlap_percentage (%)(0-100) (default 50)\ncrs: The Coordinate Reference System (CRS) (default: EPSG:31370 - Belgian Lambert72)\n\nLoad thematic data\nLoad reference data\nProcess (align) the thematic data\nResults are returned:\n\nResulting geometry\nDifferences: parts that are ‘different’ from the original geometry (positive or negative)\nPositive differences: parts that are added to the original geometry\nNegative differences: parts that are removed form the original geometry\nRelevant intersections: relevant intersecting parts of the reference geometries\nRelevant differences: relevant differences of the reference geometries"
  },
  {
    "objectID": "index.html#the-brdr-algorithm",
    "href": "index.html#the-brdr-algorithm",
    "title": "brdr",
    "section": "",
    "text": "The algorithm for alignment is based on 2 main principles:\n\nPrinciple of intentionality: Thematic boundaries can consciously or unconsciously deviate from the reference borders. The algorithm should keep notice of that.\nSelective spatial conservation of shape: The resulting geometry should re-use the shape of the reference borders where aligned is of relevance.\n\nThe figure below shows a schematic overview of the algorithm: \nThe algorithm can be split into 3 main phases:\n\nInitialisation:\n\nDeciding which reference polygons are candidate-polygons to re-use its shape. The reference candidate polygons are selected based on spatial intersection with the thematic geometry.\n\nProcessing:\n\nProcess all candidate-reference polygons one-by-one\nCalculate relevant zones for each candidate-reference-polygon\n\nrelevant intersections: zones that must be present in the final result\nrelevant differences: zones that must be excluded from the final result \n\nEvaluate each candidate based on their relative zones: which parts must be kept and which parts must be excluded \nUnion all kept parts to recompose a resulting geometry\n\nPost-processing:\n\nValidation/correction of differences between the original input geometry and the composed intermediate resulting geometry after processing the algorithm\nTechnical validation of inner holes and multipolygons that are created by processing the algorithm\nClean-up slivers\nMake the resulting geometry valid\n\n\nRESULT:\nA new resulting output geometry, aligned to the reference-polygons"
  },
  {
    "objectID": "index.html#development",
    "href": "index.html#development",
    "title": "brdr",
    "section": "",
    "text": "PIP_COMPILE_ARGS=\"-v --strip-extras --no-header --resolver=backtracking --no-emit-options --no-emit-find-links\"\npip-compile $PIP_COMPILE_ARGS\npip-compile $PIP_COMPILE_ARGS -o requirements-dev.txt --all-extras\n\n\n\npython - m\npytest - -cov = brdr\ntests / --cov - report\nterm - missing\n\n\n\nAs an example-usage (proof-of-concept), a Dockerfile is created to set up a GRB-specific webservice that ‘predicts’ one or multiple actual geometries for a input-geometry based on the reference source GRB. This webservice is based on ‘brdr’.\nThis POC can be found at brdr-webservice (GRB-actualisator).\ndocker build -f Dockerfile . -t grb_webservice\ndocker run --rm -p 80:80 --name grb_webservice grb_webservice\n\n\nexample can be found at: http://localhost:80/docs#/default/actualiser_actualiser_post"
  },
  {
    "objectID": "index.html#motivation-citation",
    "href": "index.html#motivation-citation",
    "title": "brdr",
    "section": "",
    "text": "A more in-depth description of the algorithm can be found in the following article (in dutch):\n\nDieussaert, K., Vanvinckenroye, M., Vermeyen, M., & Van Daele, K. (2024). Grenzen verleggen. Automatische correcties van geografische afbakeningen op verschuivende onderlagen Onderzoeksrapporten Agentschap Onroerend Erfgoed,\n\nhttps://doi.org/10.55465/SXCW6218."
  },
  {
    "objectID": "index.html#comments-and-contributions",
    "href": "index.html#comments-and-contributions",
    "title": "brdr",
    "section": "",
    "text": "We would love to hear from you and your experiences with brdr or its sister project brdrQ. The discussions forum is the place to be when:\n\nYou have any questions on using brdr or brdrQ or their applicability to your use cases\nWant to share your experiences with the library\nHave any suggestions for improvements or feature requests\n\nIf you have discovered a bug in the brdr library you can report it here:\nhttps://github.com/OnroerendErfgoed/brdr/issues\nWe try to keep the list of issues as clean as possible. If you’re unsure whether something is a bug, or whether the bug is in brdr or brdrQ, we encourage you to go through the discussions forum first."
  },
  {
    "objectID": "index.html#acknowledgement",
    "href": "index.html#acknowledgement",
    "title": "brdr",
    "section": "",
    "text": "This software was created by Athumi, the Flemish data utility company, and Flanders Heritage Agency."
  },
  {
    "objectID": "reference/GeoJsonUrlLoader.html",
    "href": "reference/GeoJsonUrlLoader.html",
    "title": "GeoJsonUrlLoader",
    "section": "",
    "text": "GeoJsonUrlLoader\nloader.GeoJsonUrlLoader(url, id_property)",
    "crumbs": [
      "Reference",
      "Loaders",
      "GeoJsonUrlLoader"
    ]
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "Aligner class of the brdr package.\n\n\n\nAligner\nThis class is used to compare and align the thematic data with the reference data.\n\n\n\n\n\n\nLoaders to load data\n\n\n\nLoader\n\n\n\nDictLoader\n\n\n\nGeoJsonLoader\n\n\n\nGeoJsonFileLoader\n\n\n\nGeoJsonUrlLoader\n\n\n\n\n\n\n\nGRB specific loaders - grb.GRBActualLoader - grb.GRBFiscalParcelLoader - grb.GRBSpecificDateParcelLoader",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#aligner",
    "href": "reference/index.html#aligner",
    "title": "Function reference",
    "section": "",
    "text": "Aligner class of the brdr package.\n\n\n\nAligner\nThis class is used to compare and align the thematic data with the reference data.",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#loaders",
    "href": "reference/index.html#loaders",
    "title": "Function reference",
    "section": "",
    "text": "Loaders to load data\n\n\n\nLoader\n\n\n\nDictLoader\n\n\n\nGeoJsonLoader\n\n\n\nGeoJsonFileLoader\n\n\n\nGeoJsonUrlLoader",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#grb",
    "href": "reference/index.html#grb",
    "title": "Function reference",
    "section": "",
    "text": "GRB specific loaders - grb.GRBActualLoader - grb.GRBFiscalParcelLoader - grb.GRBSpecificDateParcelLoader",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/Loader.html",
    "href": "reference/Loader.html",
    "title": "Loader",
    "section": "",
    "text": "Loader\nloader.Loader()",
    "crumbs": [
      "Reference",
      "Loaders",
      "Loader"
    ]
  }
]